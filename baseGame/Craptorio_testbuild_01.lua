-- title:   Craptorio
-- author:  @ArchaicVirus
-- desc:    De-make of Factorio
-- site:    https://github.com/archaicvirus/Craptorio
-- license: MIT License
-- version: 1.0
-- script: lua

vec2 = {}
vec2_mt = {}
vec2_mt.__index = vec2_mt

function vec2_mt:__add( v )
  return vec2(self.x + v.x, self.y + v.y)
end

function vec2_mt:__sub( v )
  return vec2(self.x - v.x, self.y - v.y)
end

function vec2_mt:__mul( v )
  if type(v) == "table"
  then return vec2(self.x * v.x, self.y * v.y)
  else return vec2(self.x * v, self.y * v) end
end

function vec2_mt:__div( v )
  if type(v) == "table"
  then return vec2(self.x / v.x, self.y / v.y)
  else return vec2(self.x / v, self.y / v) end
end

function vec2_mt:__unm()
  return vec2(-self.x, -self.y)
end

function vec2_mt:dot( v )
  return self.x * v.x + self.y * v.y
end

function vec2_mt:length()
  return math.sqrt(self.x * self.x + self.y * self.y)
end

function vec2_mt:distance(v)
  return ((self.x - v.x) ^ 2 + (self.y - v.y) ^ 2) ^ 0.5
end

function vec2_mt:normalize()
  local length = self:length()
  if length == 0 then
    return vec2(0, 0)
  end
  return vec2(self.x / length, self.y / length)
end

function vec2_mt:rotate(angle)
  local cs = math.cos(angle)
  local sn = math.sin(angle)
  return vec2(self.x * cs - self.y * sn, self.x * sn + self.y * cs)
end
  
function vec2_mt:div()
  return self.x / self.y
end

function vec2_mt:min(v)
  if type(v) == "table"
  then return vec2(math.min(self.x, v.x), math.min(self.y, v.y))
  else return math.min(self.x, self.y) end
end

function vec2_mt:max(v)
  if type(v) == "table"
  then return vec2(math.max(self.x, v.x), math.max(self.y, v.y))
  else return math.max(self.x, self.y) end
end

function vec2_mt:abs()
  return vec2(math.abs(self.x), math.abs(self.y))
end

function vec2_mt:mix(v, n)
  return self * n + v * math.max(0, 1 - n)
end

function vec2_mt:__tostring()
  return ("(%g | %g)"):format(self:tuple())
end

function vec2_mt:tuple()
  return self.x, self.y
end

setmetatable(vec2, {__call = function(V, x, y ) return setmetatable({x = x or 0, y = y or x or 0}, vec2_mt) end})

ITEMS = {
  [0] = false,
  [1] = {
    name = 'advanced_circuit',
    fancy_name = 'Advanced Circuit',
    id = 1,
    sprite_id = 457,
    belt_id = 296,
    color_key = 0,
    type = 'consumable',
    craftable = {'player', 'machine'},
    sub_type = 'icon_only',
    stack_size = 100,
    recipe = {
      id = 1,
      crafting_time = 60*6,
      count = 1,
      ingredients = {
        [1] = {id = 21, count = 4}, --copper_cable
        [2] = {id = 2, count = 2}, --green_circuit
        [3] = {id = 36, count = 2}, --plastic_bar
      },
    }
  },
  [2] = {
    name = 'electronic_circuit',
    fancy_name = 'Electronic Circuit',
    id = 2,
    sprite_id = 456,
    belt_id = 280,
    color_key = 0,
    type = 'consumable',
    craftable = {'player', 'machine'},
    sub_type = 'icon_only',
    stack_size = 100,
    recipe = {
      id = 2,
      crafting_time = 60*0.5,
      count = 1,
      ingredients = {
        [1] = {id = 21, count = 3}, --copper_cable
        [2] = {id = 15, count = 1}, --iron_plate
      }
    },
  },
  [3] = {
    name = 'iron_ore',
    fancy_name = 'Iron Ore',
    info = 'Collected by laser, or mining drill. Found at iron ore deposits in the wild',
    id = 3,
    sprite_id = 162,
    smelted_id = 15,
    belt_id = 178,
    color_key = 4,
    --alt_ids = {256, }
    type = 'ore',
    craftable = false,
    stack_size = 100,
    smelting_time = 1 * 60,
    mining_time = 4 * 60,
    recipe = false,
  },
  [4] = {
    name = 'copper_ore',
    fancy_name = 'Copper Ore',
    info = 'Collected by laser, or mining drill. Found at copper ore deposits in the wild',
    id = 4,
    sprite_id = 161,
    belt_id = 177,
    color_key = 1,
    type = 'ore',
    craftable = false,
    stack_size = 100,
    smelted_id = 16,
    smelting_time = 5 * 60,
    mining_time = 4 * 60,
    recipe = false,
  },
  [5] = {
    name = 'stone',
    fancy_name = 'Stone Ore',
    info = 'Collected by laser, or mining drill. Found at stone ore deposits, and loose stones in the wild',
    id = 5,
    sprite_id = 160,
    belt_id = 176,
    color_key = 4,
    type = 'ore',
    craftable = false,
    stack_size = 100,
    smelted_id = 17,
    smelting_time = 2 * 60,
    mining_time = 2 * 60,
    recipe = false,
  },
  [6] = {
    name = 'coal',
    fancy_name = 'Coal',
    info = 'Collected by laser, or mining drill. Found at coal ore deposits in the wild',
    id = 6,
    sprite_id = 163,
    belt_id = 179,
    color_key = 4,
    type = 'fuel',
    craftable = false,
    stack_size = 100,
    fuel_time = 60*15,
    mining_time = 3 * 60,
    recipe = false,
  },
  [7] = {
    name = 'uranium',
    fancy_name = 'Uranium Ore',
    info = 'Collected by mining drill only. Found at uranium ore deposits in the wild',
    id = 7,
    sprite_id = 164,
    belt_id = 180,
    color_key = 4,
    type = 'liquid',
    craftable = false,
    stack_size = 100,
    smelting_time = 5 * 60,
    mining_time = 4 * 60,
    recipe = false,
  },
  [8] = {
    name = 'oil_shale',
    fancy_name = 'Oil Shale',
    info = 'Collected by laser, or mining drill. Found at oil-shale deposits in the wild',
    id = 8,
    sprite_id = 165,
    belt_id = 181,
    color_key = 4,
    type = 'liquid',
    craftable = false,
    stack_size = 100,
    smelting_time = 5 * 60,
    mining_time = 4 * 60,
    recipe = false,
  },
  [9] = {
    name = 'transport_belt',
    fancy_name = 'Transport Belt',
    id = 9,
    sprite_id = 256,
    belt_id = 434,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 100,
    recipe = {
      id = 9,
      crafting_time = 60*0.5,
      count = 2,
      ingredients = {
        [1] = {id = 20, count = 1},
        [2] = {id = 15, count = 1},
      }
    },
  },
  [10] = {
    name = 'splitter',
    fancy_name = 'Splitter',
    id = 10,
    sprite_id = 323,
    belt_id = 433,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 100,
    recipe = {
      id = 10,
      crafting_time = 60*1,
      count = 2,
      ingredients = {
        [1] = {id = 2, count = 5},
        [2] = {id = 15, count = 5},
        [3] = {id = 9, count = 4},
      }
    },
  },
  [11] = {
    name = 'inserter',
    fancy_name = 'Inserter',
    id = 11,
    sprite_id = 267,
    belt_id = 417,
    color_key = 15,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 100,
    recipe = {
      id = 11,
      crafting_time = 60*0.5,
      count = 1,
      ingredients = {
        [1] = {id = 2, count = 1},
        [2] = {id = 20, count = 1},
        [3] = {id = 15, count = 1},
      }
    },
  },
  [12] = {
    name = 'power_pole',
    fancy_name = 'Power Pole',
    id = 12,
    sprite_id = 478,
    belt_id = 433,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 100,
    recipe = {},
  },
  [13] = {
    name = 'mining_drill',
    fancy_name = 'Mining Drill',
    id = 13,
    sprite_id = 276,
    belt_id = 416,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 50,
    recipe = {
      id = 13,
      crafting_time = 60*2,
      count = 2,
      ingredients = {
        [1] = {id = 2, count = 3},
        [2] = {id = 15, count = 10},
        [3] = {id = 20, count = 5}
      },
    }
  },
  [14] = {
    name = 'stone_furnace',
    fancy_name = 'Stone Furnace',
    id = 14,
    sprite_id = 503,
    belt_id = 502,
    color_key = 6,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 50,
    recipe = {
      id = 14,
      crafting_time = 60*0.5,
      count = 1,
      ingredients = {
        [1] = {id = 5, count = 5}
      },
    }
  },
  [15] = {
    name = 'iron_plate',
    fancy_name = 'Iron Plate',
    info = 'Obtained via smelting iron ore in a furnace',
    id = 15,
    sprite_id = 448,
    belt_id = 299,
    color_key = 1,
    type = 'ore',
    craftable = false,
    stack_size = 50,
    smelted_id = 27,
    required_tech = 4,
    smelting_time = 5 * 60,
    recipe = false,
  },
  [16] = {
    name = 'copper_plate',
    fancy_name = 'Copper Plate',
    info = 'Obtained via smelting copper ore in a furnace',
    id = 16,
    sprite_id = 449,
    belt_id = 300,
    color_key = 1,
    type = 'intermediate',
    craftable = false,
    stack_size = 50,
    recipe = false,
  },
  [17] = {
    name = 'stone_brick',
    fancy_name = 'Stone Brick',
    info = 'Obtained via smelting stone ore in a furnace',
    id = 17,
    sprite_id = 450,
    belt_id = 282,
    color_key = 1,
    type = 'intermediate',
    craftable = false,
    stack_size = 50,
    smelting_time = 10,
    recipe = false,
  },
  [18] = {
    name = 'underground_belt',
    fancy_name = 'Underground Belt',
    id = 18,
    sprite_id = 301,
    belt_id = 279,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    stack_size = 50,
    recipe = {
      id = 18,
      crafting_time = 60*1,
      count = 2,
      ingredients = {
        [1] = {id = 15, count = 10}, --plate
        [2] = {id = 9, count = 5}, --transport_belt
      }
    },
  },
  [19] = {
    name = 'assembly_machine',
    fancy_name = 'Assembly Machine',
    id = 19,
    sprite_id = 331,
    belt_id = 347,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 21,
      crafting_time = 60*0.5,
      count = 2,
      ingredients = {
        [1] = {id = 2, count = 3},
        [2] = {id = 20, count = 5},
        [3] = {id = 15, count = 9},
      },
    }
  },
  [20] = {
    name = 'gear',
    fancy_name = 'Gear',
    id = 20,
    sprite_id = 452,
    belt_id = 432,
    color_key = 0,
    type = 'intermediate',
    craftable = {'player', 'machine'},
    stack_size = 100,
    recipe = {
      id = 20,
      crafting_time = 60*0.5,
      count = 1,
      ingredients = {
        [1] = {id = 15, count = 2}
      }
    }
  },
  [21] = {
    name = 'copper_cable',
    fancy_name = 'Copper Cable',
    sprite_id = 453,
    id = 21,
    belt_id = 281,
    color_key = 0,
    type = 'intermediate',
    craftable = {'player', 'machine'},
    sub_type = 'craftable',
    stack_size = 100,
    recipe = {
      id = 21,
      crafting_time = 60*0.5,
      count = 2,
      ingredients = {
        [1] = {id = 16, count = 1}
      },
    }
  },
  [22] = {
    name = 'research_lab',
    fancy_name = 'Research Lab',
    sprite_id = 399,
    id = 22,
    belt_id = 281,
    color_key = 0,
    type = 'placeable',
    craftable = {'player', 'machine'},
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 22,
      crafting_time = 60*2,
      count = 1,
      ingredients = {
        [1] = {id = 2, count = 10},
        [2] = {id = 20, count = 10},
        [3] = {id = 9, count = 4}
      },
    }
  },
  [23] = {
    name = 'automation_pack',
    fancy_name = 'Automation Pack',
    id = 23,
    sprite_id = 460,
    belt_id = 444,
    color_key = 0,
    type = 'intermediate',
    craftable = {'player', 'machine'},
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 23,
      crafting_time = 60*5,
      count = 1,
      ingredients = {
        [1] = {id = 16, count = 1},
        [2] = {id = 20, count = 1}
      },
    }
  },
  [24] = {
    name = 'logistics_pack',
    fancy_name = 'Logistics Pack',
    id = 24,
    sprite_id = 461,
    belt_id = 445,
    color_key = 0,
    type = 'intermediate',
    craftable = {'player', 'machine'},
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 24,
      crafting_time = 60*6,
      count = 1,
      ingredients = {
        [1] = {id = 11, count = 1},
        [2] = {id =  9, count = 1}
      },
    }
  },
  [25] = {
    name = 'biology_pack',
    fancy_name = 'Biology Pack',
    info = 'Crafed in a Bio Refinery',
    id = 25,
    sprite_id = 462,
    belt_id = 446,
    color_key = 0,
    type = 'oil',
    craftable = true,
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 25,
      crafting_time = 60*10,
      count = 1,
      ingredients = {
        [1] = {id = 32, count = 25},
        [2] = {id = 6, count = 5},
        [3] = {id = 8, count = 10}
      },
    }
  },
  [26] = {
    name = 'production_pack',
    fancy_name = 'Production Pack',
    id = 26,
    sprite_id = 463,
    belt_id = 447,
    color_key = 0,
    type = 'intermediate',
    craftable = true,
    sub_type = 'craftable',
    stack_size = 50,
    recipe = {
      id = 26,
      crafting_time = 60*20,
      count = 1,
      ingredients = {
        [1] = {id = 30, count = 1},
        [2] = {id = 27, count = 5},
        [3] = {id = 37, count = 1}
      },
    }
  },
  [27] = {
    name = 'steel_plate',
    fancy_name = 'Steel Plate',
    info = 'Obtained via smelting 2x iron plates in a furnace',
    id = 27,
    sprite_id = 468,
    belt_id = 469,
    color_key = 1,
    type = 'intermediate',
    craftable = false,
    stack_size = 50,
    smelting_time = 180,
    recipe = false,
  },
  [28] = {
    name = 'wood',
    fancy_name = 'Wood Planks',
    info = 'Obtained via chopping trees in the wild',
    id = 28,
    sprite_id = 451,
    belt_id = 467,
    color_key = 0,
    type = 'fuel',
    craftable = false,
    stack_size = 100,
    fuel_time = 1 * 2 * 60,
    recipe = false
  },
  [29] = {
    name = 'solar_panel',
    fancy_name = 'Solar Panel',
    id = 29,
    sprite_id = 510,
    belt_id = 493,
    color_key = 1,
    type = 'placeable',
    craftable = true,
    stack_size = 50,
    recipe = {
      id = 29,
      crafting_time = 4.5 * 60,
      count = 1,
      ingredients = {
        [1] = {id = 16, count = 5},
        [2] = {id = 2, count = 15},
        [3] = {id = 27, count = 5},
      },
    }
  },
  [30] = {
    name = 'bio_refinery',
    fancy_name = 'Bio-Refinery',
    id = 30,
    sprite_id = 374,
    belt_id = 390,
    color_key = 1,
    type = 'placeable',
    craftable = true,
    stack_size = 10,
    recipe = {
      id = 30,
      crafting_time = 10 * 60,
      count = 1,
      ingredients = {
        [1] = {id = 16, count = 5},
        [2] = {id = 2, count = 15},
        [3] = {id = 27, count = 5},
      },
    }
  },
  [31] = {
    name = 'engine_unit',
    fancy_name = 'Biofuel Engine',
    id = 31,
    sprite_id = 483,
    belt_id = 484,
    color_key = 1,
    type = 'intermediate',
    craftable = false,
    stack_size = 5,
    recipe = {
      id = 31,
      crafting_time = 10 * 60,
      count = 1,
      ingredients = {
        [1] = {id = 20, count = 3},
        [2] = {id = 27, count = 2},
        [3] = {id = 2, count = 1},
      },
    }
  },
  [32] = {
    name = 'fiber',
    fancy_name = 'Organic Fibers',
    info = 'Acquired via laser mining or made in Bio Refinery',
    id = 32,
    sprite_id = 268,
    belt_id = 269,
    color_key = 0,
    type = 'oil',
    craftable = false,
    stack_size = 200,
    recipe = {
      id = 32,
      crafting_time = 60 * 3,
      count = 50,
      ingredients = {
        [1] = {id = 28, count = 10},
      },
    },
  },
  [33] = {
    name = 'chest',
    fancy_name = 'Storage Chest',
    id = 33,
    sprite_id = 464,
    belt_id = 470,
    color_key = 0,
    type = 'placeable',
    craftable = true,
    stack_size = 50,
    recipe = {
      id = 33,
      crafting_time = 60 * 3,
      count = 1,
      ingredients = {
        [1] = {id = 28, count = 10},
      },
    },
  },
  [34] = {
    name = 'laser_mining_speed',
    fancy_name = 'Laser Mining 1 Upgrade',
    info = 'Increases mining speed by 150%',
    id = 34,
    sprite_id = 358,
    belt_id = -1,
    color_key = 1,
    type = 'upgrade',
    craftable = false,
    recipe = false,
  },
  [35] = {
    name = 'biofuel',
    fancy_name = 'Solid Biofuel',
    info = 'Crafed in a Bio Refinery',
    id = 35,
    sprite_id = 482,
    belt_id = 481,
    color_key = 6,
    type = 'oil',
    craftable = false,
    stack_size = 20,
    recipe = {
      id = 35,
      crafting_time = 60 * 3,
      count = 5,
      ingredients = {
        [1] = {id = 6, count = 1},
        [2] = {id = 8, count = 5},
        [3] = {id = 32, count = 10},
      },
    },
  },
  [36] = {
    name = 'plastic_bar',
    fancy_name = 'Plastic Bar',
    info = 'Crafed in a Bio Refinery',
    id = 36,
    sprite_id = 455,
    belt_id = 471,
    color_key = 0,
    type = 'oil',
    craftable = false,
    stack_size = 100,
    recipe = {
      id = 36,
      crafting_time = 15,
      count = 2,
      ingredients = {
        [1] = {id = 6, count = 1},
        [2] = {id = 8, count = 5},
        [3] = {id = 32, count = 10},
      },
    },
  },
  [37] = {
    name = 'processing_unit',
    fancy_name = 'Processing Unit',
    info = 'Crafed in a Bio Refinery',
    id = 36,
    sprite_id = 472,
    belt_id = 295,
    color_key = 0,
    type = 'oil',
    craftable = false,
    stack_size = 100,
    recipe = {
      id = 37,
      crafting_time = 10,
      count = 2,
      ingredients = {
        [1] = {id = 2, count = 10},
        [2] = {id = 1, count = 10},
        [3] = {id = 35, count = 10},
      },
    },
  },
  [38] = {
    name = 'laser_mining_speed2',
    fancy_name = 'Laser Mining 2 Upgrade',
    info = 'Increases mining speed by +150%',
    id = 38,
    sprite_id = 359,
    belt_id = -1,
    color_key = 1,
    type = 'upgrade',
    craftable = false,
    recipe = false,
  },
  [39] = {
    name = 'laser_mining_speed3',
    fancy_name = 'Laser Mining 3 Upgrade',
    info = 'Increases mining speed by +150%',
    id = 39,
    sprite_id = 359,
    belt_id = -1,
    color_key = 1,
    type = 'upgrade',
    craftable = false,
    recipe = false,
  },
  [40] = {
    name = 'rocket_silo',
    fancy_name = 'Rocket Silo',
    info = 'placeholder rocket text',
    id = 40,
    sprite_id = 386,
    belt_id = 402,
    color_key = 1,
    type = 'placeable',
    craftable = true,
    stack_size = 1,
    recipe = {
      id = 40,
      crafting_time = 60*10,
      count = 2,
      ingredients = {
        [1] = {id = 17, count = 250},
        [2] = {id = 15, count = 100},
        [3] = {id = 16, count = 100},
        [4] = {id = 45, count = 100},
        
      },
    },
  },
  [41] = {
    name = 'rocket_part',
    fancy_name = 'Rocket Part',
    info = 'An intermediate product used in repairing rockets',
    id = 41,
    sprite_id = 400,
    belt_id = 401,
    color_key = 0,
    type = 'intermediate',
    craftable = true,
    stack_size = 100,
    recipe = {
      id = 41,
      crafting_time = 60*5,
      count = 2,
      ingredients = {
        [1] = {id = 2, count = 10},
        [2] = {id = 1, count = 10},
        [3] = {id = 17, count = 25},
        [4] = {id = 15, count = 25},
      },
    },
  },
  [42] = {
    name = 'rocket_fuel',
    fancy_name = 'Rocket Fuel',
    info = 'Like my grandpa\'s whiskey',
    id = 42,
    sprite_id = 391,
    belt_id = 377,
    color_key = 0,
    type = 'oil',
    craftable = false,
    stack_size = 100,
    recipe = {
      id = 42,
      crafting_time = 60*5,
      count = 5,
      ingredients = {
        [1] = {id = 15, count = 5},
        [2] = {id = 16, count = 5},
        [3] = {id = 45, count = 10},
        [4] = {id = 35, count = 10},
      },
    },
  },
  [43] = {
    name = 'rocket_control_unit',
    fancy_name = 'Rocket Control Unit',
    info = 'High-tech electronics used to re-build rockets',
    id = 43,
    sprite_id = 375,
    belt_id = 376,
    color_key = 0,
    type = 'intermediate',
    craftable = true,
    stack_size = 100,
    recipe = {
      id = 43,
      crafting_time = 60*5,
      count = 2,
      ingredients = {
        [1] = {id = 37, count = 5},
        [2] = {id = 1, count = 10},
        [3] = {id = 2, count = 10},
        [4] = {id = 15, count = 5},
      },
    },
  },
  [44] = {
    name = 'rocket_science_pack',
    fancy_name = 'Rocket Science Pack',
    info = 'Obtained from a Rocket Silo after launching a rocket into space',
    id = 44,
    sprite_id = 495,
    belt_id = 479,
    color_key = 0,
    type = 'intermediate',
    craftable = false,
    stack_size = 100,
    recipe = {
      id = 44,
      crafting_time = 60*1.5,
      count = 1000,
      ingredients = {
        [1] = {id = 41, count = 100},
        [2] = {id = 42, count = 100},
        [3] = {id = 43, count = 100},
      },
    },
  },
  [45] = {
    name = 'refined_oil_chunk',
    fancy_name = 'Refined Oil Chunk',
    info = 'Condensed heavy oil, used in high-grade fuels',
    id = 45,
    sprite_id = 283,
    belt_id = 284,
    color_key = 1,
    type = 'oil',
    craftable = false,
    stack_size = 50,
    recipe = {
      id = 45,
      crafting_time = 60*1.5,
      count = 2,
      ingredients = {
        [1] = {id = 8, count = 10},
      },
    },
  },
}

cover = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,15,15,15,15,0,15,0,15,0,0,15,0,0,0,0,0,15,15,15,15,15,15,15,14,15,14,14,15,14,15,0,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,0,0,0,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,14,14,15,15,15,15,15,15,15,15,15,15,0,15,0,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,0,0,0,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,15,0,0,0,0,0,0,0,0,0,15,0,15,0,15,15,15,0,15,15,15,15,15,15,15,0,0,0,15,0,15,0,15,15,15,15,15,15,14,14,15,14,15,15,15,15,15,15,15,15,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,0,0,15,15,14,15,14,14,14,14,14,14,14,14,14,15,14,0,14,15,15,15,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,13,14,14,14,14,14,14,14,15,15,15,15,15,15,15,14,15,15,15,15,15,15,15,15,15,15,0,15,15,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,15,15,15,15,0,15,15,0,15,0,15,0,0,0,0,15,15,0,15,0,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,15,15,15,15,15,0,15,0,15,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,15,0,15,0,0,0,15,15,15,15,15,14,15,15,14,15,15,14,14,15,14,14,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,0,0,14,15,14,14,14,14,14,14,14,14,13,14,14,15,14,14,0,15,15,0,15,15,15,15,15,14,14,14,14,13,14,14,13,14,14,13,14,14,14,13,14,14,14,13,14,14,14,14,14,14,15,14,14,14,14,14,13,14,14,14,13,14,13,14,14,15,15,15,15,15,15,15,15,0,15,14,15,15,15,15,15,15,15,15,15,0,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,15,15,15,15,15,0,15,0,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,15,15,15,0,0,0,15,0,0,0,0,15,0,0,0,15,0,15,0,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,14,15,14,14,14,14,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,0,0,0,0,0,15,14,14,13,14,14,13,0,15,14,14,13,0,15,14,14,14,14,13,15,14,14,14,14,13,14,14,14,13,14,14,13,13,14,14,13,14,14,14,13,14,14,14,14,15,14,15,15,15,14,14,14,13,14,14,14,14,14,14,14,15,14,14,14,15,15,0,15,15,0,15,14,0,15,15,15,15,15,15,15,15,15,15,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,0,15,0,0,15,0,15,15,15,15,15,15,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,15,15,15,15,14,14,14,15,14,15,15,15,15,15,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,0,15,15,15,0,15,15,15,14,14,13,14,14,14,15,15,2,14,15,15,15,14,14,15,14,15,14,14,13,13,13,13,13,13,14,13,13,14,13,14,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,15,14,14,13,14,14,14,14,13,14,14,13,14,14,14,15,15,15,15,15,15,0,14,15,15,15,15,14,15,15,15,15,15,15,15,14,14,15,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,8,15,15,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,14,15,14,15,14,15,8,14,15,14,8,15,8,15,15,15,15,15,0,0,0,15,0,0,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,15,8,15,15,15,15,15,15,15,15,15,15,15,14,15,15,15,14,14,15,14,14,14,14,15,15,15,15,0,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,15,15,15,0,0,0,0,15,15,14,13,14,14,13,14,14,14,14,14,14,14,15,15,15,14,14,14,14,14,14,13,14,13,14,13,14,13,14,13,14,13,14,13,14,14,14,13,14,13,13,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,13,14,14,14,14,15,15,15,15,15,15,0,15,15,15,15,15,15,8,14,15,14,15,15,15,15,15,14,14,14,15,14,14,14,14,14,14,14,13,14,13,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,14,14,15,14,15,15,8,14,15,14,15,14,14,15,14,14,14,15,14,15,14,15,1,15,8,15,15,15,0,0,0,0,0,15,0,15,15,15,14,15,15,15,14,15,14,15,14,15,15,15,14,15,14,15,14,15,15,15,15,15,8,14,15,14,15,15,15,15,8,14,14,14,14,14,14,15,15,8,15,0,0,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,13,14,13,14,13,14,14,14,14,14,14,15,0,0,0,15,15,15,15,14,14,13,14,14,14,14,14,2,14,14,14,15,14,14,14,14,14,15,14,14,13,14,13,13,13,14,13,14,13,14,14,13,14,14,13,13,14,13,14,14,14,14,14,15,15,14,15,14,12,14,14,14,13,14,14,14,14,13,14,14,14,15,15,15,15,15,15,0,15,14,15,14,14,15,15,15,15,15,8,15,14,14,15,14,15,14,14,14,14,14,14,14,13,14,13,13,13,13,13,14,13,14,13,14,14,13,14,14,14,14,14,14,15,14,15,14,14,15,8,15,15,15,15,8,15,15,14,15,15,14,15,15,14,14,14,15,14,14,15,14,15,14,14,15,14,15,14,15,15,15,15,15,0,0,0,0,15,15,15,15,14,15,15,15,15,14,15,15,15,15,15,15,14,15,14,14,15,14,15,14,15,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,0,15,15,14,14,0,15,15,15,14,14,14,14,14,13,14,14,13,14,14,14,14,13,14,13,13,14,13,13,14,13,14,14,15,15,0,0,15,15,14,15,14,14,14,14,14,14,14,15,13,15,14,14,15,14,14,14,14,14,15,14,14,14,13,14,13,14,13,13,13,14,13,14,14,14,14,14,13,14,13,13,14,13,14,14,15,15,15,14,14,14,14,15,15,14,14,14,14,14,13,13,14,14,14,15,15,15,0,15,14,15,15,14,14,14,14,14,14,14,15,15,15,14,14,14,14,14,14,15,14,14,14,14,14,14,13,13,14,13,14,13,13,13,14,13,13,14,13,14,13,14,14,14,14,14,14,14,14,15,14,14,15,15,15,15,14,15,14,15,14,14,15,14,14,15,14,14,14,15,14,14,14,14,14,15,14,14,15,14,15,15,14,15,15,0,0,0,0,0,0,15,14,14,14,14,14,14,14,15,14,14,14,8,14,14,14,14,14,15,14,14,15,14,15,15,15,15,15,15,14,15,15,14,14,14,14,14,14,14,14,14,15,15,14,15,15,0,15,15,14,15,14,14,14,14,13,14,14,14,14,14,14,13,13,13,13,13,13,14,13,14,14,14,14,15,15,14,15,14,14,14,14,13,14,13,14,14,14,14,15,15,0,14,14,14,14,14,14,14,15,14,14,13,13,13,13,13,13,13,14,13,14,14,14,13,14,13,14,14,14,13,14,14,14,15,15,15,15,15,14,1,15,15,14,14,14,15,15,14,14,14,14,14,13,14,14,14,15,15,15,15,15,15,15,15,14,15,14,15,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,13,14,13,13,14,13,13,14,13,13,14,13,13,13,14,14,14,14,14,14,14,14,15,14,14,14,15,14,15,14,15,15,15,15,15,15,14,14,15,14,14,15,14,15,14,14,15,14,15,14,14,14,14,15,14,15,15,15,15,15,0,0,0,0,15,15,0,14,15,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,8,15,15,15,15,15,14,14,15,14,14,14,14,13,14,14,15,15,15,14,14,15,15,0,15,14,14,14,14,13,14,14,13,14,14,14,14,14,14,14,13,13,14,13,13,13,14,14,14,14,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,15,15,14,14,14,13,14,13,14,13,13,14,14,13,14,14,14,14,14,13,14,13,14,13,14,15,15,1,15,1,15,2,13,1,15,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,15,8,15,15,15,15,14,14,15,14,14,15,15,14,14,14,14,14,15,14,15,14,14,14,14,14,13,14,13,13,13,13,13,13,14,13,13,14,13,14,13,14,14,14,14,14,14,14,14,14,15,14,14,15,14,15,8,14,14,15,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,8,15,15,0,0,0,15,15,15,15,15,15,14,15,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,15,14,14,15,14,15,15,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,13,13,13,13,13,14,14,14,14,14,15,14,15,14,8,14,14,14,14,13,14,14,14,14,14,15,14,14,14,14,14,14,15,15,15,15,14,13,14,13,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,15,15,1,1,15,1,13,13,13,12,3,14,14,14,15,14,15,14,13,14,14,13,14,14,14,14,14,14,14,14,14,15,14,15,14,14,15,15,14,14,15,14,15,14,15,14,14,15,14,14,14,14,14,13,13,14,13,14,13,13,13,13,14,13,13,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,15,14,15,14,15,14,15,15,14,14,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,15,15,15,14,15,0,15,0,15,0,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,15,14,15,15,14,14,14,14,13,14,14,14,13,14,14,14,14,14,14,14,13,14,14,14,13,14,13,14,13,14,14,14,14,14,14,13,13,13,13,14,13,14,14,14,15,0,14,15,15,14,15,14,14,14,14,14,14,14,13,14,14,14,14,15,14,14,14,15,15,15,14,14,14,14,13,14,14,14,14,13,14,14,14,14,14,14,14,14,14,13,14,14,14,15,1,15,1,1,15,2,13,13,3,13,14,14,14,15,1,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,15,14,14,15,14,15,15,14,14,14,15,15,14,14,15,14,14,14,13,13,14,13,14,13,13,13,13,14,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,15,14,15,14,14,14,15,14,15,15,15,15,14,15,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,15,14,15,14,15,15,15,0,15,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,14,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,13,14,14,14,14,14,13,13,13,13,13,13,14,14,14,14,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,14,14,14,14,14,14,13,14,14,14,14,13,14,13,14,14,14,14,13,14,14,14,14,1,1,2,1,2,2,1,2,2,14,12,13,14,14,15,15,13,14,15,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,14,15,14,15,14,15,14,14,14,14,14,14,13,13,13,13,14,13,13,13,14,13,13,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,15,14,15,15,15,14,14,14,15,14,15,14,15,14,14,14,14,15,14,14,14,14,14,15,15,15,15,15,0,15,0,15,15,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,15,14,14,15,14,15,15,14,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,13,13,14,14,14,13,14,14,14,13,14,14,13,13,13,13,12,13,13,13,14,13,14,15,15,15,14,15,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,0,14,15,15,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,13,14,14,14,14,14,14,14,1,2,3,3,12,3,1,2,2,3,13,2,14,14,14,14,13,14,14,14,14,14,13,14,14,14,14,13,14,14,14,14,14,13,14,15,14,14,15,14,14,14,15,15,15,15,15,14,15,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,15,14,14,14,14,14,15,14,15,14,15,15,15,14,15,14,15,14,14,15,14,14,14,14,14,15,14,14,14,14,15,14,15,8,15,15,15,0,15,15,15,15,15,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,15,14,14,15,14,14,14,15,15,14,14,14,15,14,14,13,14,14,14,14,13,14,14,13,14,13,14,14,13,13,14,14,13,14,14,14,13,14,13,13,13,13,12,13,13,13,13,14,14,15,15,15,14,15,15,14,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,0,15,15,14,15,14,14,14,14,14,14,13,14,14,14,14,13,14,14,14,14,14,14,13,14,14,14,14,14,2,3,5,3,3,1,2,2,15,1,14,14,14,14,14,13,14,15,14,14,14,13,13,14,13,14,13,12,13,14,14,14,14,14,14,14,14,15,14,14,14,15,15,14,15,15,14,14,14,14,14,14,14,13,14,13,13,14,13,14,13,13,13,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,15,14,15,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,0,15,15,15,15,15,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,14,15,15,14,14,14,14,14,14,14,14,13,14,13,14,14,13,14,14,14,13,13,14,14,13,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,14,14,15,14,0,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,14,14,14,14,14,14,14,14,14,13,14,14,14,13,14,14,13,14,14,14,14,13,14,1,2,3,3,3,2,2,1,2,14,14,12,13,15,14,15,14,14,15,14,14,13,13,13,13,14,14,14,13,3,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,14,15,15,15,14,14,14,14,14,14,13,13,14,13,13,13,13,14,13,13,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,15,14,14,14,15,14,14,15,14,14,15,14,15,14,15,14,15,14,15,14,15,15,15,15,15,15,15,15,15,15,8,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,15,8,14,15,14,14,14,14,14,13,14,14,14,14,13,14,13,14,14,15,15,15,14,14,14,14,14,15,15,14,14,13,14,13,13,13,13,13,13,13,13,14,14,14,15,15,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,14,15,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,1,2,3,5,3,2,2,2,2,14,15,14,13,15,14,14,14,14,14,14,13,13,14,13,13,13,14,13,14,12,14,14,14,14,14,14,14,15,14,15,14,14,15,14,15,14,15,15,14,15,14,14,14,13,14,14,13,13,14,13,13,13,13,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,8,14,14,14,14,14,15,14,14,14,14,14,14,14,15,14,15,15,15,15,15,0,15,0,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,15,14,14,14,14,13,14,14,14,13,14,14,14,13,14,14,13,14,14,14,14,14,14,14,14,15,15,14,14,14,14,13,13,13,13,13,13,13,13,14,14,14,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,14,14,14,14,14,14,14,14,14,13,14,14,13,14,13,14,14,14,14,14,14,14,14,14,2,3,5,3,2,2,2,14,14,15,14,13,14,14,14,14,13,14,13,13,13,13,13,14,13,13,14,13,14,14,14,13,14,13,14,14,14,14,15,14,14,15,14,14,14,14,15,14,14,14,15,14,14,14,14,14,14,13,13,14,13,13,13,13,13,14,13,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,15,14,14,15,14,14,14,14,15,14,14,15,14,14,14,15,14,15,14,15,14,15,15,14,15,15,15,15,0,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,13,14,13,14,14,14,13,14,14,14,13,15,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,13,14,13,14,14,14,15,15,15,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,13,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,1,2,2,3,4,2,2,2,2,1,15,15,14,13,14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,2,13,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,14,14,15,15,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,13,14,14,14,14,14,14,15,14,14,14,14,15,14,14,15,14,14,14,14,14,14,15,14,14,14,14,14,15,15,8,15,15,15,0,0,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,14,14,13,14,13,13,13,13,14,13,14,13,14,15,15,14,14,14,15,14,15,14,14,13,14,14,13,13,13,14,14,14,14,14,14,15,15,15,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,14,14,1,2,3,11,3,2,2,14,15,14,14,14,14,13,13,13,13,13,13,13,12,13,12,12,13,13,14,13,13,13,14,13,14,13,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,13,15,15,15,14,14,14,14,14,13,14,13,13,13,13,13,13,14,13,14,14,14,14,13,14,13,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,15,14,14,15,15,15,15,0,15,0,15,15,8,15,15,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,15,15,15,0,15,14,14,14,14,14,14,14,14,14,13,13,14,13,13,14,13,14,14,13,14,13,14,13,13,14,13,14,14,14,14,15,14,15,0,14,15,15,14,14,13,14,13,14,13,13,13,14,14,14,14,15,14,0,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,15,15,14,2,12,3,11,2,2,2,15,14,14,13,14,13,13,13,13,12,13,12,13,12,13,12,13,13,13,13,13,13,14,13,14,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,14,14,14,14,13,14,13,14,13,13,13,13,13,13,13,14,13,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,15,0,0,15,15,15,15,14,15,14,14,15,14,14,8,14,15,14,14,15,14,14,14,14,14,15,15,15,15,0,14,15,14,14,14,14,14,14,14,13,14,13,13,13,14,13,14,13,13,13,13,13,14,13,13,14,13,14,14,14,15,14,15,15,14,15,14,14,14,13,13,14,13,13,13,14,14,14,14,14,15,15,15,15,15,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,14,15,15,14,13,14,3,5,4,5,2,15,13,14,13,14,13,13,13,13,13,13,12,12,12,12,13,13,13,13,13,13,13,14,13,13,14,13,13,14,14,14,14,14,14,14,14,14,14,14,15,14,15,13,1,14,14,14,15,14,14,14,14,13,13,13,13,13,13,13,14,13,14,14,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,15,14,14,15,15,15,15,0,15,15,15,15,15,15,15,14,14,14,14,14,14,15,14,15,14,14,15,14,15,14,15,15,15,15,15,0,0,15,14,14,14,14,14,14,13,14,13,13,14,14,13,13,13,13,14,13,14,13,13,13,14,13,13,13,14,14,15,15,15,14,14,15,14,14,14,13,13,13,13,14,13,13,14,14,14,14,14,0,15,14,15,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,15,15,14,14,14,14,14,13,11,4,11,1,14,13,13,13,13,13,13,13,12,13,12,13,12,13,13,13,13,13,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,13,14,14,14,13,14,14,14,13,13,13,13,13,13,13,13,14,13,14,13,14,13,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,8,14,14,14,15,14,15,15,15,0,0,15,15,8,14,15,14,15,14,14,14,14,14,0,14,14,14,15,14,14,14,14,0,15,0,0,15,15,15,15,14,14,14,14,13,14,13,13,14,13,14,14,13,13,13,13,13,13,13,13,14,13,13,13,13,13,14,15,14,14,14,14,14,14,14,13,15,13,13,13,13,13,13,13,14,14,14,14,0,0,15,14,15,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,2,15,0,0,0,15,2,13,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,14,14,15,14,14,14,14,14,4,11,11,13,14,13,13,13,13,13,13,13,13,12,13,12,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,14,15,15,13,14,14,14,14,13,13,14,13,13,14,13,13,13,14,13,14,13,14,13,14,13,13,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,0,15,15,15,15,14,15,14,14,14,15,15,15,15,15,15,15,15,14,15,14,15,14,15,15,15,15,0,15,15,14,14,14,14,13,14,15,0,0,14,13,13,14,14,13,13,14,13,13,14,13,13,14,13,13,14,13,14,14,15,15,0,15,15,15,15,13,14,13,13,13,13,13,13,13,13,13,14,15,15,0,15,14,15,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,15,0,0,15,0,15,0,15,2,14,13,14,14,14,14,14,14,14,14,14,15,14,14,15,15,15,14,14,14,14,13,14,1,3,11,13,14,13,13,13,13,13,13,12,5,12,13,12,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,14,14,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,14,13,14,14,13,14,13,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,15,8,15,0,15,15,15,15,14,15,15,15,14,15,15,14,15,15,15,15,14,14,14,14,14,14,15,15,15,14,15,14,14,14,14,14,14,14,0,0,0,0,0,2,14,13,14,13,13,13,13,13,13,14,13,13,14,13,13,13,14,14,15,14,14,14,15,0,15,14,14,13,14,14,13,13,13,13,13,14,14,15,15,15,15,14,15,13,14,14,13,14,14,14,13,14,14,14,14,14,14,15,0,0,15,14,15,14,0,0,2,13,14,13,14,14,14,14,14,14,14,15,15,15,15,15,14,15,15,14,14,14,14,14,2,11,4,2,13,13,13,13,13,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,14,13,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,13,13,13,14,13,13,13,13,13,13,13,13,13,14,13,13,13,13,14,13,13,13,14,13,14,14,14,14,15,14,13,14,14,13,14,13,14,14,14,14,14,15,15,14,14,14,14,14,14,15,14,15,14,15,0,15,0,15,15,15,15,15,15,14,15,15,15,15,15,15,14,14,14,15,14,14,15,14,15,15,14,15,14,14,14,14,14,14,3,0,0,0,0,0,14,14,13,14,13,13,13,13,13,14,13,14,13,13,13,13,13,13,15,14,15,14,15,15,15,15,14,14,14,14,14,13,13,13,13,13,13,14,14,15,15,14,14,15,14,14,13,14,14,13,14,14,14,14,14,14,14,14,15,15,0,14,14,13,14,15,0,15,15,13,14,14,14,14,14,14,15,15,15,15,15,14,15,15,15,14,14,14,13,14,14,1,13,2,0,14,13,12,12,12,12,11,11,12,12,13,13,13,12,12,13,13,13,13,13,13,13,13,14,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,1,14,14,1,14,14,13,15,14,14,13,14,14,13,13,13,13,13,13,13,13,13,13,13,14,13,13,14,13,14,13,14,13,13,14,13,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,15,14,14,14,14,15,15,15,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,15,14,14,8,14,15,15,8,14,14,14,14,14,14,14,1,0,0,0,0,15,14,14,13,14,14,14,14,13,13,14,14,13,14,13,14,13,14,14,14,15,15,15,15,15,15,14,14,14,14,13,14,13,13,13,13,14,14,14,15,15,15,14,14,14,13,14,13,13,14,14,14,14,14,14,14,14,14,15,0,0,14,14,15,0,15,0,0,15,0,15,13,14,14,14,15,14,15,15,15,15,15,15,15,15,15,14,14,14,2,15,0,0,0,0,14,15,12,12,12,12,11,12,13,14,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,13,13,14,13,14,15,14,14,13,14,13,14,14,14,14,13,14,14,14,0,0,14,14,14,14,14,15,14,15,14,15,15,0,15,0,0,0,15,15,15,15,15,15,0,15,15,8,15,0,15,15,14,8,15,14,14,15,15,14,14,14,14,14,14,14,14,2,14,15,0,0,15,0,14,13,14,13,13,14,14,14,13,14,13,14,14,13,13,14,14,14,14,14,15,14,14,15,15,14,14,13,14,14,14,14,13,13,14,14,14,14,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,0,14,14,13,3,0,0,15,15,15,1,15,14,14,14,15,15,0,0,0,15,15,15,8,14,14,14,14,14,14,15,2,14,0,14,14,15,11,12,12,13,13,13,12,12,12,12,12,12,12,13,13,13,13,13,13,13,14,13,13,14,13,13,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,14,14,14,13,13,13,13,13,13,13,13,0,0,14,13,13,13,14,13,14,13,14,13,13,14,14,13,15,14,14,14,14,13,14,14,14,14,14,15,14,14,15,14,14,14,14,14,14,14,15,15,15,15,0,15,0,15,15,15,15,15,15,15,15,8,15,15,15,15,15,14,14,15,14,15,14,14,15,14,15,14,14,14,14,14,2,14,15,0,0,0,0,0,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,13,13,14,14,15,15,14,15,15,15,13,14,14,14,13,14,13,13,14,13,14,14,15,15,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,0,0,15,14,12,4,15,15,1,15,15,2,15,14,14,14,15,15,0,0,0,0,0,15,15,14,14,14,14,14,15,15,15,15,0,15,15,15,12,13,13,12,12,11,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,14,13,14,14,13,14,15,15,14,14,14,13,13,14,13,14,15,13,13,13,14,14,14,13,13,13,13,13,14,13,13,14,13,14,14,14,0,0,15,13,14,14,14,14,14,14,14,0,14,14,15,14,14,14,14,14,14,15,14,15,14,0,0,0,15,15,15,15,15,15,15,8,15,15,15,15,15,14,14,0,15,15,14,14,14,14,14,14,15,14,14,14,14,14,14,0,0,0,0,15,0,14,14,14,13,13,14,14,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,14,13,14,13,13,14,14,14,14,15,15,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,0,15,15,2,14,15,14,15,15,1,15,15,14,14,14,15,0,0,0,0,0,0,15,15,14,14,14,13,14,14,15,15,15,0,0,15,13,12,12,11,12,12,12,12,12,11,12,12,12,12,12,13,13,13,13,13,13,14,13,14,13,14,13,14,14,14,13,14,14,13,14,13,14,13,14,14,14,14,13,14,13,14,14,14,14,13,13,14,14,13,13,14,13,13,14,15,12,13,14,14,14,0,13,13,14,13,13,13,13,14,13,14,15,14,14,15,14,15,14,14,14,14,13,14,14,14,15,0,15,0,0,14,14,14,14,14,14,15,15,15,15,0,0,0,0,15,15,14,15,15,14,15,1,15,15,14,15,14,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,0,0,15,15,15,14,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,13,14,14,13,14,14,15,14,14,14,13,14,14,13,13,14,13,14,14,14,14,15,15,15,15,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,13,15,15,0,14,15,15,15,15,15,15,1,15,2,13,14,14,15,15,15,0,0,0,0,15,15,15,14,14,13,14,13,14,15,0,0,15,0,0,0,13,11,12,12,11,12,12,12,11,12,12,12,12,12,12,12,13,13,13,13,13,14,13,14,13,13,13,14,13,14,13,14,14,2,14,14,14,14,14,13,14,15,14,13,14,15,15,15,14,13,14,14,14,14,14,13,12,14,15,12,12,14,14,12,14,13,13,13,13,13,13,13,13,13,13,15,0,14,15,14,14,14,13,14,14,14,14,14,14,15,0,15,0,0,0,14,14,14,14,14,15,14,15,0,15,15,15,15,15,8,14,15,15,15,15,8,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,14,14,13,14,13,14,14,13,14,14,14,14,14,14,14,13,0,15,14,14,14,14,14,14,14,14,14,13,14,14,14,13,13,13,14,14,14,14,14,15,0,15,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,0,15,15,14,14,15,14,14,14,14,13,2,14,14,14,15,15,15,15,14,15,14,14,14,13,13,14,14,14,14,14,0,0,15,0,14,14,14,11,11,12,11,12,11,11,12,12,11,11,12,12,12,12,12,13,13,13,14,13,14,13,14,14,14,14,14,14,14,14,13,14,14,13,14,14,13,14,13,14,14,15,0,15,15,15,14,15,15,15,0,14,14,14,12,14,14,13,13,15,15,13,14,14,13,13,13,13,13,14,13,14,13,15,15,14,0,0,0,14,14,13,14,14,14,14,14,0,0,15,0,0,0,0,15,15,14,14,15,15,15,0,15,15,15,15,14,15,14,15,14,15,15,15,15,14,14,14,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,15,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,15,14,14,13,13,13,14,14,15,13,13,14,14,14,14,14,14,13,14,14,13,15,14,14,14,14,15,14,14,14,15,14,14,14,14,13,14,14,13,14,13,13,15,14,0,14,14,14,14,14,14,14,14,2,3,2,8,14,14,14,15,14,14,14,14,14,14,13,14,14,14,14,14,14,14,0,0,0,0,15,14,14,12,11,12,11,11,12,11,11,11,12,12,11,12,12,12,12,12,13,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,13,14,14,14,14,1,14,14,15,15,15,15,14,14,15,15,15,15,0,0,15,0,14,14,15,13,13,15,0,15,15,0,15,13,13,13,13,13,13,13,14,14,14,14,0,0,0,0,14,0,14,14,14,15,0,0,0,0,0,0,0,0,15,15,0,14,14,14,15,0,0,15,15,15,15,15,14,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,13,15,15,14,14,15,14,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,14,13,14,14,14,14,13,13,14,14,14,14,13,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,13,14,13,13,14,14,13,14,13,15,15,0,15,14,14,14,15,14,2,14,14,13,2,14,13,14,14,14,14,14,14,14,14,13,14,14,13,14,14,13,15,15,15,0,0,0,15,14,14,12,12,11,12,11,12,11,12,11,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,14,13,14,14,13,15,14,14,15,15,14,14,14,14,15,15,14,14,15,15,15,0,0,15,15,15,0,15,15,15,15,14,14,14,14,15,15,15,14,0,15,14,15,13,14,0,14,14,14,14,14,14,14,15,15,15,0,0,0,0,15,15,15,15,0,0,0,15,0,0,15,0,0,0,14,15,15,15,0,0,0,15,15,15,8,1,0,14,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,13,15,14,14,14,13,14,14,13,14,14,14,14,14,14,15,14,13,15,15,14,14,13,13,14,14,15,13,14,14,14,13,14,14,14,14,14,15,14,14,14,15,14,14,14,15,15,14,14,14,13,13,13,14,13,14,14,14,14,14,14,14,0,15,14,14,14,14,14,13,14,14,3,13,14,13,13,13,13,13,13,14,14,14,14,13,14,13,13,13,14,15,14,0,0,0,0,15,0,14,12,11,12,11,12,11,11,11,12,11,12,11,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,15,15,15,15,0,15,15,15,0,15,15,15,0,15,0,15,0,15,14,14,14,14,14,14,14,15,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,0,14,15,15,0,0,0,0,15,0,0,0,0,0,0,15,15,15,15,15,0,15,15,15,15,15,15,15,14,15,15,14,14,14,14,14,14,14,14,14,14,13,15,14,15,14,15,14,14,14,14,13,14,14,13,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,0,15,14,14,14,14,14,14,15,13,14,14,13,14,14,14,14,14,15,15,14,14,15,14,15,15,15,14,14,14,14,14,14,14,13,13,13,14,14,14,14,13,14,15,0,15,14,14,14,14,2,14,14,2,2,14,14,13,13,13,13,14,14,13,13,12,13,13,13,13,13,13,14,0,13,0,15,14,0,0,15,0,0,0,12,12,11,12,11,12,11,12,12,12,12,12,11,12,12,12,12,13,13,13,13,13,13,13,13,14,13,14,14,14,14,15,14,14,15,15,15,15,15,14,0,15,15,0,15,15,15,15,0,0,15,0,15,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,13,14,15,15,14,14,14,14,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,15,15,15,15,0,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,13,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,14,14,15,13,14,15,14,14,14,15,14,14,14,14,13,13,15,13,13,13,14,0,15,14,15,14,14,15,15,15,15,15,14,14,14,14,14,14,14,14,14,13,13,14,14,14,14,14,15,0,15,15,14,14,15,14,14,14,14,15,15,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,0,0,0,15,0,14,12,14,0,15,14,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,13,12,13,13,13,13,13,13,13,13,13,14,14,14,14,15,15,14,14,15,15,15,14,0,15,0,0,0,15,0,0,0,0,0,15,15,14,14,14,13,13,14,14,14,14,14,14,15,14,15,15,15,15,14,15,14,14,14,14,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,0,0,0,15,15,15,8,14,15,14,14,14,14,14,14,14,14,15,14,14,15,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,0,3,14,14,15,14,14,15,14,14,14,15,14,15,14,13,13,14,14,15,14,15,15,15,15,15,15,15,0,15,15,14,14,13,14,14,13,13,14,13,14,13,14,13,14,14,15,0,14,15,13,14,1,14,1,1,15,2,13,14,13,13,13,13,13,13,13,13,13,13,13,13,14,14,1,14,15,0,0,0,0,0,15,14,0,14,13,13,12,11,11,11,12,11,12,11,12,11,12,12,12,12,12,13,12,12,12,13,13,12,13,12,13,13,14,13,14,14,14,14,14,14,15,15,15,0,14,0,15,0,0,0,0,0,0,15,0,0,15,14,14,0,14,13,15,15,14,14,15,15,15,15,15,15,15,15,15,14,0,14,14,14,14,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,0,0,15,0,15,15,15,15,14,14,14,14,13,14,14,14,14,15,14,13,14,15,13,14,13,14,14,14,14,14,14,14,14,14,13,15,14,14,14,14,13,14,14,14,13,14,14,14,14,14,14,14,15,14,13,14,15,14,14,14,15,14,14,14,14,15,15,15,14,13,2,14,14,15,15,14,15,15,15,0,0,15,15,15,14,14,13,14,13,14,13,13,13,13,13,14,13,13,14,15,0,14,0,14,14,14,13,14,14,1,2,13,14,13,13,13,13,13,13,12,13,13,13,12,14,15,0,15,15,0,0,0,0,0,0,14,14,0,14,11,12,12,11,12,11,11,11,11,12,11,12,11,12,12,12,12,12,13,13,13,12,13,13,13,13,13,13,13,14,14,14,14,14,15,14,15,15,15,15,15,0,0,0,0,0,0,0,14,15,15,15,15,13,14,0,2,13,14,0,14,14,14,15,15,15,15,15,15,15,15,15,15,15,14,14,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,8,15,15,15,14,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,0,14,14,14,13,14,13,13,14,13,14,14,14,14,14,13,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,15,14,14,14,14,15,14,14,14,13,14,14,13,15,14,14,14,14,14,14,15,15,15,14,14,13,13,13,13,13,13,13,13,14,13,13,14,14,14,15,15,15,15,14,13,14,14,2,14,14,2,13,14,13,13,13,13,13,13,14,13,13,13,12,0,15,14,1,0,15,0,0,0,0,0,15,0,15,0,12,11,12,11,11,12,11,12,12,11,12,11,12,12,12,12,12,13,13,12,12,12,12,12,12,12,13,13,13,14,14,14,15,14,15,15,15,15,0,0,15,0,15,0,15,15,15,15,0,15,15,15,15,14,14,15,14,13,14,15,14,14,14,14,15,14,15,15,8,14,14,14,15,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,15,15,15,15,15,15,15,15,15,15,15,14,14,14,13,14,14,15,14,15,14,14,13,14,14,14,15,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,13,14,13,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,15,14,13,13,13,13,14,13,13,13,13,13,14,14,14,13,14,15,0,14,15,14,14,13,14,13,14,14,14,2,14,12,13,13,13,13,13,15,14,13,13,12,0,0,12,14,2,14,2,14,14,2,14,2,14,14,12,11,12,12,11,14,13,13,13,13,13,14,11,11,12,12,12,12,12,12,12,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,15,0,15,0,15,0,15,0,15,15,15,15,15,15,15,15,13,14,0,13,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,15,15,0,0,0,0,15,15,15,14,14,14,14,14,14,13,14,14,14,15,15,14,15,14,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,14,14,13,14,14,14,14,14,15,14,14,14,15,14,2,14,14,13,15,14,14,14,14,14,13,15,13,14,14,14,14,14,14,14,14,14,13,14,13,14,13,14,14,14,14,13,13,13,14,13,14,15,0,14,0,14,13,14,13,14,14,1,14,13,14,13,13,13,13,13,14,15,15,13,13,13,0,0,13,14,0,0,0,15,0,15,15,0,15,14,11,11,11,12,11,14,11,11,11,12,14,13,13,11,11,12,11,12,12,12,12,12,12,11,12,12,12,13,13,14,14,14,14,15,14,15,15,15,15,0,15,15,15,15,14,14,14,14,14,14,14,14,15,14,14,15,0,13,13,15,14,14,13,13,14,14,14,14,14,14,14,14,15,14,15,14,14,14,14,15,15,0,0,0,0,15,0,0,0,0,0,0,0,15,0,15,0,0,15,15,15,14,15,14,14,14,14,15,15,15,14,14,13,13,13,14,13,14,14,15,14,14,14,14,15,14,15,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,15,15,0,15,14,13,13,13,14,14,14,14,13,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,13,14,15,15,15,15,14,14,2,14,2,14,14,15,14,14,13,13,13,13,13,15,15,14,13,13,13,0,0,12,15,15,15,0,0,0,15,0,14,13,14,12,13,12,11,11,15,11,11,13,14,15,14,13,11,12,11,12,12,12,12,11,12,12,12,12,12,12,13,13,13,14,14,14,14,15,14,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,0,13,13,14,14,14,13,13,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,15,15,15,15,14,0,0,0,0,0,0,0,15,15,15,15,0,15,15,15,15,15,15,15,15,14,14,8,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,14,14,15,14,14,14,14,14,15,15,15,14,14,14,14,14,14,15,0,0,0,0,1,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,15,14,15,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,13,14,15,0,0,0,13,14,15,15,14,0,15,14,14,14,14,14,0,15,15,14,14,13,13,12,14,0,0,0,1,13,13,0,0,12,15,0,0,0,0,0,0,0,14,14,13,14,12,13,12,11,14,13,13,12,14,14,14,13,11,11,11,12,12,11,12,12,12,12,12,12,12,13,13,13,13,14,14,14,15,14,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,0,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,8,15,15,15,15,15,0,0,0,0,0,15,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,14,13,14,13,14,14,15,14,14,13,14,14,14,14,13,14,14,14,14,14,15,15,15,14,14,14,15,13,0,15,0,0,0,15,2,14,14,14,14,14,14,14,13,13,14,14,13,14,14,14,14,14,14,13,14,14,14,14,14,14,15,14,15,15,14,14,13,14,14,13,13,14,13,14,14,13,14,13,14,13,13,0,14,15,14,0,15,14,15,0,14,0,0,14,14,15,14,15,0,15,15,0,15,14,12,13,0,15,14,14,2,3,13,0,0,13,15,15,0,0,15,0,15,15,14,14,14,13,11,11,12,14,14,11,11,12,14,14,15,14,13,14,12,11,12,12,12,11,12,11,12,12,12,12,12,13,13,14,14,14,14,15,14,15,14,14,14,14,15,15,14,14,15,14,14,14,13,14,14,14,14,14,15,14,15,14,15,14,14,14,14,14,15,14,14,14,14,14,14,14,15,14,15,14,15,14,14,15,15,15,15,15,15,15,15,0,0,0,0,15,15,15,15,0,15,15,0,15,15,0,14,0,15,8,14,14,14,13,14,14,14,13,14,14,14,14,14,15,14,14,13,14,13,14,14,14,13,14,14,14,15,15,14,14,14,14,14,2,15,0,0,0,0,0,14,13,14,14,14,14,13,14,14,14,14,14,13,13,14,14,14,14,13,15,13,14,13,14,14,14,14,13,15,14,13,14,14,13,13,13,13,14,13,13,13,14,13,14,13,14,14,14,14,14,15,15,0,0,15,0,14,0,0,15,15,1,15,1,0,0,0,14,0,14,12,14,15,15,14,14,2,2,14,0,0,12,15,0,15,0,14,15,15,15,14,14,14,14,12,12,13,15,14,12,11,13,14,14,14,13,12,11,14,11,12,11,11,12,11,12,12,12,12,12,13,13,14,14,14,14,14,14,14,14,14,14,15,15,14,15,15,15,15,15,14,14,14,14,14,14,14,13,14,15,14,15,15,14,14,14,15,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,14,15,15,0,0,0,15,15,15,15,15,0,0,15,0,15,0,15,14,14,14,14,14,14,14,14,14,14,13,13,13,13,14,14,15,14,14,13,13,13,13,14,14,14,14,14,14,15,15,14,15,14,14,14,14,14,0,0,0,0,0,14,13,14,14,14,13,14,13,13,14,13,14,14,14,13,14,14,14,14,14,14,14,14,13,14,14,13,13,14,13,14,14,13,14,13,13,13,13,13,13,13,13,14,13,14,14,13,15,15,15,14,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,13,15,0,0,0,0,0,14,0,0,13,0,0,15,0,14,15,14,15,15,15,15,14,14,14,13,14,13,14,14,14,14,14,15,14,15,14,14,11,11,12,11,11,12,11,12,12,12,12,13,13,13,13,14,14,14,14,15,14,14,14,15,14,14,14,14,15,0,15,15,14,14,14,14,14,14,14,13,14,14,15,14,14,15,14,15,15,0,15,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,0,15,15,15,15,15,15,15,15,0,15,0,0,15,14,14,14,14,14,14,14,13,14,13,13,13,13,13,14,14,14,14,13,13,13,13,13,13,14,14,14,14,14,14,14,13,14,15,15,13,0,1,15,0,0,0,0,14,13,13,14,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,13,13,14,14,14,13,13,14,14,14,14,13,14,13,12,13,12,12,13,15,14,14,14,14,15,0,0,14,15,15,14,14,15,0,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,14,15,15,14,14,14,15,14,0,14,13,15,0,0,15,14,1,14,15,0,15,15,14,13,13,12,14,14,15,14,14,14,14,14,14,14,14,15,12,11,11,11,11,12,11,12,12,12,12,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,13,13,13,14,14,14,15,14,15,0,15,0,15,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,15,0,0,15,15,14,15,15,15,15,0,15,15,0,15,14,14,15,15,15,15,14,13,14,13,14,13,13,13,13,14,14,13,13,14,13,13,14,14,13,14,14,14,14,14,15,13,13,15,0,15,0,0,0,0,0,0,14,13,13,13,14,13,14,13,13,13,13,13,14,14,14,14,14,14,14,13,14,13,14,13,13,2,14,14,14,13,14,13,13,13,12,12,12,12,13,14,14,14,14,14,13,14,14,14,14,15,15,14,15,14,0,15,15,14,2,14,1,0,0,0,0,0,0,0,0,0,0,0,14,14,15,14,13,14,15,14,0,14,14,15,0,0,15,14,14,14,15,0,0,15,13,14,13,13,14,14,14,13,15,14,14,14,14,14,14,14,14,13,11,12,11,11,12,12,12,12,12,12,13,13,14,13,14,14,14,14,14,14,15,14,14,14,14,15,14,15,15,15,14,14,14,13,14,14,13,13,13,13,13,13,14,14,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,0,15,15,15,15,8,15,15,0,15,0,15,0,14,14,14,15,14,14,13,14,14,14,13,13,14,13,13,13,13,14,14,13,13,13,13,13,14,14,14,15,15,0,15,14,13,14,14,14,0,15,15,0,15,0,14,13,14,13,14,13,14,14,14,14,1,14,0,0,0,15,14,14,14,14,13,14,14,14,13,14,13,14,13,13,13,13,13,13,12,12,13,12,13,12,13,13,14,13,13,13,13,14,14,14,14,14,14,15,15,15,0,15,14,14,14,14,15,1,15,0,0,0,0,0,0,0,12,13,15,15,14,14,14,14,14,0,15,15,15,0,0,0,14,14,14,15,15,14,0,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,12,11,11,12,11,12,12,12,12,13,13,13,14,14,14,14,14,15,14,14,14,15,14,15,14,14,15,14,14,14,14,14,14,14,14,13,14,13,13,13,13,13,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,15,15,14,15,15,14,15,15,0,15,15,15,0,15,15,14,14,13,14,13,14,13,14,14,14,14,14,13,13,13,14,14,13,14,13,14,14,14,13,14,15,15,15,15,14,0,15,14,14,14,14,14,15,15,14,14,14,13,14,13,14,13,13,14,14,3,14,0,15,0,0,14,14,14,14,14,13,13,14,14,14,14,14,14,14,13,13,14,13,13,12,12,13,12,12,13,13,13,13,13,14,13,14,14,2,13,14,14,15,15,15,15,15,15,1,14,15,15,15,15,15,14,0,0,0,0,0,13,14,14,15,13,14,13,15,14,0,15,15,15,14,0,0,14,14,14,14,15,15,15,13,13,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,11,11,11,12,12,12,12,12,13,13,13,13,14,14,14,14,14,15,14,15,14,14,14,14,14,14,12,12,14,13,13,14,13,14,13,14,14,13,14,14,13,14,14,13,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,0,15,15,15,0,14,15,14,14,15,14,14,14,14,13,14,14,14,14,13,13,14,14,14,13,14,13,13,13,13,14,14,14,14,15,15,14,14,0,14,14,0,15,0,15,15,14,14,14,15,14,14,13,14,13,13,13,3,13,0,0,0,0,0,14,14,13,14,13,2,13,14,13,13,14,14,14,12,13,13,13,13,13,13,12,12,12,14,13,14,12,13,13,13,14,13,14,14,14,14,14,14,14,15,0,1,15,15,15,15,15,0,15,14,0,0,0,0,15,14,14,14,15,14,13,14,1,14,15,15,15,15,0,0,15,14,14,14,15,14,15,14,13,14,13,14,13,14,13,13,14,14,14,14,14,14,14,14,14,14,14,11,11,12,12,12,12,12,12,13,13,13,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,13,14,13,14,14,13,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,8,15,15,15,15,15,15,15,15,0,15,15,15,14,14,15,15,15,14,0,15,14,13,14,13,13,13,14,14,13,13,13,14,14,14,14,14,14,15,15,0,15,15,15,13,14,0,15,15,15,14,15,14,14,14,14,14,14,12,13,2,14,14,13,1,0,0,0,0,14,14,14,14,13,13,13,14,13,15,13,14,14,12,13,14,13,13,13,12,12,13,12,13,13,14,12,13,13,14,14,13,14,14,14,14,15,14,15,14,1,14,14,1,15,1,15,0,0,0,15,0,15,15,15,0,14,14,15,15,15,15,14,15,14,0,14,0,14,0,0,14,14,14,14,14,15,15,14,13,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,14,13,13,12,11,12,12,12,13,13,13,13,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,13,14,13,14,1,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,0,15,15,15,15,0,15,0,14,14,14,15,15,14,14,13,15,14,14,13,14,13,14,13,14,13,13,13,14,14,14,14,14,0,15,15,15,14,15,15,15,15,0,0,15,15,15,15,14,14,14,14,14,14,13,14,13,14,15,1,14,0,0,0,0,14,13,14,13,14,13,14,14,13,14,14,14,14,12,13,13,13,13,13,12,12,12,12,13,14,13,13,13,13,14,14,13,13,14,14,14,14,15,14,15,0,0,0,0,0,0,15,15,15,0,0,15,0,0,0,15,14,14,14,0,14,14,13,14,14,0,15,15,14,15,15,14,14,14,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,13,12,12,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,14,14,14,14,14,14,14,13,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,0,15,15,15,15,15,0,0,0,15,14,14,13,14,13,14,13,15,14,14,14,14,13,13,13,13,13,14,13,14,13,14,15,13,15,14,14,15,14,15,15,15,0,0,0,15,15,15,14,14,14,14,13,14,13,14,14,14,14,2,0,0,0,0,0,0,14,13,14,14,13,13,13,13,14,14,13,14,14,12,13,14,13,13,14,13,12,12,12,13,13,14,12,13,13,14,14,13,14,14,14,14,15,15,0,0,15,15,0,15,15,15,15,0,15,0,15,0,0,15,15,15,14,14,1,15,14,13,13,14,14,0,0,15,15,0,15,14,14,14,15,14,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,13,13,13,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,14,13,14,13,13,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,15,15,0,15,0,15,15,15,0,0,0,14,14,14,13,14,14,14,14,13,14,15,14,14,13,14,13,14,13,13,14,14,14,15,15,14,14,0,15,0,15,15,15,15,0,0,0,15,15,15,14,14,14,14,13,14,14,14,14,15,14,0,0,0,0,15,15,14,15,15,13,13,13,14,13,14,14,13,14,14,14,12,14,13,14,12,14,13,12,12,12,13,13,13,12,13,13,14,14,13,13,14,14,15,14,15,0,0,15,15,0,15,14,14,14,15,15,15,0,0,0,0,15,15,14,14,15,15,14,14,13,14,14,0,15,0,14,0,15,14,14,14,15,15,15,15,15,15,15,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,15,14,15,14,12,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,13,13,14,13,13,14,13,13,14,13,13,14,13,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,15,15,15,15,0,15,15,15,0,0,0,14,15,14,13,14,14,1,14,15,14,14,14,14,13,13,13,13,13,13,13,14,14,14,14,15,15,0,15,15,0,0,0,15,0,0,15,15,15,14,14,14,13,14,14,14,13,14,14,14,15,15,15,14,15,13,13,13,13,15,14,13,14,13,13,13,13,14,14,14,14,12,14,14,13,13,15,14,12,13,12,13,13,14,12,13,13,14,14,14,13,15,14,15,15,15,15,0,0,15,15,15,15,14,14,14,15,0,0,15,0,0,0,0,14,14,14,15,14,13,13,14,14,15,15,0,14,15,15,14,14,14,15,14,15,15,0,0,0,15,15,14,14,14,14,14,14,14,13,14,13,14,14,15,14,15,14,15,15,14,14,13,13,13,13,13,13,13,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,0,0,0,15,15,14,13,14,15,15,14,14,13,15,13,14,13,14,13,13,13,13,13,14,14,13,15,14,15,0,15,0,0,0,0,0,0,0,15,15,14,14,14,14,14,14,13,14,14,14,14,14,15,14,15,14,14,14,13,14,13,13,0,13,13,13,13,13,15,14,13,14,14,13,13,14,14,13,14,12,12,12,12,13,13,13,13,13,14,13,15,13,14,14,14,15,15,0,15,0,0,15,15,0,0,15,1,14,15,0,0,0,0,0,0,0,14,14,14,15,14,14,2,14,14,15,0,0,14,0,15,14,14,14,15,15,15,15,15,0,0,15,15,14,14,14,14,14,13,13,14,14,14,14,13,13,13,14,14,14,14,15,0,15,15,14,13,13,14,13,13,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,15,14,14,14,15,14,15,14,14,15,14,14,14,15,14,14,14,14,14,13,13,13,13,13,13,13,13,13,14,13,14,13,14,14,13,14,14,14,14,13,14,14,14,14,14,14,14,15,14,15,15,15,8,15,0,0,0,15,15,14,14,14,13,13,13,13,13,14,14,13,14,13,13,13,13,14,13,14,14,13,0,14,15,15,0,15,0,0,0,0,0,0,0,15,15,14,14,14,13,14,14,14,14,14,14,14,15,15,14,14,13,0,15,14,13,14,14,13,13,13,14,13,14,14,14,14,14,13,14,13,15,13,14,14,13,13,12,13,14,13,13,14,13,14,15,14,13,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,15,0,15,14,15,14,14,14,0,0,15,0,0,15,15,15,15,15,15,15,15,15,0,15,15,15,15,14,14,13,14,14,14,14,14,14,14,15,15,15,14,15,14,14,13,14,14,0,0,13,13,13,14,13,13,14,13,13,14,14,14,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,14,13,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,0,0,0,0,0,14,13,14,13,14,14,13,14,13,13,14,13,13,13,13,13,13,13,14,14,13,14,14,0,0,0,15,0,0,0,0,0,0,15,15,15,14,14,14,14,14,13,14,14,14,14,14,14,15,15,14,14,14,14,14,0,15,15,0,14,13,13,13,15,14,14,14,14,13,14,14,14,14,13,13,13,12,13,14,13,13,13,14,15,14,14,13,14,15,15,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,13,14,14,14,13,14,15,15,0,0,0,0,14,15,15,15,15,15,0,15,15,0,15,0,15,15,14,14,14,14,13,14,14,13,14,14,14,15,15,15,15,14,14,14,14,14,14,15,15,14,14,14,15,14,14,14,15,15,14,15,15,0,15,0,15,15,0,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,14,14,13,14,14,13,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,15,8,1,15,0,0,0,0,0,14,14,14,14,13,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,14,14,14,14,0,0,15,0,0,0,0,0,0,0,15,15,14,14,13,14,13,15,14,14,13,13,14,14,14,15,14,14,14,15,13,13,14,14,14,0,15,14,13,14,14,14,13,13,13,14,14,14,13,14,14,14,14,13,14,13,13,13,14,13,14,14,15,14,15,0,0,15,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,14,13,13,14,14,15,15,15,0,0,15,0,14,15,14,0,0,15,15,15,14,15,15,15,15,14,14,14,13,13,13,14,13,14,14,14,14,15,15,14,14,14,14,14,15,15,14,14,14,14,15,15,14,0,15,15,14,15,15,15,15,15,15,0,0,15,15,0,0,14,14,14,14,14,14,14,14,14,15,14,15,14,15,14,14,14,14,13,14,13,13,13,13,14,13,14,14,14,13,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,15,15,0,0,0,0,0,14,14,14,14,14,0,15,15,14,14,14,13,13,13,13,13,13,13,14,13,14,14,14,15,15,0,15,15,15,15,0,0,0,0,15,15,14,14,14,12,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,12,14,14,14,14,14,14,15,13,14,14,0,14,14,13,14,14,14,14,14,14,14,14,13,14,14,12,13,14,14,14,14,15,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,2,13,14,14,14,15,0,0,0,15,0,0,15,15,15,0,0,15,0,15,14,15,15,0,15,15,14,13,13,13,13,13,13,13,14,14,14,14,13,13,13,14,13,13,15,15,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,0,14,0,0,0,0,0,0,0,14,14,14,14,14,15,14,14,15,14,15,14,15,15,14,14,14,14,13,14,13,13,14,13,14,14,13,14,14,13,14,13,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,15,0,0,0,0,0,15,15,14,13,2,14,14,13,13,12,13,13,13,13,13,13,13,13,13,14,14,14,14,15,0,15,15,15,15,15,15,0,0,0,0,15,14,14,14,12,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,1,14,15,14,14,14,14,14,13,14,13,14,13,14,13,14,13,14,13,15,14,15,13,13,14,13,15,15,15,15,0,15,15,0,0,0,15,14,15,15,15,0,0,0,0,15,0,0,0,0,0,0,14,14,14,14,13,14,14,14,0,0,0,0,15,15,0,0,0,0,0,0,15,0,0,14,15,0,0,15,14,14,14,13,14,13,13,14,14,13,14,15,15,13,13,14,14,14,14,14,14,14,14,15,15,15,15,15,15,14,15,14,15,0,0,0,0,15,0,0,0,0,0,0,0,15,14,15,14,14,14,15,15,15,15,15,15,15,15,15,15,14,14,13,13,14,14,13,14,14,14,14,14,13,14,13,13,13,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,15,0,0,0,0,0,0,15,14,14,13,14,13,13,13,13,13,14,13,13,13,13,13,13,14,14,14,15,15,0,0,0,15,0,15,15,15,0,0,0,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,14,14,14,14,15,14,15,14,15,14,13,14,14,14,14,14,14,14,14,13,14,14,14,13,14,14,13,15,14,14,14,14,14,14,0,0,0,15,15,0,0,14,15,15,14,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,14,14,14,14,15,0,0,0,0,15,15,0,0,0,0,0,0,15,0,0,14,15,0,14,0,15,14,14,13,13,13,14,12,12,13,14,15,15,0,0,0,0,0,14,13,0,15,0,15,0,15,15,15,15,15,15,15,15,15,14,14,0,15,0,0,0,0,0,0,0,0,15,14,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,13,14,14,14,14,14,13,14,14,13,14,14,13,13,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,0,0,0,0,0,15,15,14,14,14,13,13,14,13,13,13,13,13,14,13,13,13,13,13,13,12,14,15,15,0,0,15,0,14,15,15,0,0,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,14,15,14,14,14,14,14,13,14,14,14,14,14,14,14,13,13,14,13,13,14,14,14,14,14,14,14,14,15,0,0,15,0,14,14,14,14,14,0,15,0,0,0,0,0,0,0,0,0,0,0,14,15,15,15,15,15,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,14,15,14,0,0,0,15,14,14,14,13,13,13,14,14,14,14,15,15,15,0,0,15,0,0,0,0,0,0,0,15,15,15,15,15,15,15,15,15,15,14,0,0,0,0,15,0,0,0,15,0,0,15,15,14,15,15,14,15,15,15,15,15,15,14,15,15,15,15,14,14,14,14,14,14,14,14,14,14,13,14,13,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,0,0,0,0,15,0,14,14,14,14,13,14,15,14,14,14,14,13,14,13,14,15,13,13,14,15,15,14,15,15,15,14,15,15,14,14,14,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,15,14,15,14,14,14,14,15,14,14,14,14,13,14,14,14,13,14,14,14,14,13,14,13,14,14,14,14,14,14,15,14,14,14,14,14,14,15,15,15,0,13,13,14,14,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,14,15,15,0,15,14,15,15,0,0,0,0,0,15,15,0,0,15,0,0,15,15,0,0,0,0,15,0,15,15,14,14,14,14,13,14,13,14,14,15,15,0,15,0,0,14,15,15,15,14,14,15,14,15,15,8,15,15,8,0,15,0,14,0,0,0,0,0,15,0,0,0,14,0,0,0,15,15,15,0,15,15,15,0,0,0,15,0,0,15,15,14,14,14,14,13,14,14,13,14,14,14,13,13,14,13,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,15,0,0,0,0,15,15,15,15,14,14,13,13,15,14,14,13,13,13,14,14,14,14,14,14,14,15,14,15,14,15,0,14,0,15,0,15,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,13,13,14,14,14,14,14,14,14,14,14,14,13,0,15,15,13,13,13,14,14,15,15,0,0,0,0,0,0,0,15,0,0,0,0,0,14,15,14,0,15,15,15,15,0,0,0,0,0,15,0,0,0,0,0,0,15,0,0,0,0,0,0,15,15,14,15,14,14,14,14,14,14,14,15,15,15,15,15,15,15,14,15,14,14,15,14,15,15,8,15,15,15,15,15,15,0,0,14,0,0,0,0,0,0,0,0,0,14,15,0,0,0,0,15,15,0,0,0,0,15,15,0,15,15,15,15,13,13,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,15,0,0,0,0,0,0,0,15,14,14,14,14,14,13,13,13,14,14,14,14,14,14,14,15,14,14,15,15,14,15,14,15,15,0,15,14,15,14,15,15,14,15,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,15,15,14,13,13,14,14,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,14,15,0,0,0,15,15,15,0,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,14,14,14,14,0,15,15,14,15,15,14,14,14,15,14,15,14,15,14,15,15,15,15,8,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,14,15,0,15,0,0,14,14,14,14,14,14,14,14,14,14,14,13,13,14,13,13,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,0,15,0,15,15,0,0,0,0,13,14,13,14,14,1,15,14,14,14,14,14,14,14,15,14,14,15,0,15,14,15,15,15,14,14,14,15,15,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,15,0,14,13,13,14,14,1,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,15,15,15,0,0,15,15,0,0,0,0,0,0,15,0,0,15,0,15,0,15,0,0,0,0,0,0,15,14,14,15,15,15,15,15,15,0,15,15,15,0,15,14,15,14,15,15,15,8,15,15,15,15,8,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,14,14,14,14,14,15,0,0,14,14,14,14,14,14,14,14,14,13,14,14,14,13,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,15,8,0,0,15,14,14,0,14,14,0,14,14,2,14,13,0,0,0,14,15,15,14,14,14,15,15,0,14,14,14,15,14,14,15,14,14,14,0,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,14,13,14,13,14,14,14,14,14,1,15,15,14,13,14,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,0,0,15,15,15,0,0,15,15,15,15,15,15,15,15,1,15,15,0,0,0,0,0,0,15,15,14,15,15,0,15,0,15,15,15,15,15,15,15,14,0,15,14,0,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,15,14,15,14,14,14,0,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,14,15,15,0,0,0,0,14,13,14,14,14,14,15,0,15,14,15,15,0,15,15,15,14,15,15,14,14,15,14,15,14,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,14,14,14,14,14,14,13,13,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,14,14,14,14,14,14,14,14,15,15,14,14,14,14,15,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,15,15,0,0,0,15,0,15,15,0,0,15,0,15,15,15,15,14,14,8,15,15,0,0,0,0,0,0,15,14,14,0,15,15,15,15,15,15,15,15,15,15,14,15,15,14,15,15,15,15,15,15,15,15,15,15,15,0,0,0,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,15,0,0,14,14,14,14,14,15,14,15,15,14,14,14,14,13,15,15,14,13,13,14,14,14,15,14,14,13,13,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,0,0,15,0,15,0,0,15,15,15,15,14,15,15,0,15,0,0,0,15,0,0,0,15,15,14,14,14,14,14,14,14,15,15,15,15,14,15,14,14,14,15,14,14,14,14,14,14,15,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,13,14,13,14,13,13,14,13,14,14,14,14,14,14,15,14,15,15,15,14,14,14,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,14,15,15,0,15,15,15,15,0,15,0,0,15,14,14,15,15,15,14,14,15,15,15,15,0,0,0,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,14,14,14,15,14,15,14,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,15,15,15,0,15,0,15,15,15,15,0,0,15,15,0,0,13,0,0,14,14,14,14,13,13,15,15,14,14,15,15,14,14,14,14,14,14,14,14,14,15,14,14,14,14,13,14,14,15,14,14,14,15,15,14,15,15,15,0,15,0,0,15,15,15,15,15,0,15,15,15,15,14,15,15,15,15,15,15,0,15,15,15,15,15,15,15,14,14,15,14,15,0,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,15,14,14,15,14,14,13,14,14,14,14,14,14,13,14,13,14,15,15,15,13,14,14,14,14,14,14,14,14,14,15,14,15,14,15,15,15,0,0,0,15,0,15,0,0,0,0,0,0,0,0,0,0,0,15,15,0,15,0,15,0,15,15,0,15,0,15,14,14,13,14,15,15,15,15,14,15,15,15,15,15,0,15,15,15,15,15,15,15,15,15,15,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,14,15,0,15,14,14,15,15,15,0,0,0,15,0,15,0,0,0,0,0,13,14,0,0,15,15,0,14,13,14,14,15,14,15,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,15,14,15,15,15,15,0,0,0,15,15,15,0,15,15,15,15,15,15,0,14,14,15,15,0,15,0,15,14,15,15,15,15,15,13,15,15,14,15,15,15,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,13,14,14,14,14,14,14,13,14,14,14,14,15,15,15,0,15,15,15,14,14,14,15,15,14,15,15,14,14,15,15,15,0,0,0,15,15,0,15,15,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,0,15,15,15,15,14,14,14,15,15,14,15,15,15,15,14,15,15,15,15,15,15,8,15,15,15,15,15,8,14,15,14,14,13,13,13,13,13,14,14,14,14,14,14,14,14,15,14,14,15,8,15,15,15,15,0,15,14,15,15,0,0,15,0,15,0,0,15,0,0,0,0,0,13,15,14,15,0,0,0,0,15,14,14,14,15,15,14,14,14,15,14,14,14,15,15,14,15,15,15,15,15,15,15,15,15,0,14,14,15,15,15,15,0,0,0,15,0,0,15,15,15,15,15,15,15,0,0,15,14,0,15,0,15,15,0,15,15,15,15,15,14,15,14,0,14,15,14,15,14,15,15,14,15,14,14,14,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,14,13,14,13,13,13,14,14,14,13,14,14,15,15,15,15,15,15,0,15,15,15,14,14,14,14,14,15,14,15,14,13,14,15,15,0,0,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,15,15,0,15,15,15,15,15,15,15,15,14,15,15,15,15,15,14,14,14,14,15,14,15,15,15,15,14,14,15,15,8,15,14,15,15,14,14,14,13,13,14,13,13,13,13,13,14,13,14,14,14,14,15,14,14,14,15,14,15,15,15,14,14,14,15,15,0,0,15,15,0,0,0,0,0,0,0,0,13,14,0,0,0,15,15,13,15,14,14,13,14,14,14,14,15,14,14,15,15,15,14,15,14,14,14,14,14,14,14,14,15,15,0,15,15,15,15,15,0,0,0,15,0,15,15,15,15,15,15,15,0,15,0,0,0,14,15,15,0,0,0,15,15,0,15,15,15,15,15,15,15,15,15,15,15,14,15,15,15,15,14,15,14,13,14,15,14,15,13,15,15,14,15,14,15,14,14,14,14,14,14,14,13,14,14,14,13,13,15,14,14,13,14,14,14,2,14,14,14,15,15,15,14,15,0,0,0,15,14,14,14,15,14,15,15,14,13,14,14,14,15,0,0,15,15,15,1,15,0,0,0,0,15,0,0,0,0,15,15,15,15,15,15,15,14,14,14,14,14,14,14,15,15,15,15,14,14,14,14,14,14,14,15,14,15,14,14,14,15,15,15,15,14,15,14,14,14,14,14,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,15,14,15,8,15,14,14,15,15,15,15,0,15,0,15,0,0,0,0,0,0,0,13,15,15,0,14,15,0,14,15,14,15,14,14,14,14,15,14,15,14,14,14,14,15,14,2,14,15,15,15,0,15,0,15,14,15,15,0,0,15,0,0,0,0,15,15,15,15,14,15,15,14,15,15,15,15,15,0,15,14,15,14,15,0,15,15,15,15,15,15,15,15,15,15,14,14,14,14,15,14,14,15,14,15,15,15,13,14,15,15,15,14,15,15,15,14,15,14,14,14,14,14,14,13,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,15,14,14,15,0,15,15,0,15,15,14,15,15,0,14,14,15,15,0,14,13,14,14,14,15,0,15,15,15,14,15,15,0,0,0,14,13,15,15,15,15,15,15,15,14,14,14,14,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,14,14,13,14,13,13,13,14,13,13,13,13,14,14,14,14,14,15,14,14,14,14,15,15,14,14,14,15,0,15,15,0,0,15,0,15,0,0,0,0,0,14,14,0,15,0,13,15,14,15,14,14,14,14,14,14,14,14,14,15,14,15,1,15,14,15,15,15,0,0,0,15,0,0,14,15,15,14,0,15,0,0,15,15,15,15,15,14,14,14,14,14,14,14,15,14,15,15,15,15,14,15,14,14,15,15,15,15,15,15,15,15,14,14,14,15,14,14,15,14,15,15,15,15,15,14,15,15,15,15,15,0,13,0,15,15,14,15,15,14,15,14,14,14,14,14,14,13,14,14,14,14,15,13,14,14,14,13,15,15,15,14,13,14,14,14,14,0,15,15,0,0,14,14,15,15,15,15,14,13,13,14,14,15,15,0,15,15,1,14,15,0,0,15,0,0,15,0,14,14,14,14,14,15,14,14,15,15,14,14,15,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,11,12,13,13,13,13,13,14,14,14,14,14,14,14,15,14,14,15,14,14,14,14,0,0,15,15,0,0,15,0,0,15,0,0,0,15,0,0,0,15,14,15,14,14,14,14,14,13,14,14,14,14,15,15,15,15,14,0,0,15,15,15,15,15,15,15,0,0,15,14,15,0,14,0,0,0,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,13,13,14,14,14,13,15,15,14,15,14,14,14,15,15,14,15,0,14,15,15,15,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,14,14,14,15,14,14,14,13,14,14,14,14,14,13,14,13,14,12,13,14,15,14,15,15,15,0,15,15,15,14,15,0,0,0,0,0,15,15,15,15,15,15,0,13,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,14,13,14,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,15,14,13,14,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,15,15,15,14,15,15,14,14,14,14,14,14,14,14,14,14,15,14,15,14,14,2,13,2,13,2,2,14,15,0,15,15,15,0,15,15,0,0,0,0,15,15,15,14,15,14,14,14,14,14,14,14,14,14,15,15,14,15,14,14,14,15,14,15,14,15,15,15,15,14,0,14,15,0,15,15,15,15,0,15,15,14,13,14,14,15,15,15,15,15,14,15,14,14,14,13,14,13,14,13,13,14,14,13,14,14,14,14,13,14,14,14,15,14,15,15,15,15,15,14,15,15,14,14,0,0,0,15,15,14,15,15,0,15,15,14,13,14,14,0,15,15,15,15,15,14,15,15,15,15,15,14,14,14,13,13,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,13,13,13,14,14,14,14,14,14,14,14,14,13,14,13,14,14,13,15,0,0,0,0,0,0,15,1,15,14,14,13,13,13,13,13,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,14,14,14,15,14,14,13,14,13,14,14,14,14,14,14,14,2,13,2,14,15,1,14,15,2,14,0,15,0,15,14,0,0,0,0,15,15,15,15,15,8,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,14,15,14,15,15,15,0,15,0,15,15,14,15,15,15,15,15,15,15,15,0,15,0,15,14,15,14,14,14,14,14,14,14,15,14,13,14,14,14,14,14,13,13,14,14,14,13,14,14,14,14,14,15,15,14,0,14,0,15,14,15,15,14,14,14,14,0,15,0,15,15,15,15,15,15,15,14,14,14,14,15,15,15,15,15,15,14,14,14,15,14,14,14,14,14,14,13,14,14,13,14,14,14,14,14,13,14,13,14,14,13,14,14,13,14,13,13,14,13,14,14,13,14,13,14,14,13,14,14,13,15,14,15,15,15,1,14,14,14,15,15,0,15,14,13,12,13,13,14,13,14,13,14,14,14,14,14,14,14,13,14,13,14,13,14,14,15,15,0,15,15,15,14,0,0,15,15,15,15,15,14,14,15,15,13,15,15,14,14,14,13,14,13,14,13,14,14,14,15,14,14,15,15,2,2,2,14,2,13,15,15,14,14,0,0,0,0,0,0,0,0,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,0,14,15,15,15,14,14,14,15,0,15,15,0,0,0,15,15,0,15,0,0,14,14,15,15,15,14,14,14,14,14,14,14,13,14,13,13,3,14,13,13,14,14,14,14,13,13,14,14,15,15,15,14,0,0,15,15,15,14,15,14,15,15,15,15,15,15,15,13,14,14,15,14,15,15,14,15,14,14,15,14,14,15,14,14,15,14,14,14,12,14,14,13,13,14,14,14,13,13,14,13,14,13,13,13,13,13,14,14,13,13,13,14,13,13,14,13,14,13,13,14,13,14,13,13,13,13,14,0,13,14,13,14,2,14,0,14,14,15,14,14,14,15,14,14,13,14,14,13,13,14,13,14,14,13,13,14,13,14,13,14,14,14,14,14,14,14,14,14,15,0,0,15,15,15,15,15,15,14,15,0,14,15,14,14,14,13,13,13,13,13,14,13,14,14,14,14,14,2,3,2,3,14,2,14,1,2,14,15,14,0,0,0,0,0,0,0,0,15,15,8,14,14,14,14,14,14,14,14,14,13,13,14,14,14,14,14,14,14,0,14,13,15,14,14,15,14,15,15,15,15,15,0,15,15,15,15,15,0,15,0,2,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,13,14,14,14,14,14,15,14,15,0,15,0,15,14,14,14,15,15,15,0,0,14,15,15,15,14,15,15,14,14,14,15,14,14,14,14,14,14,14,15,14,15,14,15,14,14,14,12,13,14,14,14,14,14,13,13,13,13,13,13,14,13,13,14,13,14,13,14,13,13,13,14,13,13,13,13,13,13,13,13,14,13,14,13,14,15,13,13,13,14,15,2,13,14,13,15,15,12,13,15,14,13,13,14,1,14,14,13,14,14,14,13,14,13,13,13,13,14,14,14,14,14,15,14,14,14,15,0,0,0,0,0,0,0,0,0,15,15,14,14,14,13,14,13,12,13,13,13,14,13,14,14,14,14,14,3,2,13,2,3,2,2,14,14,14,15,15,0,15,14,0,0,0,0,0,15,14,14,14,14,14,14,14,14,14,13,14,14,14,13,14,14,13,14,14,14,14,14,14,15,14,0,14,14,0,0,15,0,15,0,14,0,0,15,15,0,0,15,13,15,15,15,15,15,14,14,14,14,14,14,13,13,13,14,13,14,14,14,14,13,14,13,14,14,14,0,14,0,0,0,15,0,0,15,14,14,0,0,0,15,15,14,15,0,15,14,15,14,15,15,14,14,14,15,14,14,14,14,14,15,14,14,15,14,14,14,14,14,15,14,14,14,14,14,13,13,13,14,13,13,13,14,13,13,13,13,13,13,13,14,13,13,13,13,14,13,13,13,13,13,13,13,13,13,14,14,13,1,15,14,3,3,13,14,14,14,15,13,3,14,14,13,13,14,15,13,13,13,14,14,13,13,13,13,13,14,13,14,14,14,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,15,15,15,14,15,14,14,14,13,13,13,13,13,13,14,14,14,14,14,14,14,3,2,13,2,13,14,2,13,0,14,15,0,15,15,14,0,0,0,0,14,14,15,14,14,14,13,14,13,14,14,14,13,14,14,14,14,14,14,14,14,14,1,14,15,15,15,14,14,15,0,15,0,0,14,0,15,15,0,15,15,14,14,15,15,15,15,15,15,15,14,13,14,14,13,14,14,13,2,13,13,13,14,12,2,14,14,14,14,14,14,15,15,14,14,14,13,14,14,14,15,0,0,0,14,0,14,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,13,14,13,13,13,13,14,13,13,13,13,13,13,13,14,13,13,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,14,13,14,1,14,3,3,14,14,14,14,0,0,14,14,14,15,13,15,15,13,13,13,13,13,14,13,13,13,13,13,13,14,14,0,15,15,0,0,0,0,0,0,0,0,0,0,0,15,15,15,8,14,14,14,14,13,14,13,13,13,13,14,13,13,13,14,13,14,14,14,14,3,13,13,2,14,14,14,1,15,14,0,15,15,0,15,0,0,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,3,14,13,0,1,15,1,15,15,14,14,14,15,15,15,15,15,14,0,0,15,0,0,0,0,15,0,0,0,0,15,14,15,14,14,14,13,14,14,13,13,14,13,14,13,14,13,14,13,13,13,8,14,14,14,14,13,14,14,14,14,14,15,14,14,14,14,0,0,0,14,14,14,14,15,15,15,15,15,15,15,14,14,14,13,14,13,14,14,13,14,14,14,14,14,14,14,13,14,13,14,14,14,14,14,13,13,14,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,13,13,13,13,14,12,14,3,1,8,13,13,14,14,15,0,0,15,15,15,14,15,15,15,13,13,14,14,14,13,13,14,13,13,14,13,14,14,15,15,0,15,0,15,0,0,0,15,0,15,15,14,14,14,14,14,14,14,13,14,14,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,13,2,13,13,13,14,14,14,15,15,0,0,15,15,0,0,0,0,14,15,14,14,14,15,14,13,14,15,14,14,15,15,13,15,15,15,15,14,15,15,14,14,14,15,15,15,14,0,15,15,15,0,15,0,0,0,15,15,15,0,0,15,14,15,13,14,13,14,13,14,13,13,13,2,13,13,14,14,13,13,14,13,13,14,14,14,14,14,14,15,14,14,14,14,15,14,15,14,0,0,0,14,15,15,14,14,15,0,15,0,15,14,15,13,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,13,12,13,12,13,14,13,14,3,2,14,1,13,3,14,15,0,0,15,15,15,15,15,15,0,14,13,14,13,14,13,13,13,13,13,13,13,14,14,14,15,14,15,14,14,13,13,15,14,14,15,15,15,14,14,14,14,14,13,13,13,13,14,13,13,13,13,13,13,13,14,13,13,14,14,13,14,14,14,13,14,14,2,14,0,15,0,15,15,0,0,0,0,0,0,14,14,14,0,0,0,14,14,15,14,14,0,0,15,14,13,15,15,15,15,15,15,15,15,15,15,15,14,14,15,15,14,14,14,14,0,0,0,0,15,15,14,1,14,14,15,14,14,14,13,14,13,14,14,14,13,14,13,14,13,14,14,13,13,14,13,14,13,14,14,15,0,1,14,14,14,14,15,14,15,15,15,14,14,14,14,15,14,14,15,15,15,13,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,13,14,13,14,14,14,14,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,15,13,14,13,13,13,15,15,15,15,0,15,0,15,15,0,0,0,15,15,15,14,14,13,14,14,14,13,14,13,13,13,13,14,14,14,14,14,14,15,15,15,14,14,14,14,14,15,14,14,14,13,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,14,0,15,15,0,15,15,0,0,0,0,0,14,15,15,15,0,0,14,0,0,14,15,0,15,15,14,14,14,15,15,14,15,14,14,14,14,15,14,14,15,13,13,0,15,14,14,1,0,14,15,0,15,15,15,15,15,14,14,14,13,14,13,13,14,13,13,13,13,14,13,14,14,14,14,14,13,13,14,14,15,15,15,14,15,14,14,14,14,0,15,14,14,14,15,14,14,14,13,14,13,14,15,0,14,15,14,14,13,14,14,14,13,14,14,14,13,14,14,15,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,14,13,13,13,13,13,13,14,15,14,14,3,13,2,2,13,0,14,0,15,0,15,15,0,14,15,15,15,14,14,15,15,0,0,15,14,13,14,13,13,14,14,14,15,14,14,15,15,14,14,14,14,14,14,15,15,15,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,14,13,13,14,13,14,14,14,14,14,14,14,14,13,14,15,15,15,15,15,15,15,0,0,0,0,14,14,14,15,14,14,14,15,15,15,0,15,15,14,13,15,14,15,15,14,15,15,14,15,14,15,15,14,15,0,0,15,15,14,14,0,0,0,0,15,0,15,15,14,14,14,14,13,14,13,14,14,13,2,14,13,14,14,14,14,14,14,13,14,14,13,13,14,13,15,14,14,0,15,14,14,14,0,14,13,13,14,13,13,13,13,14,13,13,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,13,14,13,14,13,13,13,13,13,13,13,14,13,13,13,14,13,13,13,14,13,13,13,13,13,14,13,13,13,14,13,14,13,14,14,0,13,14,3,13,13,14,13,0,14,0,15,0,15,0,0,15,15,14,14,14,14,15,0,15,0,0,14,14,14,13,13,14,14,14,15,15,14,14,14,14,14,14,14,14,1,14,14,15,15,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,14,13,13,14,14,13,14,14,14,14,14,14,14,14,15,15,15,0,15,15,15,0,0,0,0,14,15,15,0,15,15,15,0,15,15,14,15,0,15,15,14,15,15,14,15,14,15,15,14,15,15,15,14,0,0,0,14,14,15,0,15,0,0,0,0,0,0,15,14,14,14,14,14,13,14,13,2,13,7,13,14,13,14,14,14,13,13,14,14,13,14,13,13,14,15,15,15,15,14,14,14,14,14,14,13,13,13,13,13,13,13,13,14,14,13,13,15,14,13,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,13,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,14,13,13,13,14,13,14,13,14,0,3,14,13,2,13,2,14,15,14,15,0,0,0,0,15,14,14,15,14,14,15,0,0,0,0,15,15,14,13,14,13,14,14,14,15,14,0,15,14,14,14,14,1,15,14,14,15,14,15,15,14,14,14,14,14,13,14,13,13,14,13,13,14,13,13,13,14,13,14,14,13,14,14,14,14,14,14,14,14,15,15,0,0,15,0,0,0,0,0,14,15,0,0,0,0,0,0,15,14,0,0,0,15,15,14,14,14,15,14,15,14,15,15,15,14,14,14,15,0,0,15,14,0,14,15,0,0,15,15,0,15,15,13,15,14,14,14,14,13,14,14,14,14,14,14,14,14,14,13,13,13,14,13,14,12,13,13,14,15,14,14,15,14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,13,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,13,13,14,13,14,13,14,13,14,0,14,15,3,13,14,13,14,15,14,0,0,0,0,0,0,15,14,14,14,14,14,15,0,0,15,14,15,14,14,13,14,14,14,14,15,15,14,15,15,15,14,14,14,14,14,15,14,15,14,15,14,14,14,14,14,13,14,13,14,13,13,13,13,13,14,13,13,14,13,14,14,13,14,13,14,14,14,14,15,14,15,15,0,0,0,0,0,0,0,14,0,15,0,0,15,0,0,14,14,0,14,14,14,14,15,15,14,14,8,14,14,14,15,15,15,15,13,14,14,0,15,15,14,0,0,0,14,13,15,14,14,15,15,14,14,14,14,14,14,14,14,13,14,13,14,13,14,14,13,14,13,13,14,13,13,13,14,14,14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,13,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,14,13,13,13,13,13,12,13,13,13,13,13,13,13,13,13,13,14,13,14,13,14,13,14,15,1,14,0,15,14,14,13,2,14,2,15,15,15,0,0,0,0,0,15,14,14,14,14,15,0,0,0,0,0,15,14,14,13,14,15,15,14,15,14,15,14,15,15,14,15,14,15,14,14,15,15,15,15,15,14,14,14,14,14,14,13,13,13,14,13,14,13,14,13,14,13,14,13,14,14,13,14,14,14,14,14,14,14,15,0,0,0,0,0,0,0,0,15,15,0,0,0,15,0,0,14,14,14,15,14,14,14,15,14,14,14,14,14,14,14,14,14,15,0,14,13,14,14,14,14,14,1,14,15,14,14,14,13,0,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,13,14,13,13,12,13,13,14,14,14,14,13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,14,15,14,14,14,14,14,14,14,14,13,15,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,13,14,13,13,13,14,13,13,13,13,13,13,14,14,14,13,13,13,14,13,14,13,13,13,14,14,14,14,13,2,14,15,15,14,14,14,1,14,13,14,14,15,15,15,0,0,0,0,0,15,14,14,14,14,15,0,0,0,0,0,15,14,14,15,14,0,0,14,14,14,14,14,15,14,0,15,15,15,14,15,14,14,15,14,15,15,15,14,14,14,14,14,14,14,14,14,13,14,13,14,14,13,14,14,13,13,14,14,13,14,14,14,14,15,15,0,0,0,0,0,0,0,0,15,14,15,0,0,0,0,0,15,14,15,14,14,14,14,15,14,14,14,14,14,14,14,14,14,15,15,14,2,0,15,15,14,14,14,14,14,14,14,14,0,15,14,15,15,15,14,13,15,14,13,14,13,14,14,14,14,14,13,14,14,14,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,14,13,14,13,13,14,13,13,13,14,15,13,14,13,14,13,14,14,13,14,14,14,14,13,13,13,2,14,14,15,15,14,2,14,13,0,1,13,1,15,15,0,15,0,0,0,0,0,1,14,14,14,15,0,0,15,0,0,15,0,14,14,14,0,0,14,14,13,15,15,8,14,14,15,14,15,14,15,15,15,15,0,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,13,14,14,14,14,15,15,15,0,0,0,0,0,0,0,0,15,15,15,0,0,15,0,15,14,14,15,14,13,14,15,14,14,14,14,14,14,14,14,14,15,14,14,14,14,13,0,14,0,0,15,15,15,15,15,15,15,14,14,14,15,14,15,15,13,13,14,14,14,14,14,13,14,14,14,14,14,13,13,13,12,12,13,13,13,13,13,13,13,13,13,12,13,13,13,13,13,12,13,13,13,13,13,13,14,13,15,14,14,14,14,14,15,14,15,0,0,0,15,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,14,13,0,14,13,14,13,13,14,14,14,14,14,14,14,14,14,14,15,13,15,14,14,14,15,14,13,1,15,0,15,15,15,15,0,15,15,0,15,15,15,14,14,14,14,14,15,0,14,0,0,0,0,14,14,15,0,15,14,14,14,15,0,0,14,14,15,0,15,15,8,14,15,14,14,15,14,15,15,15,15,15,14,14,14,14,14,14,13,14,14,13,14,14,14,13,14,14,14,14,14,14,14,15,15,0,0,0,0,0,0,0,0,0,15,14,15,14,14,14,14,14,14,13,15,14,14,15,14,13,14,14,14,14,14,14,14,14,15,15,14,14,2,13,0,15,0,15,15,14,14,14,14,15,15,14,14,14,15,14,14,14,14,14,13,14,13,14,14,14,13,14,13,14,14,14,13,13,13,12,13,12,13,12,12,13,12,12,12,13,12,13,13,12,13,13,13,13,13,13,13,14,13,13,14,14,13,14,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,13,14,14,14,13,0,15,13,14,14,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,1,14,13,0,0,14,13,14,0,0,0,15,14,15,15,15,14,14,14,14,14,14,14,14,14,15,15,0,15,15,14,15,14,14,15,15,13,14,14,15,15,15,14,14,0,0,0,15,15,15,0,15,0,15,15,15,14,14,15,14,15,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,0,0,0,0,0,0,0,0,15,15,15,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,13,14,14,14,14,14,15,14,0,13,14,15,14,0,0,0,0,15,1,15,15,15,15,0,13,15,14,14,14,14,14,15,14,14,2,13,13,14,13,14,14,13,14,14,14,14,13,13,12,12,12,12,12,11,12,12,12,12,13,12,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,15,14,14,15,12,14,14,14,14,13,14,13,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,13,14,14,0,0,15,14,13,14,14,3,13,14,14,14,13,14,14,13,14,2,14,14,14,15,14,1,14,0,15,14,13,14,15,15,15,14,15,14,14,14,14,13,14,13,14,14,14,14,14,14,15,0,15,0,15,15,15,0,14,14,15,14,14,14,14,15,0,15,15,14,15,15,14,8,14,15,8,0,0,0,0,0,0,0,0,15,15,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,0,0,0,0,0,0,15,15,8,14,15,14,14,14,14,14,15,14,13,14,14,13,14,14,14,14,13,14,14,14,15,14,14,13,14,14,14,0,0,15,15,15,14,14,14,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,14,14,14,14,13,13,12,12,11,11,11,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,14,13,13,14,14,14,14,14,14,14,14,15,13,0,13,3,0,14,14,14,13,14,13,14,13,14,14,14,14,13,14,13,14,13,14,14,14,14,14,15,14,15,15,0,14,14,14,2,14,13,13,13,15,14,14,14,14,13,13,14,14,14,14,13,15,14,14,1,15,0,15,15,14,14,14,14,14,14,13,13,13,14,14,14,13,14,14,15,14,14,0,15,0,0,0,0,0,13,14,15,14,8,14,8,15,0,0,0,0,0,0,15,15,15,8,15,0,0,15,0,0,15,15,15,15,15,0,0,0,0,0,0,0,14,14,14,14,14,14,14,15,14,15,0,0,15,0,0,0,0,0,0,0,15,15,15,15,14,14,14,14,14,14,0,14,14,13,13,0,15,14,14,15,0,14,14,14,15,15,14,14,0,13,0,0,0,15,15,15,14,14,1,0,15,2,0,15,15,14,14,14,14,14,14,14,14,14,14,13,14,14,13,13,14,13,14,14,13,14,13,13,12,11,12,11,11,12,12,12,12,12,13,13,12,13,13,13,13,13,14,14,14,14,13,14,14,14,14,14,14,15,15,14,0,13,13,14,15,14,13,13,13,14,13,14,13,14,14,14,14,14,14,14,14,15,15,15,15,14,15,15,15,0,15,0,14,14,8,15,8,14,14,13,14,14,14,13,14,13,13,13,14,13,3,13,13,15,14,14,1,14,14,15,14,14,14,14,14,14,14,14,13,14,0,14,14,14,14,14,14,15,15,15,0,0,0,0,14,14,14,14,14,14,8,15,15,14,14,14,14,15,14,0,15,0,0,0,0,0,0,0,15,15,8,15,8,15,15,15,0,0,0,0,14,14,14,14,14,14,14,14,15,15,15,0,0,0,0,0,0,0,0,0,15,15,15,14,15,14,14,14,14,0,0,0,14,15,0,14,14,0,0,0,15,14,14,14,14,15,13,0,15,14,0,0,0,0,15,0,0,0,0,15,0,0,15,15,14,14,15,14,14,14,14,14,14,14,13,14,13,14,14,14,13,13,13,14,14,14,13,12,12,11,11,11,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,14,14,14,13,14,14,14,15,15,15,14,0,14,3,14,14,14,13,13,13,14,14,14,14,14,15,14,15,14,15,14,14,14,14,14,14,14,14,15,14,14,15,15,14,0,15,14,14,14,14,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,1,15,15,15,14,13,14,13,13,14,13,14,15,0,0,0,0,15,14,14,14,14,14,14,15,15,15,15,15,15,13,15,14,8,14,14,15,14,14,14,14,14,14,14,14,14,15,0,0,0,0,15,15,0,0,0,0,0,15,0,0,0,0,0,0,0,15,14,15,14,14,14,15,15,15,15,0,15,0,0,0,0,0,0,0,0,15,15,15,14,14,15,14,15,15,0,0,15,15,0,15,14,0,0,0,0,14,14,14,14,14,0,15,15,14,15,0,0,0,0,0,0,15,0,15,0,0,15,15,15,14,0,15,14,14,14,14,14,14,13,13,13,13,13,13,12,13,13,13,13,14,13,13,13,12,11,11,12,12,12,12,12,12,12,13,13,13,13,13,13,13,14,13,14,13,13,14,14,14,15,15,15,15,15,15,14,15,14,13,3,13,13,13,14,13,14,13,14,14,14,14,15,14,14,14,14,14,14,14,14,15,14,14,15,14,13,15,15,14,15,14,15,14,14,14,14,14,13,13,14,13,13,13,13,13,13,3,13,13,13,14,14,14,14,14,14,14,14,0,0,0,15,15,15,0,15,15,15,14,14,14,14,14,15,15,15,0,14,15,15,14,14,8,14,15,8,15,14,14,14,14,14,14,14,13,15,0,15,0,0,0,15,0,0,0,0,0,0,0,0,0,14,15,15,0,0,14,14,14,14,15,14,14,15,14,15,15,0,0,0,0,0,0,0,0,0,15,15,15,0,15,15,14,14,15,14,14,15,0,14,15,0,0,0,15,15,14,0,14,14,15,15,15,15,15,15,0,0,0,0,0,1,15,15,0,15,14,15,0,15,0,14,15,15,14,14,14,14,14,14,14,14,14,14,13,14,13,14,13,14,13,13,13,13,11,12,11,11,11,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,15,13,15,14,14,13,15,14,13,13,13,13,13,13,13,13,14,14,14,14,15,14,13,14,13,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,13,13,14,13,13,3,12,12,13,13,14,14,13,14,14,0,15,14,15,8,14,15,15,14,0,0,0,0,0,14,14,14,14,14,14,14,15,14,14,14,14,14,15,14,0,0,15,15,15,14,14,14,14,14,14,14,13,15,15,0,0,0,0,15,15,0,0,0,15,0,0,0,15,13,0,0,14,14,14,14,14,14,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,15,15,0,15,15,15,0,0,15,14,15,0,0,0,0,15,15,15,0,0,15,0,14,14,14,15,15,15,0,0,0,0,0,0,15,15,0,15,13,14,14,0,15,0,14,13,14,15,15,14,14,14,14,14,14,14,14,13,13,13,13,14,13,13,13,14,13,12,12,12,11,12,11,11,12,12,12,12,13,13,13,13,14,13,14,14,13,14,14,14,14,14,14,14,14,14,13,13,14,13,13,13,14,14,14,13,14,13,14,13,14,14,13,15,14,14,14,14,13,14,13,13,14,14,14,14,14,13,14,14,13,14,13,14,14,14,14,14,14,14,13,14,13,13,13,13,13,13,13,14,14,14,14,14,0,0,0,0,15,8,14,14,14,15,15,0,0,0,14,14,0,13,13,13,14,14,14,14,14,15,15,14,15,14,14,14,15,0,0,15,14,14,14,14,14,14,14,13,15,8,14,15,0,0,0,0,0,15,0,0,0,15,0,14,0,15,14,15,0,14,14,14,14,15,14,14,15,15,15,15,0,0,0,0,0,0,0,0,0,0,15,0,0,15,15,0,0,0,0,0,0,0,0,15,15,15,0,0,0,15,0,14,0,14,15,15,15,15,15,0,0,15,15,0,15,0,15,15,14,3,14,0,15,0,0,13,15,15,14,15,14,14,14,14,14,14,13,14,13,14,13,13,14,13,13,13,13,13,12,11,11,11,12,11,11,12,12,13,13,13,13,13,13,14,13,13,14,13,13,13,13,14,14,14,13,13,13,12,13,13,13,13,13,13,12,14,13,13,13,13,14,13,14,14,14,14,14,14,14,14,14,1,14,13,14,14,14,14,13,14,14,14,14,14,14,15,0,15,15,14,13,13,13,14,14,14,14,15,15,15,15,14,15,0,15,15,0,0,15,15,0,0,0,14,14,13,13,15,13,14,0,14,13,13,13,14,14,14,13,0,0,14,15,14,14,15,14,15,14,15,14,14,14,14,14,13,14,14,14,14,13,14,0,0,0,0,15,15,0,0,0,15,15,15,15,15,14,0,0,0,0,14,14,14,14,14,14,15,15,15,0,15,0,0,0,0,0,0,0,0,0,0,15,0,15,15,15,0,0,0,0,0,15,14,15,0,0,15,0,15,14,14,0,14,14,15,15,15,15,15,0,15,0,0,0,15,0,0,0,0,0,0,15,15,0,15,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,14,13,12,12,12,11,12,11,11,12,11,12,12,13,13,13,13,13,13,13,13,13,13,14,13,14,13,13,14,13,13,13,12,13,13,13,13,14,12,12,13,13,13,13,14,14,14,14,15,14,14,14,14,14,14,14,13,15,15,15,14,14,13,15,14,14,14,14,14,14,14,14,14,14,15,15,14,14,15,15,0,15,15,14,14,14,14,15,0,0,0,0,0,15,14,13,13,13,13,13,13,13,15,14,14,0,14,14,13,14,13,14,14,14,15,15,14,15,14,14,15,14,8,14,14,14,14,14,14,14,14,14,14,14,15,14,13,0,0,0,0,14,8,15,0,15,15,14,0,15,15,15,15,0,0,0,14,14,15,14,15,0,0,15,0,15,0,15,0,0,0,0,0,0,0,0,0,15,15,15,15,0,0,14,0,0,15,14,14,0,0,15,0,14,15,14,14,15,0,15,15,15,15,15,0,15,15,0,15,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,14,14,14,14,14,14,13,13,13,14,13,14,14,13,13,13,13,12,12,11,12,11,12,11,11,12,12,12,13,13,13,13,13,13,14,13,14,13,13,13,13,13,13,13,13,13,13,12,13,12,13,13,12,13,12,13,13,14,14,13,14,14,14,13,14,15,14,2,15,15,15,0,15,14,14,14,13,14,14,14,13,13,13,13,14,15,14,14,14,14,15,15,0,0,14,14,15,8,14,8,15,15,0,0,0,15,15,15,14,12,13,13,13,13,13,13,13,14,13,13,0,14,0,13,13,14,13,14,14,0,15,14,14,14,14,8,14,14,15,14,14,14,13,14,13,14,13,14,14,14,0,0,0,15,15,15,15,14,14,15,0,15,15,14,14,14,14,14,14,0,14,15,15,15,15,15,15,15,0,15,0,0,0,15,0,0,0,0,0,0,0,0,0,15,15,0,0,0,0,0,0,0,14,15,14,14,0,15,15,15,15,15,14,15,15,15,15,15,15,0,0,15,15,15,15,0,0,0,0,0,0,0,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,13,14,13,14,13,13,13,13,13,13,12,12,12,11,12,11,12,12,11,12,12,12,13,13,13,13,13,13,13,13,13,13,12,13,13,13,13,12,12,12,12,12,12,12,13,13,12,12,13,13,14,13,14,14,14,14,15,15,13,14,15,14,0,15,15,14,15,14,13,13,14,13,13,14,13,13,14,14,14,0,0,14,14,8,0,15,15,14,0,0,0,0,15,15,0,15,0,0,15,15,0,0,0,13,13,13,13,13,13,13,14,13,14,13,15,15,13,14,13,14,14,14,15,15,14,14,14,14,15,14,8,14,14,14,14,14,13,14,14,14,13,13,15,0,0,0,0,0,15,14,15,15,0,15,14,15,15,14,14,14,14,15,15,15,15,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,0,0,0,15,0,15,0,0,0,0,0,0,0,0,14,15,15,0,15,14,14,15,15,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,14,15,14,14,14,14,14,14,14,14,13,14,14,14,13,14,13,14,13,14,13,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,11,12,12,12,12,13,13,13,13,13,15,13,14,14,14,14,15,15,14,14,15,14,14,14,14,15,15,15,14,14,13,13,13,14,13,13,13,13,14,14,14,0,15,14,14,15,0,0,0,0,15,14,13,13,13,13,15,0,0,15,0,0,15,15,0,15,13,13,13,13,13,14,13,13,13,14,14,14,13,13,14,13,14,14,15,15,14,14,14,14,15,15,15,14,14,14,13,14,14,14,13,14,14,13,15,0,0,0,0,0,0,0,0,0,0,14,0,15,14,15,14,15,14,0,14,14,15,14,15,15,15,15,0,0,15,15,15,15,15,15,15,15,15,15,15,15,0,0,15,15,15,15,0,15,15,0,0,15,14,15,15,15,15,14,14,0,0,15,15,0,0,14,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,13,13,12,13,12,12,12,13,13,12,12,12,13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,13,13,13,13,13,14,13,13,14,13,14,14,14,14,14,15,14,15,15,14,14,14,14,15,14,14,14,14,13,14,13,13,13,14,13,13,13,15,15,14,14,14,14,15,15,14,13,13,13,13,13,14,13,8,13,0,0,15,0,0,0,0,0,15,13,13,13,13,13,14,13,13,14,13,14,14,13,13,14,13,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,13,14,0,0,15,0,0,0,0,0,0,0,15,14,14,15,14,14,14,0,15,15,15,15,15,0,15,15,15,0,0,15,15,14,15,14,15,15,15,15,15,15,15,0,15,15,15,15,15,8,14,14,15,14,14,15,13,0,15,14,15,0,0,0,0,15,14,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,15,15,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,13,13,13,14,13,13,13,13,13,13,13,13,13,13,12,13,12,13,12,13,13,13,13,13,13,13,14,13,13,13,13,13,13,13,13,13,13,12,13,13,14,13,14,14,14,14,15,14,14,15,1,15,14,14,15,0,14,15,14,14,14,14,14,14,13,13,14,14,13,14,13,14,14,13,14,15,14,14,14,8,14,13,13,13,14,14,13,13,13,13,14,13,0,15,0,14,14,14,14,0,14,13,13,13,13,13,15,13,13,13,13,14,13,14,13,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,13,8,0,0,15,15,0,0,0,0,0,0,15,14,14,14,14,14,14,0,14,14,14,14,15,15,15,15,14,0,0,15,15,15,14,15,15,15,15,15,15,15,15,0,0,15,15,15,15,14,15,15,15,15,13,0,14,15,15,15,0,15,0,15,0,0,0,14,15,15,0,15,0,0,0,15,15,0,0,0,0,0,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,13,14,13,13,13,13,13,13,13,13,12,13,13,12,13,12,12,13,13,13,13,13,13,13,14,13,14,13,12,13,13,14,13,13,14,14,14,14,14,2,14,14,14,14,14,14,14,14,14,15,15,15,0,15,15,15,15,14,14,14,14,14,13,14,14,14,14,13,13,14,13,14,15,14,14,14,14,15,14,14,14,13,14,13,14,13,13,15,13,0,0,15,13,15,14,14,0,14,13,13,13,13,13,8,13,13,14,14,14,13,14,14,13,14,14,14,15,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,15,0,0,0,15,15,0,0,15,14,15,14,14,14,14,14,14,15,15,14,14,14,15,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,0,15,0,15,15,15,15,15,15,13,0,14,15,15,15,0,15,15,15,0,0,0,0,0,0,15,14,15,15,0,0,0,0,0,0,0,0,0,0,0,0,15,0,14,15,14,14,14,15,14,14,14,14,14,14,14,13,14,14,14,14,15,13,13,13,13,13,13,13,13,12,13,12,13,12,13,13,12,13,12,13,13,13,13,14,14,13,13,13,13,13,14,14,14,13,14,13,15,14,14,13,14,14,14,15,14,14,14,15,14,14,14,15,0,15,15,15,15,15,14,14,14,14,14,14,14,14,13,14,14,13,13,14,15,14,14,14,14,8,14,14,13,14,14,13,13,13,13,15,0,0,0,13,14,14,14,14,14,13,13,13,13,14,13,14,13,13,14,13,14,14,13,14,14,14,13,14,15,15,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,13,0,0,15,15,15,15,15,15,14,14,15,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,0,0,0,15,15,15,8,15,15,15,15,14,0,13,15,15,0,15,0,0,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,13,14,13,13,13,13,13,13,13,12,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,14,14,14,15,15,15,0,15,15,15,15,14,14,14,14,14,14,14,14,15,14,14,14,13,14,15,14,14,8,15,14,14,15,15,14,13,14,13,14,13,14,15,0,0,14,14,14,14,14,14,14,13,13,13,13,14,14,13,13,14,14,14,14,14,14,13,14,14,13,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,13,14,14,13,0,0,15,15,8,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,8,14,15,15,15,8,15,15,8,15,14,15,14,15,15,15,15,15,15,15,15,0,0,0,0,15,15,15,15,15,15,15,0,0,14,0,0,0,0,0,0,0,15,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,14,15,14,14,15,14,1,14,14,14,14,14,14,15,14,14,14,14,14,13,14,13,13,13,13,13,13,12,13,13,13,13,13,13,13,13,13,13,14,13,13,13,13,13,13,14,13,15,15,15,14,1,14,15,14,15,14,14,14,14,14,14,14,15,15,0,15,15,15,0,14,0,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,0,15,14,14,14,14,14,14,13,14,13,13,13,0,0,0,0,0,15,8,15,0,14,13,13,13,12,14,13,13,14,13,14,14,13,14,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,13,0,0,15,14,15,14,14,15,14,14,8,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,15,14,15,14,8,14,15,8,15,15,15,0,0,0,0,15,15,15,15,15,14,0,15,14,0,0,0,0,0,0,0,0,15,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,14,15,14,14,14,14,14,13,14,15,14,14,0,14,14,14,13,14,13,13,13,13,13,13,13,13,13,13,13,13,13,12,13,13,13,13,13,13,13,14,13,14,15,0,15,15,0,0,0,15,0,0,15,15,15,15,15,15,15,14,0,0,15,14,14,15,15,0,0,15,15,14,14,14,14,14,14,14,14,14,14,14,13,14,14,15,14,15,0,0,15,14,14,15,14,14,14,13,14,13,13,0,0,0,0,0,0,0,0,0,0,14,13,14,14,15,13,13,14,13,14,14,14,14,14,14,14,13,14,15,15,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,14,14,14,8,0,15,14,15,14,15,14,14,14,14,14,14,14,15,14,14,14,14,14,14,15,14,14,14,14,14,15,14,14,14,15,14,15,14,15,15,15,15,15,15,0,0,0,0,15,15,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,0,15,0,0,0,0,0,15,15,0,14,15,0,14,14,14,14,14,14,14,14,14,14,15,15,15,13,14,14,14,14,14,13,13,13,13,13,13,13,12,13,12,13,13,12,13,13,13,13,14,13,13,14,13,13,14,15,0,0,15,0,15,0,0,15,15,14,14,14,14,15,15,0,15,14,13,14,13,0,14,15,0,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,15,14,15,14,14,14,14,14,14,14,14,13,14,13,14,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,14,13,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,13,14,15,15,15,15,8,14,15,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,14,15,15,0,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,15,15,15,15,15,15,15,14,15,15,15,15,15,15,15,15,15,15,13,0,0,14,14,14,14,13,14,14,14,14,14,1,0,15,14,14,14,15,14,14,13,13,13,13,13,13,13,12,12,13,12,13,13,13,13,14,13,14,14,12,12,13,13,13,14,15,15,15,0,15,15,0,15,15,14,14,14,15,14,15,0,14,14,14,14,14,0,14,14,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,8,14,14,14,14,14,14,14,13,13,7,0,0,0,0,15,0,0,0,0,0,15,0,0,0,0,15,0,14,13,15,14,14,14,14,14,14,14,13,0,0,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,15,14,15,14,15,14,14,14,14,15,15,15,14,15,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,15,15,15,15,0,0,0,0,0,0,15,14,14,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,15,0,15,15,15,15,15,14,14,15,15,15,14,15,15,14,14,14,0,14,15,0,14,14,14,14,14,14,13,14,14,14,0,15,15,14,14,0,14,13,13,13,13,13,13,13,12,13,13,12,12,12,12,11,13,13,14,13,13,13,12,12,12,12,14,15,0,0,15,0,0,15,15,15,15,14,14,14,15,15,15,14,14,14,14,14,0,14,14,14,14,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,13,0,8,14,14,15,14,14,14,14,14,14,14,13,13,14,0,0,0,15,15,0,0,15,14,0,15,0,0,15,0,15,14,15,14,14,14,14,14,0,15,14,14,14,15,15,14,14,13,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,14,14,15,14,15,14,14,15,15,14,14,15,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,8,15,15,15,15,15,15,15,0,0,0,0,15,15,15,14,15,15,0,0,15,0,0,0,0,0,0,0,15,15,14,15,0,15,0,0,15,15,15,15,8,14,15,15,15,14,14,15,15,14,14,14,14,0,0,14,15,14,14,14,15,14,14,15,0,14,15,14,15,0,14,14,13,14,13,13,13,13,13,13,13,13,13,13,13,12,12,13,13,13,13,13,13,13,12,13,15,13,14,0,0,0,15,15,15,15,14,14,14,14,14,15,15,15,14,14,14,15,15,14,13,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,15,14,14,15,14,14,14,14,14,14,14,14,13,14,0,0,0,14,15,0,15,0,15,15,15,0,0,15,15,14,15,14,14,14,14,14,15,15,15,14,14,14,15,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,14,14,14,14,15,15,8,15,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,15,15,15,15,15,14,0,0,15,15,15,15,15,15,15,15,15,15,15,15,15,0,15,15,0,0,15,15,15,15,15,0,0,15,15,15,8,15,1,15,14,15,14,14,15,14,14,14,15,14,14,15,0,14,14,14,14,14,14,14,14,0,0,15,0,15,0,14,14,13,14,14,13,13,13,13,13,13,13,13,12,13,13,13,13,12,13,13,13,13,13,13,13,13,15,15,15,14,14,15,0,15,15,15,15,15,14,14,14,14,15,15,15,14,14,15,15,14,15,14,0,15,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,0,8,14,13,14,14,14,14,14,13,14,13,14,0,0,0,14,15,15,15,15,8,15,15,13,14,13,14,15,14,14,14,14,14,14,15,14,14,15,14,14,14,15,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,15,14,15,14,15,14,14,14,15,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,15,14,15,15,15,15,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,15,15,14,15,15,15,15,15,0,0,15,15,14,15,15,15,15,15,15,14,15,14,15,15,0,0,15,15,14,14,14,14,14,14,14,14,15,0,14,14,15,15,15,15,0,0,15,15,0,15,15,14,14,13,14,14,15,14,13,14,13,14,13,14,13,13,14,13,13,13,13,13,13,13,13,13,14,14,14,14,15,0,14,14,14,0,0,15,15,15,14,14,14,15,14,14,15,15,14,15,15,15,0,15,0,15,0,15,0,15,14,14,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,13,14,15,14,15,15,15,13,14,0,0,0,15,8,0,8,0,15,14,0,8,15,15,15,14,14,14,15,14,15,14,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,14,14,15,14,14,8,15,14,15,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,15,15,0,15,15,0,15,0,0,0,0,15,15,8,14,14,14,14,14,15,14,14,15,15,0,0,14,15,15,15,8,1,8,15,14,14,14,15,14,15,0,14,14,14,15,14,14,14,14,14,15,15,15,0,0,15,15,15,15,15,0,0,15,14,0,15,15,14,14,13,14,15,14,14,15,15,14,15,15,15,13,15,14,14,13,13,13,13,13,13,13,13,14,13,15,14,15,15,15,14,14,2,15,15,14,15,14,14,14,14,14,15,15,15,15,15,15,0,15,14,14,14,14,15,0,15,14,14,14,14,14,13,14,14,14,14,14,14,14,14,13,14,15,0,0,0,14,14,15,15,6,0,0,0,0,15,14,0,15,0,14,15,15,15,15,15,14,14,14,14,14,14,14,14,15,15,15,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,15,15,15,14,15,14,14,14,14,15,14,14,15,14,14,14,14,14,14,15,14,14,14,14,15,14,14,15,15,15,15,0,0,0,0,0,0,0,0,15,15,15,15,15,14,14,14,14,15,14,14,14,14,14,0,0,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,15,14,14,14,15,15,15,15,15,15,15,14,15,0,15,15,15,15,15,0,0,15,15,0,0,0,15,14,15,15,14,0,14,15,14,14,0,0,15,13,15,14,13,13,13,12,13,13,13,13,13,13,14,14,14,14,14,0,15,0,14,14,15,14,15,15,14,14,14,14,14,15,15,15,15,15,15,14,14,14,14,14,14,0,15,14,14,14,13,13,14,13,14,14,14,13,14,14,13,14,15,13,14,14,14,13,14,0,14,13,0,0,0,15,14,15,0,14,0,15,8,0,14,0,15,8,15,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,8,15,15,8,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,0,0,0,0,0,0,0,0,15,0,15,15,14,15,14,14,14,14,15,14,14,14,15,0,0,14,14,14,14,14,15,14,15,14,14,14,14,14,14,15,14,15,15,14,15,15,15,15,14,15,15,15,15,0,0,14,15,0,0,0,0,15,15,0,0,0,0,15,15,0,14,0,15,15,15,15,0,0,0,13,15,14,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,0,14,15,14,14,15,14,14,15,14,15,14,0,15,15,15,15,14,15,14,14,14,14,0,14,14,13,14,13,13,14,13,13,15,14,14,14,14,14,15,13,14,14,14,14,0,0,14,13,15,0,0,15,14,15,0,15,15,14,15,0,15,15,15,15,14,14,14,13,14,14,14,14,14,14,14,14,13,14,14,14,13,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,8,15,0,0,0,15,15,15,15,0,15,15,15,15,15,14,14,15,14,14,14,15,15,15,15,0,0,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,14,14,15,15,15,15,14,14,15,0,0,0,0,15,14,14,15,0,0,0,0,15,0,0,0,0,0,14,0,15,15,15,15,0,0,0,14,0,14,14,13,14,13,13,13,13,13,13,13,12,13,14,13,14,14,14,14,14,14,14,15,14,14,15,14,14,14,15,14,15,15,15,15,15,15,14,14,15,14,15,14,14,14,14,14,13,14,13,14,14,14,14,14,14,13,14,14,14,14,14,15,15,0,15,15,14,13,15,15,15,14,14,15,0,15,0,15,0,15,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,14,15,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,14,14,15,14,15,15,15,15,15,0,15,15,15,15,15,0,15,15,15,14,14,14,14,14,15,0,15,0,0,0,0,0,15,14,14,14,14,15,15,0,0,0,15,14,14,14,8,15,14,15,15,14,0,15,15,15,0,15,0,0,0,0,0,15,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,15,14,0,0,0,14,15,15,13,13,14,14,13,13,13,13,13,12,13,13,13,14,13,14,14,15,15,15,0,15,14,14,0,15,15,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,14,14,13,14,13,13,14,14,14,15,0,15,15,0,0,15,15,14,15,14,14,13,13,15,15,15,14,14,15,0,8,0,13,14,8,15,15,0,15,15,15,14,14,13,14,13,14,14,14,14,13,13,14,14,14,13,14,15,15,14,15,14,15,14,15,15,14,14,14,14,14,14,14,14,14,14,14,15,14,15,14,15,15,15,15,14,14,14,14,14,14,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,0,15,15,15,15,15,15,15,15,0,15,15,8,14,15,14,14,15,0,0,0,0,15,0,0,0,0,15,0,0,0,15,15,0,0,0,0,14,14,15,14,0,14,15,15,15,15,14,0,15,0,14,15,15,15,0,0,0,15,15,0,0,0,15,15,0,0,14,0,15,15,0,15,0,0,15,0,0,0,15,15,14,14,13,13,14,14,13,13,13,13,13,13,13,13,14,13,14,14,14,14,15,14,14,15,14,14,15,14,14,14,15,15,14,15,15,15,15,15,14,15,15,15,15,15,0,14,14,13,14,15,0,0,15,0,15,15,15,14,15,14,14,15,15,0,15,14,13,13,14,14,15,14,14,14,15,15,15,0,15,15,15,15,8,0,0,15,15,14,14,13,14,14,14,14,14,14,14,13,14,14,14,14,14,14,14,15,14,14,15,15,14,15,14,14,14,14,14,14,14,14,14,14,14,15,14,15,15,15,15,15,15,15,14,15,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,14,15,15,15,15,0,0,0,15,15,15,15,15,15,15,15,0,15,15,14,14,14,15,14,14,15,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,14,0,0,14,14,15,14,14,15,15,14,15,15,0,0,0,15,0,15,15,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,14,15,0,14,0,0,15,0,0,0,15,15,13,13,14,13,14,13,13,13,13,13,13,12,12,13,14,14,14,14,14,14,15,14,14,0,14,14,15,15,15,14,15,15,15,15,15,15,15,15,15,15,14,0,15,0,15,0,15,15,14,0,0,15,0,0,0,0,0,0,14,15,15,15,0,15,15,14,13,13,14,14,14,15,14,14,15,15,15,0,14,14,0,15,15,0,0,0,0,15,14,14,14,13,14,14,14,14,14,13,14,14,13,14,14,14,14,14,15,14,15,15,15,15,15,14,14,14,14,14,14,14,14,15,14,15,14,15,8,15,15,15,15,8,14,14,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,14,15,15,15,0,15,0,0,0,0,15,15,15,15,15,15,15,15,15,15,15,15,15,14,14,15,14,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,15,15,15,15,0,15,15,15,15,15,0,0,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,0,0,15,15,0,15,0,0,0,0,0,0,0,14,14,14,13,13,13,14,14,12,13,13,14,14,13,13,13,13,13,2,14,15,15,15,15,14,15,0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,15,14,14,15,13,14,14,15,14,8,14,0,15,15,0,0,8,0,15,0,15,0,0,15,15,14,14,14,14,14,14,14,13,14,14,14,14,14,13,14,14,14,15,14,15,15,8,15,15,15,15,15,14,15,14,15,14,14,14,15,14,15,15,15,14,15,8,15,14,15,14,14,15,14,15,14,15,14,15,14,15,8,15,14,15,0,15,0,15,15,15,15,15,0,0,0,0,15,15,15,0,15,15,0,15,0,15,15,14,15,15,15,15,15,15,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,15,15,15,15,0,0,15,15,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,15,15,0,0,0,0,0,0,0,15,15,14,14,13,14,14,14,13,14,13,13,13,0,0,0,0,0,15,14,15,15,15,15,15,0,0,15,15,15,15,15,15,15,15,15,15,15,8,15,15,0,15,0,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,15,15,14,14,15,15,15,15,14,14,13,14,14,15,14,15,14,0,15,0,0,0,0,15,15,0,15,0,0,0,15,15,14,14,14,14,13,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,14,15,14,15,14,15,14,14,15,14,15,15,15,14,15,14,15,14,15,14,15,14,15,15,8,15,14,15,15,0,0,0,0,0,0,15,0,15,0,0,0,0,0,0,15,15,0,15,0,0,0,0,15,15,15,15,15,8,1,8,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,0,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,15,0,0,0,0,0,15,0,0,0,15,15,14,13,14,14,14,14,14,13,14,13,13,13,13,14,14,15,15,0,0,0,0,0,0,0,15,0,15,15,15,15,15,15,15,0,15,15,15,15,0,0,15,15,15,15,15,15,0,0,0,0,0,0,0,14,0,15,14,14,14,14,15,15,15,14,15,14,13,8,14,15,14,14,15,0,15,15,0,15,0,15,0,0,15,0,0,15,0,15,0,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,14,15,8,15,15,15,14,15,14,15,14,15,15,15,0,0,15,15,15,14,15,15,15,15,0,15,15,15,0,0,0,0,0,0,0,0,0,0,15,0,0,15,0,15,0,0,0,15,15,0,0,0,0,0,0,0,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,0,15,15,15,15,15,15,15,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,0,0,0,0,0,0,0,0,15,0,0,0,0,0,15,0,0,15,14,14,14,14,14,14,14,14,13,14,15,15,14,14,14,14,14,14,15,0,15,0,0,0,0,0,0,0,0,0,15,15,15,15,0,15,15,15,15,0,15,15,8,15,15,0,15,15,0,0,0,14,0,15,0,15,15,15,14,14,14,14,15,14,14,14,14,14,14,15,15,14,14,15,0,15,0,0,0,0,0,0,0,0,0,0,15,0,15,15,0,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,15,15,15,15,0,15,15,15,15,15,15,15,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,15,8,15,15,0,0,0,0,0,15,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,14,14,14,14,14,14,15,0,14,14,14,14,14,15,0,15,0,0,0,0,0,0,0,0,0,15,15,0,15,0,0,15,15,15,15,0,0,15,15,15,15,15,0,15,0,0,0,15,15,0,14,15,15,14,14,14,15,14,15,15,14,14,14,14,14,14,15,14,14,15,15,15,15,0,0,0,0,0,15,0,15,0,0,15,15,15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,8,15,15,15,15,15,15,15,15,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,15,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,15,14,14,14,14,14,14,15,15,0,0,15,14,14,15,15,0,15,0,15,15,0,15,0,0,0,0,0,15,0,15,15,0,0,15,15,15,0,0,15,15,0,15,15,15,0,15,15,0,0,0,15,0,14,15,15,14,14,14,14,14,14,15,14,14,14,14,15,14,14,14,14,15,15,8,15,15,15,15,0,0,15,15,15,15,15,15,15,15,15,14,15,15,14,14,14,14,14,15,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,15,15,15,0,15,0}

logo = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,1,13,1,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,15,13,9,13,9,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,10,10,10,10,10,10,10,10,10,10,13,11,9,11,9,11,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,14,14,14,14,14,14,14,14,15,13,9,13,9,13,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,13,1,13,1,15,15,15,15,15,15,15,15,15,15,15,15,1,13,1,13,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,15,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,15,15,15,15,15,15,15,1,13,1,13,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,14,14,15,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,13,9,13,9,13,15,14,14,14,14,14,14,14,14,14,14,14,14,15,13,9,13,9,13,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,14,14,15,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,15,14,9,9,9,10,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,15,14,9,9,10,10,10,10,10,10,10,10,10,10,10,10,9,9,14,15,1,1,1,1,1,1,1,1,15,14,9,9,10,10,10,10,10,10,10,10,10,10,10,10,9,9,14,15,1,1,1,9,12,9,12,9,12,13,9,9,9,9,9,9,9,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,1,15,14,9,9,9,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,1,1,15,14,9,9,10,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,9,10,9,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,15,14,9,9,10,9,9,9,9,9,9,9,9,9,9,9,9,10,9,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,9,14,14,14,14,14,14,14,14,9,9,10,9,9,14,15,1,1,9,11,9,11,9,11,13,10,10,10,10,10,10,10,10,10,10,10,10,13,11,9,11,9,11,9,1,1,1,15,14,9,9,9,10,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,1,1,15,14,9,9,10,9,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,9,9,14,14,14,14,14,14,9,9,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,9,14,14,14,14,14,14,14,9,9,10,9,9,14,15,1,1,1,15,14,9,10,9,9,9,14,14,14,14,14,14,14,14,9,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,9,12,9,12,9,12,13,9,9,9,9,9,9,10,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,15,14,9,9,10,9,9,9,14,14,14,14,14,9,9,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,9,9,14,14,14,14,14,14,14,9,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,9,14,15,15,15,15,15,15,14,9,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,14,13,9,13,9,13,15,14,14,14,14,14,9,10,9,14,14,14,14,15,13,9,13,9,13,14,1,1,1,15,14,9,9,10,9,9,14,15,15,15,15,15,14,9,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,15,9,9,9,9,14,15,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,14,13,14,13,1,15,15,15,15,14,9,10,9,14,15,15,15,1,13,14,13,14,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,15,9,9,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,15,14,14,14,14,14,15,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,15,14,14,14,14,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,15,15,15,15,1,1,1,1,15,14,9,10,9,9,14,15,15,15,15,15,15,15,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,9,14,14,14,14,14,14,14,14,9,9,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,15,15,15,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,9,9,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,13,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,13,15,1,1,1,1,1,1,1,15,14,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,14,14,14,14,14,14,14,14,14,14,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,15,15,15,15,15,15,15,15,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,15,14,9,9,10,9,14,15,1,1,1,1,1,1,15,14,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,9,14,15,15,15,15,15,14,9,9,10,9,9,14,15,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,13,13,13,15,1,1,1,1,1,1,1,15,14,9,9,10,9,9,14,15,15,15,15,15,15,14,9,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,15,15,15,15,15,15,15,1,13,14,13,14,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,10,9,9,9,14,14,14,14,14,9,9,9,10,9,9,14,15,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,15,14,9,9,10,9,9,9,14,14,14,14,14,14,9,9,9,10,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,14,14,14,14,14,14,14,14,15,13,9,13,9,13,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,10,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,15,14,9,9,9,10,9,9,9,9,9,9,9,9,9,9,10,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,9,9,9,9,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,13,12,11,12,13,13,1,1,1,1,1,1,1,15,14,9,9,9,10,10,10,10,10,10,10,10,10,10,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,10,10,10,10,10,10,10,10,10,10,10,13,11,9,11,9,11,9,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,14,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,9,9,9,9,9,9,9,9,9,9,9,9,13,12,9,12,9,12,9,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,13,12,11,12,13,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,14,14,14,14,14,14,14,14,14,14,14,14,15,13,9,13,9,13,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,14,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,15,15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,15,15,15,15,15,15,15,15,15,15,15,1,13,14,13,14,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}

ores = {
  [1] = {
    name = 'Iron',
    offset = 15000,
    id = 3,
    scale = 0.011,
    min = 15,
    max = 16,
    bmin = 45,
    bmax = 100,
    color_keys = 4,
    tile_id = 162,
    sprite_id = 178,
    biome_id = 2,
    map_cols = {8,11,12,13,14,15},
  },
  [2] = {
    name = 'Copper',
    offset = 10000,
    id = 4,
    scale = 0.013,
    min = 15,
    max = 16,
    bmin = 33,
    bmax = 65,
    color_keys = 1,
    tile_id = 161,
    sprite_id = 177,
    biome_id = 2,
    map_cols = {2,3,4,15},
  },
  [3] = {
    name = 'Coal',
    offset = 50000,
    id = 6,
    scale = 0.020,
    min = 14,
    max = 17,
    bmin = 35,
    bmax = 75,
    color_keys = 4,
    tile_id = 163,
    sprite_id = 179,
    biome_id = 3,
    map_cols = {0,14,15},
  },
  [4] = {
    name = 'Stone',
    offset = 22500,
    id = 5,
    scale = 0.018,
    min = 15,
    max = 16,
    bmin = 20,
    bmax = 70,
    color_keys = 4,
    tile_id = 160,
    sprite_id = 176,
    biome_id = 1,
    map_cols = {12,13,14,15},
  },
  [5] = {
    name = 'Oil Shale',
    offset = 37994,
    id = 8,
    scale = 0.019,
    min = 15,
    max = 16,
    bmin = 22,
    bmax = 29,
    color_keys = 4,
    tile_id = 165,
    sprite_id = 181,
    map_cols = {0,1,15},
  },
  [6] = {
    name = 'Uranium',
    offset = 76500,
    id = 7,
    scale = 0.022,
    min = 15,
    max = 16,
    bmin = 65,
    bmax = 70,
    color_keys = 4,
    tile_id = 164,
    sprite_id = 180,
    map_cols = {5,6,7,15},
  },
}

biomes = {
  [1] = {
    name = 'Desert',
    tile_id_offset = 0,
    min = 20,
    max = 30,
    t_min = 20.5,
    t_max = 21.5,
    tree_id = 194,
    tree_density = 0.05,
    color_key = 0,
    map_col = 5,
    clutter = 0.01
  },
  [2] = {
    name = 'Prarie',
    tile_id_offset = 16,
    min = 30,
    max = 45,
    t_min = 33,
    t_max = 40,
    tree_id = 200,
    tree_density = 0.075,
    color_key = 1,
    map_col = 12,
    clutter = 0.09
  },
  [3] = {
    name = 'Forest',
    tile_id_offset = 32,
    min = 45,
    max = 101,
    t_min = 65,
    t_max = 85,
    tree_id = 197,
    tree_density = 0.15,
    color_key = 1,
    map_col = 14,
    clutter = 0.05
  },
}

--callbacks for placeable items, (belts, inserters, splitters, etc) ex: click/dragging while holding item stack
--main cursor/input function needs to check for ents under cursor FIRST, for quick-depositing held items
--as some placeable items are also accepted as input items in other ents (ex: assembly machines)
--else run callback for held item here, giving mouse coords as parameters

callbacks = {
  ['transport_belt'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return false
      end
      local key = wx .. '-' .. wy
      if not cursor.drag and cursor.l and cursor.ll then
        --drag locking/placing belts
        cursor.drag = true

        cursor.drag_loc = {x = wx, y = wy}
        cursor.drag_dir = cursor.rot
      elseif not cursor.l then
        cursor.drag = false
      end
    
      local dx, dy = world_to_screen(cursor.drag_loc.x, cursor.drag_loc.y)
      local rot, place = cursor.drag_dir, false
      if cursor.drag then
        if (cursor.drag_dir == 0 or cursor.drag_dir == 2) then
          dx, dy, rot, place = x, dy, cursor.drag_dir, true
          --add_belt(x, dy, cursor.drag_dir)
        elseif (cursor.drag_dir == 1 or cursor.drag_dir == 3) then
          dx, dy, rot, place = dx, y, cursor.drag_dir, true
          --add_belt(dx, y, cursor.drag_dir)
        end
      elseif cursor.l and not cursor.ll then
        dx, dy, rot, place = x, y, cursor.rot, true
        --add_belt(x, y, cursor.rot)
      end
      --add belt--
      if place then
        local tile, cell_x, cell_y = get_world_cell(dx, dy)
        local k = cell_x .. '-' .. cell_y
        local belt = {}
        if ENTS[k] and ENTS[k].type ~= 'transport_belt' then
          sound('deny')
          return false
        end

        if not ENTS[k] then
          ENTS[k] = new_belt({x = cell_x, y = cell_y}, rot)
          ENTS[k]:rotate(rot)
          ENTS[k]:update_neighbors()
          sound('place_belt')
          return true
        elseif ENTS[k] and ENTS[k].type == 'transport_belt' and ENTS[k].rot ~= cursor.rot then
          ENTS[k]:rotate(cursor.rot)
          ENTS[k]:update_neighbors()
          sound('rotate_r')
          return false
        end
      end
      return false
    end,
    remove_item = function(x, y)
      local k = get_key(x, y)
      local tile, cell_x, cell_y = get_world_cell(x, y)
      if not ENTS[k] then return end
      if ENTS[k] and ENTS[k].type == 'transport_belt' then
        sound('delete')
        --ENTS[k]:return_all()
        ENTS[k] = nil
      end
      local tiles = {
        [1] = {x = cell_x, y = cell_y - 1},
        [2] = {x = cell_x + 1, y = cell_y},
        [3] = {x = cell_x, y = cell_y + 1},
        [4] = {x = cell_x - 1, y = cell_y}}
      for i = 1, 4 do
        local k = tiles[i].x .. '-' .. tiles[i].y
        if ENTS[k] and ENTS[k].type == 'transport_belt' then
          ENTS[k]:set_curved()
        end
      end
    end,
    draw_item = function(x, y)
      if cursor.drag then
        local sx, sy = world_to_screen(cursor.drag_loc.x, cursor.drag_loc.y)
        if cursor.drag_dir == 0 or cursor.drag_dir == 2 then
          ui.highlight(cursor.tx-2, sy-2, 10, 10, false, 3, 4)
          --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, sy - 1, 0, 1, 0, 0, 2, 2)
        else
          ui.highlight(sx - 2, cursor.ty-2, 10, 10, false, 3, 4)
          --sspr(CURSOR_HIGHLIGHT, sx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
        end
        --arrow to indicate drag direction
        sspr(BELT_ARROW_ID, cursor.tx, cursor.ty, 0, 1, 0, cursor.drag_dir, 1, 1)
      elseif not ENTS[k] or (ENTS[k] and ENTS[k].type == 'transport_belt' and ENTS[k].rot ~= cursor.rot) then
        sspr(BELT_ID_STRAIGHT + BELT_TICK, cursor.tx, cursor.ty, BELT_COLORKEY, 1, 0, cursor.rot, 1, 1)
        ui.highlight(cursor.tx-1, cursor.ty-1, 8, 8, false, 3, 4)
        --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
      else
        ui.highlight(cursor.tx-1, cursor.ty-1, 8, 8, false, 3, 4)
        --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
      end
    end
  },
  ['splitter'] = {
    place_item = function(x, y)
      local child = SPLITTER_ROTATION_MAP[cursor.rot]
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      wx, wy = wx + child.x, wy + child.y
      local tile2, cell_x, cell_y = get_world_cell(x, y)
      local key1 = get_key(x, y)
      local key2 = wx .. '-' .. wy
      if not ENTS[key1] and not ENTS[key2] then
        local splitr = new_splitter(cell_x, cell_y, cursor.rot)
        splitr.other_key = key2
        ENTS[key1] = splitr
        ENTS[key2] = {type = 'dummy_splitter', other_key = key1, rot = cursor.rot}
        ENTS[key1]:set_output()
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
      --add_splitter(x, y)
    end,
    remove_item = function(x, y)
      local k = get_key(x, y)
      if not ENTS[k] then return end
      if ENTS[k].type == 'dummy_splitter' then k = ENTS[k].other_key end
      if ENTS[k] and ENTS[k].type == 'splitter' then
        local key_l, key_r = ENTS[k].output_key_l, ENTS[k].output_key_r
        local key2 = ENTS[k].other_key
        ENTS[k] = nil
        ENTS[key2] = nil
        if ENTS[key_l] and ENTS[key_l].type == 'transport_belt' then ENTS[key_l]:update_neighbors(k) end
        if ENTS[key_r] and ENTS[key_r].type == 'transport_belt' then ENTS[key_r]:update_neighbors(k) end
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local loc = SPLITTER_ROTATION_MAP[cursor.rot]
      local tile, wx, wy = get_world_cell(x, y)
      wx, wy = wx + loc.x, wy + loc.y
      local tile2, cell_x, cell_y = get_world_cell(x, y)
      local sx, sy = get_screen_cell(x, y)
      local key1 = get_key(x, y)
      local key2 = wx .. '-' .. wy
      local x, y, w, h, col1, col2 = sx-1, sy-1, 16, 8, 5, 7
      local ox, oy = 0, 8
      if cursor.rot == 0 or cursor.rot == 2 then
        w, h = h, w
      else
        ox, oy = 8, 0
      end
      if ENTS[key1] or ENTS[key2] then col1, col2 = 2, 2 end
      ui.highlight(x, y, w, h, false, col1, col2)
      sspr(BELT_ID_STRAIGHT + BELT_TICK, sx, sy, -1, 1, 0, cursor.rot)
      sspr(BELT_ID_STRAIGHT + BELT_TICK, sx + ox, sy + oy, -1, 1, 0, cursor.rot)
      sspr(SPLITTER_ID, sx, sy, 0, 1, 0, cursor.rot, 1, 2)
    end
  },
  ['inserter'] = {
    place_item = function(x, y)
      local k = get_key(x, y)
      local tile, cell_x, cell_y = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      if ENTS[k] and ENTS[k].type == 'inserter' then
        if ENTS[k].rot ~= cursor.rot then
          ENTS[k]:rotate(rotation)
          sound('rotate_r')
        end
      elseif not ENTS[k] then
        ENTS[k] = new_inserter({x = cell_x, y = cell_y}, cursor.rot)
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
      --add_inserter(x, y, cursor.rot)
    end,
    remove_item = function(x, y)
      local k = get_key(x, y)
      if not ENTS[k] then return end
      if ENTS[k] and ENTS[k].type == 'inserter' then
        if ENTS[k].held_item_id > 0 then
          if inv:add_item({id = ENTS[k].held_item_id, count = 1}) == true then
            sound('deposit')
            ui.new_alert(cursor.x, cursor.y, '+ ' .. 1 .. ' ' .. ITEMS[ENTS[k].held_item_id].fancy_name, 1000, 0, 6)
          end
        end
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local tile, world_x, world_y = get_world_cell(x, y)
      local temp_inserter = new_inserter({x = world_x, y = world_y}, cursor.rot)
      local k = get_key(x, y)
      temp_inserter:draw()
      if not ENTS[k] or (ENTS[k].type == 'inserter' and ENTS[k].rot ~= cursor.rot) then
        ui.highlight(cursor.tx-1, cursor.ty-1, 8, 8, false, 5, 6)
        --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
      else
        ui.highlight(cursor.tx-1, cursor.ty-1, 8, 8, false, 2, 2)
      end
      --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
    end
  },
  ['power_pole'] = {
    place_item = function(x, y)
      local k = get_key(x,y)
      local tile, cell_x, cell_y = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      if not ENTS[k] then
        ENTS[k] = new_pole({x = cell_x, y = cell_y})
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
      --add_pole(x, y)
    end,
    remove_item = function(x, y)
      local k = get_key(x, y)
      if not ENTS[k] then return end
      if ENTS[k] and ENTS[k].type == 'power_pole' then
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local tile, world_x, world_y = get_world_cell(cursor.tx, cursor.ty)
      local temp_pole = new_pole({x = world_x, y = world_y})
      temp_pole:draw(true)
      --check around cursor to attach temp cables to other poles
    end
  },
  ['mining_drill'] = {
    place_item = function(x, y)
      local k = get_key(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local found_ores = {}
      local field_keys = {}
      --local sx, sy = get_screen_cell(x, y)
      for i = 1, 4 do
        local pos = DRILL_AREA_MAP_BURNER[i]
        local sx, sy = x + (pos.x * 8), y + (pos.y * 8)
        local tile, wx, wy = get_world_cell(sx, sy)
        local k = get_key(sx, sy)
        field_keys[i] = k
        if tile.ore then
          table.insert(found_ores, i)
    
          if not ORES[k] then
            local max_ore = floor(math.random(250,5000))
            local ore = {
              type = ores[tile.ore].name,
              tile_id = ores[tile.ore].tile_id,
              sprite_id = ores[tile.ore].sprite_id,
              id = ores[tile.ore].id,
              total_ore = max_ore,
              ore_remaining = max_ore,
              wx = wx,
              wy = wy,
            }
            ORES[k] = ore
          end
        end
        if ENTS[k] or (i == 4 and #found_ores == 0) then
          sound('deny')
          return false
        end
      end
    
      if not ENTS[k] then
        --local tile, wx, wy = get_world_cell(x, y)
        sound('place_belt')
        --trace('creating drill @ ' .. key)
        ENTS[k] = new_drill({x = wx, y = wy}, cursor.rot, field_keys)
        ENTS[wx + 1 .. '-' .. wy] = {type = 'dummy_drill', other_key = k}
        ENTS[wx + 1 .. '-' .. wy + 1] = {type = 'dummy_drill', other_key = k}
        ENTS[wx .. '-' .. wy + 1] = {type = 'dummy_drill', other_key = k}
        return true
      elseif ENTS[k] and ENTS[k].type == 'mining_drill' then
        sound('place_belt')
        sound('rotate_r')
        --ENTS[k].rot = cursor.rot
      end
      return false
      --add_drill(x, y)
    end,
    remove_item = function(x, y)
      local k = get_key(x, y)
      local _, wx, wy = get_world_cell(x, y)
      local _, wx, wy = get_world_cell(x, y)
      if ENTS[k].type == 'dummy_drill' then
        k = ENTS[k].other_key
      end
      if ENTS[k] then
        --ENTS[k]:return_all()
        local wx, wy = ENTS[k].pos.x, ENTS[k].pos.y
        ENTS[k] = nil
        ENTS[wx + 1 .. '-' .. wy] = nil
        ENTS[wx + 1 .. '-' .. wy + 1] = nil
        ENTS[wx .. '-' .. wy + 1] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local found_ores = {}
      local color_keys = {[1] = {0, 2, 1}, [2] = {0, 2, 1}, [3] = {0, 2, 1}, [4] = {0, 2, 1}}
      for i = 1, 4 do
        local pos = DRILL_AREA_MAP_BURNER[i]
        local sx, sy = x + (pos.x * 8), y + (pos.y * 8)
        local tile, wx, wy = get_world_cell(sx, sy)
        local k = get_key(sx, sy)
        if not tile.ore or ENTS[k] then
          color_keys[i] = {0, 5, 1}
        end
      end
      
      local sx, sy = get_screen_cell(x, y)
      local belt_pos = DRILL_MINI_BELT_MAP[cursor.rot]
      sspr(CURSOR_HIGHLIGHT_CORNER, sx - 1, sy - 1, color_keys[1], 1, 0, 0, 1, 1)
      sspr(CURSOR_HIGHLIGHT_CORNER, sx + 9, sy - 1, color_keys[2], 1, 0, 1, 1, 1)
      sspr(CURSOR_HIGHLIGHT_CORNER, sx + 9, sy + 9, color_keys[3], 1, 0, 2, 1, 1)
      sspr(CURSOR_HIGHLIGHT_CORNER, sx - 1, sy + 9, color_keys[4], 1, 0, 3, 1, 1)
      sspr(DRILL_BIT_ID, sx + 0 + (DRILL_BIT_TICK), sy + 5, 0, 1, 0, 0, 1, 1)
      sspr(DRILL_BURNER_SPRITE_ID, sx, sy, 0, 1, 0, 0, 2, 2)
      sspr(DRILL_MINI_BELT_ID + DRILL_ANIM_TICK, sx + belt_pos.x, sy + belt_pos.y, 0, 1, 0, cursor.rot, 1, 1)
    end
  },
  ['stone_furnace'] = {
    place_item = function(x, y)
      local k = get_key(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local key1 = get_key(x, y)
      local key2 = get_key(x + 8, y)
      local key3 = get_key(x + 8, y + 8)
      local key4 = get_key(x, y + 8)
      if not ENTS[key1] and not ENTS[key2] and not ENTS[key3] and not ENTS[key4] then
        --local wx, wy = screen_to_world(x, y)
        ENTS[key1] = new_furnace(wx, wy, {key2, key3, key4})
        ENTS[key2] = {type = 'dummy_furnace', other_key = key1}
        ENTS[key3] = {type = 'dummy_furnace', other_key = key1}
        ENTS[key4] = {type = 'dummy_furnace', other_key = key1}
        sound('place_belt')
        return true
      end
      sound('deny')
      return false
      --add_furnace(x, y)
    end,
    remove_item = function(x, y)
      local k = get_ent(x, y)
      if ENTS[k] then
        --ENTS[k]:return_all()
        for k, v in ipairs(ENTS[k].dummy_keys) do
          ENTS[v] = nil
        end
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local sx, sy = get_screen_cell(x, y)
      sspr(FURNACE_ID, sx, sy, FURNACE_COLORKEY, 1, 0, 0, 2, 2)
    end
  },
  ['underground_belt'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local k = wx .. '-' .. wy
      if not ENTS[k] then
        local result, other_key, cells = get_ubelt_connection(x, y, cursor.rot)
        --found suitable connection
        --don't create a new ENT, use the found ubelt as the 'host', and update it with US as it's output
        if result then
          ENTS[k] = {
            type = 'underground_belt_exit',
            flip = UBELT_ROT_MAP[cursor.rot].out_flip,
            rot = cursor.rot,
            x = wx, y = wy,
            other_key = other_key,
            is_exit = true,
            item_request = function(self, desired_item, inserter)
              return ENTS[self.other_key]:item_request(desired_item, inserter, true)
            end,
            request_deposit = function(self)
              return ENTS[self.other_key]:request_deposit()
            end,
            deposit = function(self, id, other_rot)
              return ENTS[self.other_key]:deposit(id, other_rot, true)
            end,
          }
          ENTS[other_key]:connect(wx, wy, #cells - 1)
          ENTS[other_key]:update_neighbors_exit()
          sound('place_belt')
        else
          ENTS[k] = new_underground_belt(wx, wy, cursor.rot)
          ENTS[k]:update_neighbors()
        end
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
    end,
    remove_item = function(x, y)
      local k = get_ent(x, y)
      if ENTS[k] and ENTS[k].type == 'underground_belt' then
        --return underground items if any and
        --remove hidden belts, since we removed the head
        ENTS[k]:return_all()

        local exit = false
        local start = {x = ENTS[k].x, y = ENTS[k].y}

        if ENTS[ENTS[k].exit_key] then
          --if we have an exit ubelt
          exit = {x = ENTS[ENTS[k].exit_key].x, y = ENTS[ENTS[k].exit_key].y}
        end
        ENTS[ENTS[k].exit_key] = nil
        ENTS[k] = nil
        
        local function update(x, y)
          local cell_x, cell_y = x, y
          local tiles = {
            [1] = {x = cell_x, y = cell_y - 1},
            [2] = {x = cell_x + 1, y = cell_y},
            [3] = {x = cell_x, y = cell_y + 1},
            [4] = {x = cell_x - 1, y = cell_y}}
          for i = 1, 4 do
            local k = tiles[i].x .. '-' .. tiles[i].y
            if ENTS[k] then
              if ENTS[k].type == 'transport_belt' then ENTS[k]:set_curved() end
              if ENTS[k].type == 'splitter' then ENTS[k]:set_output() end
              if ENTS[k].type == 'dummy_splitter' then ENTS[ENTS[k].other_key]:set_output() end
              if ENTS[k].type == 'underground_belt_exit' then ENTS[ENTS[k].other_key]:set_output() end
              if ENTS[k].type == 'underground_belt' then ENTS[k]:set_output() end
            end
          end
        end

        if exit then update(exit.x, exit.y) end
        update(start.x, start.y)

        sound('delete')
      end
    end,
    draw_item = function(x, y)
      local flip = UBELT_ROT_MAP[cursor.rot].in_flip
      local result, other_key, cells = get_ubelt_connection(cursor.x, cursor.y, cursor.rot)
      -- trace('result: ' .. tostring(result))
      -- trace('other_key: ' .. tostring(other_key))
      -- trace('cells: ' .. tostring(cells))
      if result then
        local sx, sy = cursor.tx, cursor.ty
        ui.highlight(sx - 2, sy - 1, 7, 7, false, 3, 4)
        local c = UBELT_CLIP_OUT[cursor.rot]
        --rect(sx+c.x,sy+c.y,c.w,c.h,2)
        clip(sx+c.x,sy+c.y,c.w,c.h)
        sspr(BELT_ID_STRAIGHT + BELT_TICK, sx, sy, 0, 1, 0, cursor.rot)
        clip()
        sspr(UBELT_OUT, cursor.tx, cursor.ty, ITEMS[18].color_key, 1, UBELT_ROT_MAP[ENTS[other_key].rot].out_flip, cursor.rot)
          --sspr(UBELT_OUT + UBELT_TICK, sx, sy, 0, 1, ent.flip, ent.rot)
        
        --sspr(CURSOR_HIGHLIGHT, sx - 1, sy - 1, 0, 1, 0, 0, 2, 2)
        for i, cell in ipairs(cells) do
          ui.highlight(cell.x - 2, cell.y - 1, 7, 7, false, 3, 4)
          --sspr(CURSOR_HIGHLIGHT, cell.x - 1, cell.y - 1, 0, 1, 0, 0, 2, 2)
        end
      else


        local c = UBELT_CLIP_IN[cursor.rot]
        local sx, sy = cursor.tx, cursor.ty
        rect(sx+c.x,sy+c.y,c.w,c.h,2)
        clip(sx+c.x,sy+c.y,c.w,c.h)
        sspr(BELT_ID_STRAIGHT + BELT_TICK, sx, sy, 0, 1, 0, cursor.rot)
        clip()
        sspr(UBELT_IN, cursor.tx, cursor.ty, ITEMS[18].color_key, 1, flip, cursor.rot)


      end
      ui.highlight(cursor.tx - 2, cursor.ty - 1, 7, 7, false, 3, 4)
      --sspr(CURSOR_HIGHLIGHT, cursor.tx - 1, cursor.ty - 1, 0, 1, 0, 0, 2, 2)
    end
  },
  ['assembly_machine'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local k = wx .. '-' .. wy
      if not ENTS[k] then
        --check 3x3 area for ents
        for i = 0, 2 do
          for j = 0, 2 do
            if ENTS[wx + j .. '-' .. i + wy] then 
              sound('deny')
              return
            end
          end
        end
        --else place dummy ents to reserve 3x3 tile area, and create the crafter
        for i = 0, 2 do
          for j = 0, 2 do
            ENTS[wx + j .. '-' .. i + wy] = {type = 'dummy_assembler', other_key = k}
          end
        end
        ENTS[k] = new_assembly_machine(wx, wy)
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
    end,
    remove_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      local k = wx .. '-' .. wy
      if ENTS[k].other_key then
        k = ENTS[k].other_key
        wx, wy = ENTS[k].x, ENTS[k].y
      end
      if ENTS[k] and ENTS[k].type == 'assembly_machine' then
        --ENTS[k]:return_all()
        for i = 0, 2 do
          for j = 0, 2 do
            ENTS[wx + j .. '-' .. i + wy] = nil
          end
        end
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      sspr(CRAFTER_ID, cursor.tx, cursor.ty, ITEMS[19].color_key, 1, 0, 0, 3, 3)
      sspr(348, cursor.tx + 7 + offset, cursor.ty + 12, 0)
      sspr(348, cursor.tx + 14, cursor.ty + (6 - offset), 0, 1, 0, 3)
    end
  },
  ['research_lab'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local k = wx .. '-' ..wy
      if not ENTS[k] then
        for i = 0, 2 do
          for j = 0, 2 do
            if ENTS[wx + j .. '-' .. i + wy] then 
              sound('deny')
              return false
            end
          end
        end
        --else place dummy ents to reserve 3x3 tile area, and create the crafter
        local dummy_keys = {k}
        for i = 0, 2 do
          for j = 0, 2 do
            local dk = wx + j .. '-' .. i + wy
            ENTS[dk] = {type = 'dummy_lab', other_key = k}
            table.insert(dummy_keys, dk)
          end
        end
        sound('place_belt')
        ENTS[k] = new_lab(wx, wy, dummy_keys)
        return true
      end
      return false
    end,
    remove_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      local k = wx .. '-' .. wy
      if not ENTS[k] then return end
      if ENTS[k].type == 'dummy_lab' then
        k = ENTS[k].other_key
      end
    
      if ui.active_window and ui.active_window.ent_key == k then ui.active_window = nil end
      local keys = ENTS[k].dummy_keys
      for dk, v in ipairs(keys) do
        ENTS[v] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      sspr(LAB_ID, cursor.tx, cursor.ty, ITEMS[22].color_key, 1, 0, 0, 3, 3)
    end
  },
  ['chest'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land then
        sound('deny')
        return
      end
      local k = wx .. '-' .. wy
      if not ENTS[k] then
        ENTS[k] = new_chest(wx, wy, 1)
        sound('place_belt')
        return true
      end
      sound('deny')
      return false
    end,
    remove_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      local k = wx .. '-' .. wy
      if ENTS[k] then
        --ENTS[k]:return_all()
        ENTS[k] = nil
        sound('delete')
        return true
      end
      return false
    end,
    draw_item = function(x, y)
      sspr(CHEST_ID, cursor.tx, cursor.ty, -1)
      ui.highlight(cursor.tx-1, cursor.ty-1, 8, 8, false, 2, 2)
    end
  },
  ['bio_refinery'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land or tile.is_tree then
        sound('deny')
        return false
      end
      local k = wx .. '-' .. wy
      if not ENTS[k] then
        --check 3x3 area for ents
        for i = 0, 2 do
          for j = 0, 2 do
            if ENTS[wx + j .. '-' .. i + wy] then 
              sound('deny')
              return false
            end
          end
        end
        --else place dummy ents to reserve 3x3 tile area, and create the crafter
        local dummy_keys = {}
        for i = 0, 2 do
          for j = 0, 2 do
            if not (i == 0 and j == 0) then
              local dk = wx + j .. '-' .. i + wy
              table.insert(dummy_keys, dk)
              ENTS[dk] = {type = 'dummy_refinery', other_key = k}
            end
          end
        end
        ENTS[k] = new_refinery(wx, wy)
        ENTS[k].dummy_keys = dummy_keys
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
    end,
    remove_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      local k = wx .. '-' .. wy
      if ENTS[k].other_key then
        k = ENTS[k].other_key
        wx, wy = ENTS[k].x, ENTS[k].y
      end
      if ENTS[k] and ENTS[k].type == 'bio_refinery' then
        for k, v in ipairs(ENTS[k].dummy_keys) do
          ENTS[v] = nil
        end
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function(x, y)
      sspr(REFINERY_ID, cursor.tx, cursor.ty, ITEMS[30].color_key, 1, 0, 0, 3, 3)
    end
  },
  ['rocket_silo'] = {
    place_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      if not tile.is_land or tile.is_tree then
        sound('deny')
        return false
      end
      local k = wx .. '-' .. wy
      if not ENTS[k] then
        --check 4x4 area for ents
        for i = 0, 3 do
          for j = 0, 3 do
            if ENTS[wx + j .. '-' .. i + wy] then 
              sound('deny')
              return false
            end
          end
        end
        --else place dummy ents to reserve 4x4 tile area, and create the silo
        local dummy_keys = {}
        for i = 0, 3 do
          for j = 0, 3 do
            if not (i == 0 and j == 0) then
              local dk = wx + j .. '-' .. i + wy
              table.insert(dummy_keys, dk)
              ENTS[dk] = {type = 'dummy_silo', other_key = k}
            end
          end
        end
        ENTS[k] = new_silo(wx, wy)
        ENTS[k].dummy_keys = dummy_keys
        sound('place_belt')
        return true
      else
        sound('deny')
      end
      return false
    end,
    remove_item = function(x, y)
      local tile, wx, wy = get_world_cell(x, y)
      local k = wx .. '-' .. wy
      if ENTS[k].other_key then
        k = ENTS[k].other_key
        wx, wy = ENTS[k].x, ENTS[k].y
      end
      if ENTS[k] and ENTS[k].type == 'rocket_silo' then
        for k, v in ipairs(ENTS[k].dummy_keys) do
          ENTS[v] = nil
        end
        ENTS[k] = nil
        sound('delete')
      end
    end,
    draw_item = function()
      local sx, sy = cursor.tx, cursor.ty
      spr(ROCKET_SILO_ID, sx, sy, 1, 1, 0, 0, 2, 2)
      spr(ROCKET_SILO_ID, sx + 16, sy, 1, 1, 1, 0, 2, 2)
      spr(ROCKET_SILO_ID, sx + 16, sy + 16, 1, 1, 3, 0, 2, 2)
      spr(ROCKET_SILO_ID, sx, sy + 16, 1, 1, 2, 0, 2, 2)
      for y = 0, 1 do
        for x = 0, 1 do
          spr(370, sx + 8 + x*8, sy + 8 + y*8)
        end
      end
    end
  },
}

CRAFT_ANCHOR_ID = 435
CLOSE_ID = 437
CRAFT_ROWS = 6
CRAFT_COLS = 8
UI_CORNER = 352
LOGISTICS_ID = 387
UI_BG = 8
UI_FG = 9
UI_TEXT_BG = 0
UI_TEXT_FG = 4
UI_SHADOW = 0
UI_ARROW = 353
UI_BUTTON = 438
UI_PAUSE = 354
UI_CLOSE = 355
UI_BUTTON2 = 113
UI_PROG_ID = 128
BTN_MAIN = 12
BTN_SHADOW = 2
BTN_HOVER = 11
BTN_PRESS = 4
--TODO: move all main ui windows here
ui = {
  windows = {},
  active_window = false,
  alerts = {}
}

local Panel = {
  x = 0,
  y = 0,
  w = 10,
  h = 10,
  fg = 13,
  bg = 15,
  border = true,
  children = {},
  name = 'UI Test Name',
  vis = true,
  callback = function(self, ...) end,
  lines = {}
}

function box(x, y, w, h, bg, fg)
  rectb(x, y, w, h, fg)
  rect(x + 1, y + 1, w - 2, h - 2, bg)
end

function Panel:draw(parent)
  if self.vis then
    local screen_x, screen_y = self.x, self.y
    if parent then
      screen_x, screen_y = parent.x + self.x, parent.y + self.y
    end
    if self.border then
      rectb(screen_x, screen_y, self.w, self.h, self.fg)
    end
    rect(screen_x + 1, screen_y + 1, self.w - 2, self.h - 2, self.bg)
    --Draw any lines
    if #self.lines > 0 then
      for key, ln in pairs(self.lines) do
        local x1, x2, y1, y2
        if ln.vert then 
          x1, x2 = self.x + ln.pos, self.x + ln.pos
          y1, y2 = self.y, self.y + self.h - 1
        else
          x1, x2 = self.x + 1, self.x + self.w - 2
          y1, y2 = self.y + ln.pos, self.y + ln.pos
        end
        line(x1, y1, x2, y2, ln.col or self.fg)
      end
    end
    --Center the name text
    if self.w == 5 and self.h == 6 then
      --For small buttons/boxes
      print(self.name, screen_x + 1, screen_y, 15, false, 1, true)
    else
      local width = print(self.name, 0, -6, 15, true, 1, true)
      print(self.name, screen_x + (self.w - width)//2, screen_y + 2, 14, false, 1, true)
    end
    if #self.children > 0 then
      for key, child in ipairs(self.children) do
        child.draw(child, self)
      end
    end
  end
end

function Panel:is_hovered(x, y)
  local sx, sy = self.x, self.y
  if self.parent then
    sx, sy = self.x + self.parent.x, self.y + self.parent.y
  end
  return x >= sx and x < sx + self.w and y >= sy and y < sy + self.h and true or false
end

function ui.NewPanel(x, y, w, h, fg, bg, border, children, on_click)
  local new_panel = {
    x = x or Panel.x,
    y = y or Panel.y,
    w = w or Panel.w,
    h = h or Panel.h,
    fg = fg or Panel.fg,
    bg = bg or Panel.bg,
    border = border or Panel.border,
    children = children or Panel.children,
    callback = on_click or Panel.callback,
  }
  if on_click then
    new_panel.click = function(self, ...) self.callback(self, ...) end
  end
  setmetatable(new_panel, {__index = Panel})
  for key, child in pairs(new_panel.children) do
    child.parent = new_panel
  end
  return new_panel
end

function ui.draw_text_window(data, x, y, label, bg, fg, text_bg, text_fg, wrap)
  x, y, label, fg, bg, text_fg, text_bg = x or 2, y or 2, label or false, fg or UI_FG, bg or UI_BG, text_fg or UI_TEXT_FG, text_bg or UI_TEXT_BG
  local w = wrap or 6
  local h = #data * 7 + 4 + (label and 9 or 0)
  local final_data = {}
  for i = 1, #data do
    local string = type(data[i]) == 'table' and data[i].text or data[i]
    local string_width = print(string, 0, -10, 0, false, 1, true)
    if not wrap and string_width + 6 > w then
      w = string_width + 6
      table.insert(final_data, data[i])
    elseif wrap and string_width + 6 > wrap then
      local lines = text_wrap(string, wrap - 6)
      for k, v in ipairs(lines) do
        if type(data[i]) == 'table' then
          table.insert(final_data, {text = tostring(v), bg = data[i].bg, fg = data[i].fg})
        else
          table.insert(final_data, tostring(v))
        end
      end
      h = h + ((#lines - 1)*7)
    else
      if type(data[i]) == 'table' then
        table.insert(final_data, {text = string, bg = data[i].bg, fg = data[i].fg})
      else
        table.insert(final_data, string)
      end
    end
  end
  x = clamp(x, 0, 240 - w - 1)
  y = clamp(y, 0, 136 - h - 1)
  ui.draw_panel(x, y, w, h, bg, fg, label, UI_SHADOW)
  for i = 1, #final_data do
    local bg, fg, text = text_bg, text_fg, final_data[i]
    if type(text) == 'table' then
      bg, fg = final_data[i].bg, final_data[i].fg
      text = final_data[i].text
    end
    prints(text, x + 4, y + ((i-1) * 7) + (label and 10 or 3), bg, fg)
  end
end

function ui.item_box(x, y, w, h, bg, fg)
  local new_box = {
    x = x,
    y = y,
    w = w,
    h = h,
    bg = bg or UI_BG,
    fg = fg or UI_FG,
    update = function (self, parent)
      --self.
    end,
    draw = function (self, x, y, stack)
      box(self.x + x, self.y + y, self.w, self.h, self.bg, self.fg)
      if stack.count ~= 0 and stack.id ~= 0 then
        draw_item_stack(self.x + x + 1, self.y + y + 1, stack, true)
      end
    end,
    click = function (self, x, y, parent, stack)
      local sx, sy = self.x + parent.x, self.y + parent.y
      --have we clicked box?
      if x >= sx and x < sx + self.w and y >= sy and y < sy + self.h then
        if key(64) and stack.id ~= 0 then
          local result, stack2 = inv:add_item(stack)
          if result then
            sound('deposit')
            return {id = 0, count = 0}
          end
          if stack2 then
            sound('deposit')
            return stack2
          end
        end
        --is player holding an item stack?
        if cursor.type == 'item' then
          if cursor.item_stack.id == stack.id then

          end
        elseif cursor.type == 'pointer' then
          if stack.count > 0 then
            if cursor.r then
              set_cursor_item({id = stack.id, count = math.ceil(stack.count/2)})
              return {id = stack.id, count = floor(stack.count/2)}
            else
              set_cursor_item(stack)
              return {id = 0, count = 0}
            end
          end
          
        end
      end
      return false
    end,
  }
  return new_box
end

local CraftPanel = {
  x = 2,
  y = 2,
  grid_x = 1,
  grid_y = 34,
  w = 75,
  h = 91,
  fg = 9,
  bg = 8,
  grid_bg = 8,
  grid_fg = 9,
  dock_x = 62,
  dock_y = 2,
  close_x = 68,
  close_y = 2,
  border = 9,
  vis = false,
  docked = true,
  active_tab = 1,
  current_output = 'player',
  tab = {
    [1] = {
      x = 2,
      y = 10,
      w = 24,
      h = 24,
      spr_id = LOGISTICS_ID,
      slots = {},
    },
    [2] = {
      x = 26,
      y = 10,
      w = 24,
      h = 24,
      spr_id = 390,
      slots = {},
    },
    [3] = {
      x = 50,
      y = 10,
      w = 23,
      h = 24,
      spr_id = 393,
      slots = {},
    }
  }
}

CraftPanel.tab['logistics'] = CraftPanel.tab[0]
CraftPanel.tab['production'] = CraftPanel.tab[1]
CraftPanel.tab['intermediate'] = CraftPanel.tab[2]
--CraftPanel.tab['combat'] = CraftPanel.tab[3]

function ui.draw_panel(x, y, w, h, bg, fg, label, shadow)
  x, y = clamp(x, 0, (240 - w)), clamp(y, 0, (136 - h))
  bg, fg = bg or UI_BG, fg or UI_FG
  local width = text_width(type(label) == 'table' and label.text or label)
  if width > w + 7 then w = width + 7 end
  rect(x + 2, y + 2, w - 4, h - 4, bg) -- background fill
  if label then
    pal(1, fg)
    pal(8, fg)
    sspr(UI_CORNER, x, y, 0)
    sspr(UI_CORNER, x + w - 8, y, 0, 1, 1)
    pal()
    pal(1, fg)
    pal(8, bg)
    sspr(UI_CORNER, x + w - 8, y + h - 8, 0, 1, 3)
    sspr(UI_CORNER, x, y + h - 8, 0, 1, 2)
    pal()
    rect(x, y + 6, w, 3, fg) -- header lower-fill
    rect(x + 2, y + h - 3, w - 4, 1, fg) -- bottom footer fill
    rect(x + 6, y + 2, w - 12, 4, fg)--header fill
    --rect(x + 2, y + 9, w - 4, h - 12, bg) -- background fill
    if type(label) == 'table' then
      prints(label.text, x + w/2 - width/2, y + 2, label.bg, label.fg) -- header text
    else
      prints(label, x + w/2 - width/2, y + 2, 0, 4) -- header text
    end
  else
    pal(1, fg)
    sspr(UI_CORNER, x + w - 8, y + h - 8, {0, 8}, 1, 3)
    sspr(UI_CORNER, x, y + h - 8, {0, 8}, 1, 2)
    sspr(UI_CORNER, x, y, {0, 8})
    sspr(UI_CORNER, x + w - 8, y, {0, 8}, 1, 1)
    pal()
  end
  rect(x + 6, y, w - 12, 2, fg) -- top border
  rect(x, y + 6, 2, h - 12, fg) -- left border
  rect(x + w - 2, y + 6, 2, h - 12, fg) -- right border
  rect(x + 6, y + h - 2, w - 12, 2, fg) -- bottom border
  if shadow then
    line(x + 4, y + h, x + w - 3, y + h, shadow) -- shadow
    line(x + w - 2, y + h - 1, x + w, y + h - 3, shadow)-- shadow
    line(x + w, y + 4, x + w, y + h - 4, shadow)-- shadow
  end
end

function ui.draw_grid(x, y, rows, cols, bg, fg, size, border, rounded)
  rounded = true
  border = true
  size = size or 9
  if border then rectb(x,y,cols*size+1,rows*size+1,fg) end
  rect(x + 1, y + 1, (cols * size) - 1, (rows * size)-1, bg)
  for i = 1, cols - 1 do
    local x1 = x + i*size
    line(x1, y + 1, x1, y + (rows*size), fg)
  end
  for i = 1, rows - 1 do
    local y1 = y + i*size
    line(x + 1, y1, x + (cols*size) - 1, y1, fg)
  end
  if rounded then
    for i = 0, rows - 1 do
      for j = 0, cols  - 1 do
        local xx, yy = x + 1 + j*size, y + 1 + i*size
        pix(xx, yy, fg)
        pix(xx + size - 2, yy, fg)
        pix(xx + size - 2, yy + size - 2, fg)
        pix(xx, yy + size - 2, fg)
      end
    end
  end
end

function ui.draw_help_screen()
  ui.draw_panel(0, 0, 240, 136, 8, 9, {text = help[current_help].name, bg = 15, fg = 4})
  if current_help < 3 then
    for k, v in ipairs(help[current_help].info) do
      prints(v[2], 3, 10 + ((k-1) * 7), 15, 4)
      prints(v[1], 150, 10 + ((k-1) * 7), 15, 11, _, true)
    end
  else
    local y = 10
    for k, v in ipairs(help[current_help].info) do
      local lines = text_wrap(v, 232, false)
      for i, line in ipairs(lines) do
        prints(line, 3, y, 15, 4)
        y = y + 8
      end
      y = y + 8
    end
  end
  --page left button
  if ui.draw_button(240 - 20, 1, 1, UI_BUTTON, 2, 8, 3) then
    current_help = clamp(current_help - 1, 1, #help)
    return
  end

  --page right button
  if ui.draw_button(240 - 12, 1, 0, UI_BUTTON, 2, 8, 3) then
    current_help = clamp(current_help + 1, 1, #help)
    return
  end

  if ui.draw_text_button(2, 1, UI_BUTTON2, _, 8, 2, 15, 3, {text = ' Back ', x = 1, y = 1, bg = 15, fg = 4, shadow = {x = 1, y = 0}}) then
    if STATE == 'help' then
      cls()
      STATE = 'start'
      return
    else
      show_help = false
    end
    return
  end

end


function CraftPanel:draw()
  if self.vis == true then
    ui.draw_panel(self.x, self.y, self.w, self.h, 8, 9, 'Crafting', UI_BG)
    local mouse_x, mouse_y = mouse()
    local x, y, w, h, bg, fg = self.x, self.y, self.w, self.h, self.bg, self.fg
    local active_tab, ax, ay, aw, ah = self.active_tab, self.tab[self.active_tab].x, self.tab[self.active_tab].y, 24, 24
    local tw, th = 24, 24
    --rectb(x, y, w, h, self.border)--outer border
    rect(x + 2, y + 32, w - 4, 3, fg)--fill
    rect(x + 2, y + 9, w - 5, 23, bg)--tab background area
    rect(x + ax, y + 9, tw, th, fg)--selected tab background fill
    line(x + 26, y + 9, x + 26, y + 33, fg) --tab dividers
    line(x + 50, y + 9, x + 50, y + 33, fg) --tab dividers
    sspr(UBELT_IN, x + 4, y + self.tab[1].y + 2, 0, 1) --TAB 1
    sspr(SPLITTER_ID_SMALL, x + 15, y + self.tab[1].y + 2, 0, 1) --TAB 1
    sspr(BELT_ID_STRAIGHT, x + 15, y + self.tab[1].y + 12, 0, 1, 0, 1) --TAB 1
    sspr(INSERTER_ARM_ID, x + 4, y + self.tab[1].y + 12, 15, 1, 0, 1) --TAB 1
    sspr(331, x + self.tab[2].x + 14, y + self.tab[2].y + 12, 0)-- TAB 2
    sspr(399, x + self.tab[2].x + 3, y + self.tab[2].y + 12, 0)-- TAB 2
    sspr(316, x + self.tab[2].x + 14, y + self.tab[2].y + 2, 0)-- TAB 2
    sspr(456, x + self.tab[2].x + 3, y + self.tab[2].y + 2, 0)-- TAB 2
    sspr(460, x + self.tab[3].x + 3, y + self.tab[3].y + 12, 0)-- TAb 3
    sspr(482, x + self.tab[3].x + 3, y + self.tab[3].y + 2, 6)-- TAb 3
    sspr(283, x + self.tab[3].x + 14, y + self.tab[3].y + 13, 4)-- TAb 3
    sspr(164, x + self.tab[3].x + 14, y + self.tab[3].y + 2, 4)-- TAb 3
    ui.draw_grid(x + self.grid_x, y + self.grid_y, CRAFT_ROWS, CRAFT_COLS, self.grid_bg, self.grid_fg, 9)
    for i = 1, #self.tab do
      if i ~= self.active_tab then
        local sx, sy, tx, ty, tw, th, fg = self.x, self.y, self.tab[i].x, self.tab[i].y, self.tab[i].w, self.tab[i].h, fg
        if i ~= 1 then
          pix(sx + tx + 1, sy + ty - 1, fg)
          pix(sx + tx + 1, sy + ty + th - 3, fg)
        else
          pix(sx + tx, sy + ty - 1, fg)
          pix(sx + tx, sy + ty + th - 3, fg)
        end
        pix(sx + tx + tw - 1, sy + ty - 1, fg)
        pix(sx + tx + tw - 1, sy + ty + th - 3, fg)
      end
    end
    sspr(CLOSE_ID, x + self.close_x, y + self.close_y, 15)--close button
    sspr(self.docked == true and CRAFT_ANCHOR_ID or CRAFT_ANCHOR_ID + 1, self.x + self.dock_x, self.y + self.dock_y, 15)--anchor button
    --item sprites

    for i = 1, #recipes[self.active_tab] do
      for j = 1, #recipes[self.active_tab][i] do
        local item = ITEMS[recipes[self.active_tab][i][j]]
        if UNLOCKED_ITEMS[recipes[self.active_tab][i][j]] then
          spr(item.sprite_id, self.x + self.grid_x + (j*9) - 9 + 1, self.y + self.grid_y + 1 + (i * 9) - 9, item.color_key)
        end
      end
    end
    pix(x + self.grid_x + 1, y + self.grid_y + 1, self.grid_fg)
    pix(x + self.grid_x + 1, y + self.grid_y + CRAFT_ROWS * 9 - 1, self.grid_fg)
    pix(x + self.grid_x + CRAFT_COLS * 9 - 1, y + self.grid_y + CRAFT_ROWS * 9 - 1, self.grid_fg)
    pix(x + self.grid_x + CRAFT_COLS * 9 - 1, y + self.grid_y + 1, self.grid_fg)

    --Hovered-item recipe widget
    if self:is_hovered(x, y) then
      local result, sl_x, sl_y, slot_index = self:get_hovered_slot(mouse_x, mouse_y)
      if result then
        local row = math.ceil(slot_index / 10)
        local col = ((slot_index - 1) % 10) + 1
        ui.highlight(sl_x - 1, sl_y - 1, 8, 8, false, 3, 4)
        local id = recipes[self.active_tab][row][col]
        if UNLOCKED_ITEMS[id] then
          draw_recipe_widget(mouse_x + 8, mouse_y, recipes[self.active_tab][row][col])
        end
      end
    end

  end
end

function CraftPanel:click(x, y, side)
  if side == 'left' and not cursor.ll then
    local result, sx, sy, index = self:get_hovered_slot(x, y)
    if result and self.current_output ~= 'player' then
      local row = math.ceil(index / 10)
      local col = ((index - 1) % 10) + 1
      if row <= #recipes[self.active_tab] and col <= #recipes[self.active_tab][row] then
        --assembly machine crafting
        if ENTS[self.current_output] then
          local item = ITEMS[recipes[self.active_tab][row][col]]
          if item.craftable == false and item.type ~= 'oil' then sound('deny') return end
          if item.type == 'oil' and ENTS[self.current_output].type == 'bio_refinery' and UNLOCKED_ITEMS[item.id] then
            ENTS[self.current_output]:set_recipe(ITEMS[recipes[self.active_tab][row][col]])
            toggle_crafting()
            ui.active_window = ENTS[self.current_output]:open()
            self.current_output = 'player'
            return true
          elseif item.type ~= 'oil' and ENTS[self.current_output].type ~= 'bio_refinery' and UNLOCKED_ITEMS[item.id] then
            ENTS[self.current_output]:set_recipe(ITEMS[recipes[self.active_tab][row][col]])
            toggle_crafting()
            ui.active_window = ENTS[self.current_output]:open()
            self.current_output = 'player'
            return true
          end
          sound('deny')
          return false
        end
      end
    elseif result and self.current_output == 'player' then
      local row = math.ceil(index / 10)
      local col = ((index - 1) % 10) + 1
      if row <= #recipes[self.active_tab] and col <= #recipes[self.active_tab][row] then
        --player crafting
        local item = ITEMS[recipes[self.active_tab][row][col]]
        if item and item.craftable and UNLOCKED_ITEMS[item.id] then
          local can_craft = true
          for k, v in ipairs(item.recipe.ingredients) do
            if not inv:has_stack(v) then can_craft = false end
          end
          if can_craft then
            for k, v in ipairs(item.recipe.ingredients) do
              inv:remove_stack(v)
              ui.new_alert(cursor.x, cursor.y - 5, '-' .. v.count .. ' ' .. ITEMS[v.id].fancy_name, 1500, 0, 2)
            end
            ui.new_alert(cursor.x, cursor.y, '+' .. item.recipe.count .. ' ' .. item.fancy_name, 1500, 0, 4)
            inv:add_item({id = item.id, count = item.recipe.count})
          end
        end
      end
    end
    --close button
    local cx, cy, w, h = self.x + self.close_x, self.y + self.close_y, 5, 5
    if x >= cx and x < cx + w and y >= cy and y < cy + h then
      self.vis = false
      return true
    end
    --dock button
    local cx, cy, w, h = self.x + self.dock_x, self.y + self.dock_y, 5, 5
    if x >= cx and x < cx + w and y >= cy and y < cy + h then
      self.docked = not self.docked
      return true
    end
    --category tabs
    for i = 1, #self.tab do
      if x >= self.x + self.tab[i].x - 1 and x < self.x + self.tab[i].x + self.tab[i].w and y >= self.y + self.tab[i].y - 1 and y < self.y + self.tab[i].y - 1 + self.tab[i].h then
        self.active_tab = i
        return true
      end
    end
  end
  return false
end

function CraftPanel:is_hovered(x, y)
  if self.vis then
    return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
  end
  return false
end

function CraftPanel:get_hovered_slot(x, y)
  local grid_x, grid_y = self.x + self.grid_x, self.y + self.grid_y
  local start_x = grid_x + 1
  local start_y = grid_y + 1
  
  local rel_x = x - start_x + 1
  local rel_y = y - start_y + 1
  
  local slot_x = math.floor(rel_x / 9)
  local slot_y = math.floor(rel_y / 9)
  
  local slot_pos_x = start_x + slot_x * 9
  local slot_pos_y = start_y + slot_y * 9
  local slot_index = slot_y * 10 + slot_x + 1
  if slot_x >= 0 and slot_x <= CRAFT_COLS - 1 and slot_y >= 0 and slot_y <= CRAFT_ROWS - 1 then
    return true, slot_pos_x, slot_pos_y, slot_index
  else
    return nil
  end
end

function CraftPanel:get_hovered_slot_dyn(x, y)
  local grid_x, grid_y = self.x + self.grid_x, self.y + self.grid_y
  local start_x = grid_x + 1
  local start_y = grid_y + 1
  
  local rel_x = x - start_x + 1
  local rel_y = y - start_y + 1
  
  local slot_x = math.floor(rel_x / 9)
  local slot_y = math.floor(rel_y / 9)
  
  local slot_pos_x = start_x + slot_x * 9
  local slot_pos_y = start_y + slot_y * 9
  local slot_index = slot_y * 10 + slot_x + 1
  if slot_x >= 0 and slot_x < 10 and slot_y >= 0 and slot_y < 10 then
    if self.slots[slot_x .. '-' .. slot_y] then
      self.slots[slot_x .. '-' .. slot_y]:click()
    end
    return true, slot_pos_x, slot_pos_y, slot_index
  else
    return nil
  end
end

function text_width(txt)
  return print(txt, 0, -10, 0, false, 1, true)
end

function text_wrap(text, width, break_word)
  local wrapped_lines = {}
  local function add_line(line)
    table.insert(wrapped_lines, line)
  end
  local function measure(str)
      return text_width(str)
  end
  local function add_word(word, line)
    if measure(line .. " " .. word) > width then
      add_line(line)
      return word
    else
      if line ~= "" then line = line .. " " end
      return line .. word
    end
  end
  local line = ""
  for word in text:gmatch("%S+") do
    if not break_word and measure(word) > width then
      for c in word:gmatch(".") do
        if measure(line .. c) > width then
          add_line(line)
          line = c
        else
          line = line .. c
        end
      end
    else
      line = add_word(word, line)
    end
  end
  if line ~= "" then add_line(line) end
  return wrapped_lines
end

function ui.progress_bar(progress, x, y, w, h, bg, fg, fill, option)
  --Options: 
  --0 - rounded/fancy
  --1 - square with border
  --2 - square no border
  local prog_width = math.min(w-2, math.ceil((w-2)*progress))
  if option == 0 then
    pal({1, fg, 4, bg})
    rect(x + 1, y + 1, w - 2, 4, bg)
    rect(x + 1, y + 1, prog_width, 4, fill)
    sspr(UI_PROG_ID, x, y, 0)
    sspr(UI_PROG_ID, x + w - 8, y, 0, 1, 1)
    line(x + 4, y, x + w - 4, y, fg)
    line(x + 4, y + 5, x + w - 4, y + 5, fg)
    pal()
  elseif option == 1 then
    rectb(x, y, w, h, fg)
    rect(x + 1, y + 1, progress * (w-2), h - 2, fill)
    pix(x + 1, y + 1, fg)
    pix(x + 1, y + h - 2, fg)
    pix(x + w - 2, y + 1, fg)
    pix(x + w - 2, y + h - 2, fg)
    pix(x, y, bg)
    pix(x, y + h - 1, bg)
    pix(x + w - 1, y, bg)
    pix(x + w - 1, y + h - 1, bg)
  elseif option == 2 then
    rectb(x, y+1, w, h-2, fg)
    rectb(x+1, y, w-2, h, fg)
    rect(x + 1, y + 1, w-2, h - 2, bg)
    rect(x + 1, y + 1, progress * (w-2), h - 2, fill)
    pix(x + 1, y + 1, fg)
    pix(x + 1, y + h - 2, fg)
    pix(x + w - 2, y + 1, fg)
    pix(x + w - 2, y + h - 2, fg)
  end
end

function ui.NewCraftPanel(x, y)
  local new_panel = {}
  setmetatable(new_panel, {__index = CraftPanel})
  return new_panel
end

function show_recipe_widget()
  local x, y, id = current_recipe.x, current_recipe.y, current_recipe.id
  local item = ITEMS[id]
  local w, h = math.max(75, text_width(item.fancy_name) + 20), 13
  local start_y = 11
  if item.craftable == false then
    h = h + 8
  end
  if item.recipe then
    h = h + #item.recipe.ingredients*10 + 9
    for k, v in ipairs(item.recipe.ingredients) do
      local width = text_width(ITEMS[v.id].fancy_name) + 18
      if width > w then w = width end
    end
  end
  local lines = false
  if item.info then
    lines = text_wrap(item.info, w - 8, false)
    h = h + #lines*8
  end
  x, y = clamp(x, 1, (240 - w) - 1), clamp(y, 1, (136 - h) - 1)
  ui.draw_panel(x, y, w, h, 8, 9, item.fancy_name, 0)
  if not item.craftable then
    prints('Uncraftable', x + 5, y + start_y, 0, 2)
    start_y = start_y + 8
  end
  if item.recipe then
    for k, v in ipairs(item.recipe.ingredients) do
      prints(ITEMS[v.id].fancy_name, x + 5, y + start_y + 1)
      draw_item_stack(x + w - 11, y + start_y - 1, v, true)
      start_y = start_y + 10
    end
    sspr(CRAFTER_TIME_ID, x + 5, y + start_y, 1)
    prints((item.recipe.crafting_time/60) .. 's', x + 12, y + start_y, 0, 5)
    start_y = start_y + 8
  end
  if item.info then
    for k, v in ipairs(lines) do
      prints(v, x + 5, y + start_y, 0, 11)
      start_y = start_y + 8
    end
  end
end

function draw_recipe_widget(x, y, id)
  current_recipe = {x = x, y = y, id = id}
end

function ui(x, y, stack, show_cnt)
  show_cnt = show_tile_widget or show_cnt or show_count
  sspr(ITEMS[stack.id].sprite_id, x, y, ITEMS[stack.id].color_key)
  if show_cnt then
    local count = stack.count < 100 and stack.count or floor(stack.count/100) .. 'H'
    local sx, sy = x + 9 - text_width(count), y + 4
    prints(count, sx, sy)
  end
end

function draw_recipe_widgetOLD(x, y, id)
  local item = ITEMS[id]
  local w, h = text_width(item.fancy_name) + 4, 19
  local craft_time = (item.recipe and (item.recipe.crafting_time or item.smelting_time)/60 .. 's') or 'Uncraftable'
  local cw = text_width(craft_time)
  if item.info then
    w = math.max(w, 75) + 10
    local text = text_wrap(item.info, math.min(w, w - 6), true)
    h = h + (#text * 7)
  end
  if item.recipe then
    if item.recipe.ingredients then
      for k, v in ipairs(item.recipe.ingredients) do
        local str_w = text_width(ITEMS[v.id].fancy_name .. ' - ' .. v.count)
        if str_w + 12 > w then w = str_w + 12 end
        h = h + 7
      end
    end
    h = h + 7
    local str_w2 = text_width(item.name)
    if str_w2 > w then w = str_w2 + 8 end
    if cw > w then w = cw + 8 end
    local sx, sy = clamp(x, 1, 240 - (w + 2)), clamp(y, 1, 136 - (h+2))
    ui.draw_panel(sx, sy, w, h + 1, 8, 9, item.fancy_name, 0)
    local i = 0
    if item.recipe.ingredients then
      for k, v in ipairs(item.recipe.ingredients) do
        prints(ITEMS[v.id].fancy_name, sx + 3, sy + 10 + (i * 11), 0, 4)
        draw_item_stack(sx + w-13, sy + 10 + ((k-1) * 10), v, true)
        i = i + 1
      end
      local sw = text_width('x ' .. item.recipe.count .. ' -')
      local cw = text_width(craft_time)
      prints('x ' .. item.recipe.count .. ' -', sx + 3, sy + h - 8, 0, 4)
      sspr(CRAFTER_TIME_ID, sx + w - 2 - cw - 10, sy + h - 8, 1)
      prints(craft_time, sx + w - 3 - cw, sy + h - 8, 0, 5)
    end
    if item.info then
      local text = text_wrap(item.info, math.min(w, w - 6), true)
      for k, v in ipairs(text) do
        prints(v, sx + 3, sy + 17 + ((k-1) * 7), 0, 11)
      end
    end
  else
    local w2 = text_width('Uncraftable')
    if w2 + 6 > w then w = w2 + 6 end
    local sx, sy = clamp(x, 1, 240 - w - 2), clamp(y, 1, 136 - h - 2)
    local panel_width = text_width(item.fancy_name)
    ui.draw_panel(sx, sy, w, h, 8, 9, item.fancy_name, 0)
    prints('Uncraftable', sx + 3, sy + 10, 0, 2)
    if item.info then
      local text = text_wrap(item.info, math.min(w, w - 6), true)
      for k, v in ipairs(text) do
        prints(v, sx + 3, sy + 17 + ((k-1) * 7))
      end
    end
  end
end

function draw_tech_widget(x, y, id)
  local t = TECH[id]
  local w, h = print(t.name, 0, -6, 0, false, 1, true) + 8, 55
  local min_width = (#t.science_packs * 9) + 8
  if w < min_width + 8 then w = min_width + 8 end
  local progress = (t.completed and 'Finished') or ('Progress: ' .. floor(100* t.progress/t.science_packs[1].count) .. '%')
  local prog = print(progress, 0, -10, 0, false, 1, true)
  if w < prog + 8 then w = prog + 8 end
  local sx, sy = clamp(x, 1, 240 - w - 2), clamp(y, 1, 136 - h - 2)
  ui.draw_panel(sx, sy, w, h, UI_BG, UI_FG, t.name, 0)
  prints('Cost: ' .. t.science_packs[1].count .. 'x', sx + 4, sy + 10)
  for k, v in ipairs(t.science_packs) do
    sspr(ITEMS[v.id].sprite_id, sx + 4 + ((k-1)*9), sy + 17, ITEMS[v.id].ck)
  end
  prints('Unlocks:', sx + 4, sy + 27)
  for k, v in ipairs(t.item_unlocks) do
    sspr(ITEMS[v].sprite_id, sx + 4 + ((k-1)*9), sy + 34, ITEMS[v].color_key)
  end
  prints(progress, sx + 4, sy + 44)
end

function ui.check_input(c)
  local x, y, l, m, r, sx, sy, lx, ly, ll, lm, lr, lsx, lsy = c.x, c.y, c.l, c.m, c.r, c.sx, c.sy, c.lx, c.ly, c.ll, c.lm, c.lr, c.lsx, c.lsy
  for k, v in pairs(self.windows) do
    if v.vis and v:is_hovered(x, y) then
      return true
    end
  end
  return false
end

function rotatePoint(cx, cy, angle, px, py)
  local s = math.sin(angle)
  local c = math.cos(angle)

  -- translate point back to origin:
  px = px - cx
  py = py - cy

  -- rotate point
  local xnew = px * c - py * s
  local ynew = px * s + py * c

  -- translate point back
  px = xnew + cx
  py = ynew + cy

  return px, py
end

function rectr(x,y,w,h,bg,fg,b)
  --draws a box with 4-interior pixels (rounded look) with or without outer border
  b=false
  local offset = 0
  if b then
    offset=1
    rectb(x,y,w,h,fg)
    rect(x+1,y+1,w-2,h-2,bg)
    pix(x+1,y+1,fg)
    pix(x+w-2,y+1,fg)
    pix(x+w-2,y+h-2,fg)
    pix(x+1,y+h-2,fg)
  else
    rect(x,y,w,h,bg)
    pix(x,y,fg)
    pix(x+w-1,y,fg)
    pix(x+w-1,y+h-1,fg)
    pix(x,y+h-1,fg)
  end
end

function tspr(sprite_id, tile_w, tile_h, sx, sy, ck, width, height, skip)
  if not width then width, height = tile_w*8, tile_h*8 end
  skip = skip or {false, false}
  local spriteX = sprite_id % 16 * 8
  local spriteY = math.floor(sprite_id / 16) * 8
  local spw = tile_w * 8
  local sph = tile_h * 8
  if not skip[1] then
    ttri(
      sx, sy, 
      sx + width, sy, 
      sx, sy + height, 
      spriteX, spriteY, 
      spriteX + spw, spriteY, 
      spriteX, spriteY + sph, 0,
      ck
    )
  end  
  if not skip[2] then
    ttri(
      sx + width, sy, 
      sx, sy + height, 
      sx + width, sy + height, 
      spriteX + spw, spriteY, 
      spriteX, spriteY + sph, 
      spriteX + spw, spriteY + sph, 0,
      ck
    )
  end
end

function rspr(id, x, y, colorkey, sx, sy, flip, rotate, w, h, pivot, skip)
  colorkey = colorkey or -1
  sx = sx or 1
  sy = sy or 1
  flip = flip or 0
  rotate = rotate or 0
  w = w or 1
  h = h or 1
  pivot = pivot or vec2(4, 4)
  skip = skip or {false, false}

  -- Draw a sprite using two textured triangles.
  -- Apply affine transformations: scale, shear, rotate, flip

  -- scale / flip
  if flip % 2 == 1 then
    sx = -sx
  end
  if flip >= 2 then
    sy = -sy
  end
  ox = w * 8 // 2
  oy = h * 8 // 2
  ox = ox * -sx
  oy = oy * -sy

  -- shear / rotate
  shx1 = 0
  shy1 = 0
  shx2 = 0
  shy2 = 0
  shx1 = shx1 * -sx
  shy1 = shy1 * -sy
  shx2 = shx2 * -sx
  shy2 = shy2 * -sy
  rr = math.rad(rotate)
  sa = math.sin(rr)
  ca = math.cos(rr)

  function rot(x, y)
    return x * ca - y * sa, x * sa + y * ca
  end

  rx1, ry1 = rot(ox + shx1, oy + shy1)
  rx2, ry2 = rot(((w * 8) * sx) + ox + shx1, oy + shy2)
  rx3, ry3 = rot(ox + shx2, ((h * 8) * sy) + oy + shy1)
  rx4, ry4 = rot(((w * 8) * sx) + ox + shx2, ((h * 8) * sy) + oy + shy2)
  x1 = x + rx1 - pivot.x
  y1 = y + ry1 - pivot.y
  x2 = x + rx2 - pivot.x
  y2 = y + ry2 - pivot.y
  x3 = x + rx3 - pivot.x
  y3 = y + ry3 - pivot.y
  x4 = x + rx4 - pivot.x
  y4 = y + ry4 - pivot.y

  -- UV coords
  u1 = (id % 16) * 8
  v1 = math.floor(id / 16) * 8
  u2 = u1 + w * 8
  v2 = v1 + h * 8
  if not skip[1] then
    ttri(x1, y1, x2, y2, x3, y3, u1, v1, u2, v1, u1, v2, 0, colorkey)
  end
  if not skip[2] then
    ttri(x3, y3, x4, y4, x2, y2, u1, v2, u2, v2, u2, v1, 0, colorkey)
  end
end

function get_hovered_slot(x, y, grid_x, grid_y, grid_size, rows, cols)
  local start_x = grid_x
  local start_y = grid_y  
  local rel_x = x - start_x
  local rel_y = y - start_y  
  local slot_x = math.floor(rel_x / grid_size)
  local slot_y = math.floor(rel_y / grid_size)  
  local slot_pos_x = start_x + slot_x * grid_size
  local slot_pos_y = start_y + slot_y * grid_size
  local slot_index = slot_y * cols + slot_x + 1
  if slot_x >= 0 and slot_x < cols and slot_y >= 0 and slot_y < rows then
    return {x = slot_pos_x, y = slot_pos_y, index = slot_index}
  else
    return nil
  end
end

function ui.highlight(x, y, w, h, animate, color1, color2)
  pal({1,color1,2,color2})
  local offset = (animate and floor(player.anim_frame/4)) or 0
  sspr(CURSOR_HIGHLIGHT_CORNER_S, x + offset - 1, y - 1 + offset, 0)
  sspr(CURSOR_HIGHLIGHT_CORNER_S, x + (w - 5) - offset, y - 1 + offset, 0, 1, 1, 0)
  sspr(CURSOR_HIGHLIGHT_CORNER_S, x + (w - 5) - offset, y + (h - 5) - offset, 0, 1, 3, 0)
  sspr(CURSOR_HIGHLIGHT_CORNER_S, x + offset - 1, y + (h - 5) - offset, 0, 1, 2, 0)
  pal()
end

function ui.draw_button(x, y, flip, id, color, shadow_color, hover_color)
  color, shadow_color, hover_color = color or 12, shadow_color or 0, hover_color or 11
  local _mouse, _box, ck, p = {x = cursor.x, y = cursor.y}, {x = x, y = y, w = 8, h = 8}, 1, {4, color, 2, shadow_color, 12, color}
  local hov = hovered(_mouse, _box)
  if hov and not cursor.l then
    p = {2, shadow_color, 12, hover_color, 4, hover_color}
  elseif hov and cursor.l then
    p = {2, hover_color, 12, hover_color, 4, hover_color}
    ck = {1, 4}
  end
  pal(p)
  spr(id, x, y, ck, 1, flip)
  pal()
  if hov and cursor.l and not cursor.ll then return true end
  return false
end

function ui.draw_text_button(x, y, id, width, height, main_color, shadow_color, hover_color, label, locked)
  width, height = width or 8, height or 8
  main_color, shadow_color, hover_color = main_color or BTN_MAIN, shadow_color or UI_SHADOW, hover_color or BTN_HOVER
  if label then
    local w = text_width(label.text)
    if w + 2 > width then
      width = w + 2
    end
  end
  local _mouse, _box, ck, p = {x = cursor.x, y = cursor.y}, {x = x, y = y, w = width, h = height}, 1, {BTN_PRESS, main_color, BTN_SHADOW, shadow_color, BTN_MAIN, main_color}
  local hov = not locked and hovered(_mouse, _box)
  if hov and not cursor.l then
    p = {BTN_SHADOW, shadow_color, BTN_MAIN, hover_color, BTN_PRESS, hover_color}
  elseif hov and cursor.l then
    p = {BTN_SHADOW, hover_color, BTN_MAIN, hover_color, BTN_PRESS, hover_color}
    ck = {1, BTN_PRESS}
  end
  local lines = {
    [1] = {x1 =  x, y1 = y + height, x2 =  x + width, y2 = y + height},
    [2] = {x1 =  x, y1 = y, x2 =  x + width, y2 = y}
  }
  if label and width > 8 then
    if not locked and hov and not cursor.l then
      rect(x + 4, y, width - 8, height - 1, hover_color)
      line(x + 4, y + height - 1, x + width - 4, y + height - 1, shadow_color)
    elseif not locked and hov and cursor.l then
      rect(x + 4, y + 1, width - 8, height - 1, hover_color)
      label.y = label.y + 1
    else
      rect(x + 4, y, width - 8, height - 1, main_color)
      line(x + 4, y + height - 1, x + width - 4, y + height - 1, shadow_color)
    end
  end
  pal(p)
  spr(id, x, y, ck, 1, 0)
  spr(id, x + width - 8, y, ck, 1, 1)
  pal()
  if label then
    prints(label.text, x + label.x, y + label.y, label.bg, label.fg, label.shadow)
  end
  if hov and cursor.l and not cursor.ll then return true end
  return false
end

function ui.new_slider(x, y, value, min, max, step, width, height, ditch_color, handle_color, shadow_color)
  local slider = {
    x = x,
    y = y,
    value = value,
    min = min,
    max = max,
    step = step,
    width = width,
    height = height,
    ditch_color = ditch_color or 13,
    handle_color = handle_color or 12,
    shadow_color = shadow_color or 15,
  }
  slider.draw = function(self)
    line(self.x, self.y + 1, self.x + self.width - 1, self.y + 1, self.ditch_color)
    line(self.x + 1, self.y + 2, self.x + self.width - 1, self.y + 2, self.shadow_color)
    local x, y = remap(self.value, self.min, self.max, self.x, self.x + self.width - 1), self.y
    circ(x+1, y+2, 2, self.shadow_color)
    circ(x, y+1, 2, 12)
    local text = self.step >= 1 and floor(self.value) or round(self.value, 2)
    prints(text, self.x + self.width + 15 - (text_width(text)/2), self.y - 1)
  end
  setmetatable(slider, {__index = slider})
  return slider
end

function ui.draw_toggle(x, y, value, size)
  local mx, my = cursor.x, cursor.y
  local hov = hovered({x = mx, y = my}, {x = x, y = y - 1, w = (text_width(value)) + 12, h = 7})
  if value then
    circ(x + 4, y + 2, size, 2)
  end
  circb(x + 4, y + 2, size, 0)  
  return value
end

function draw_tile_widget()
  local x, y = cursor.x, cursor.y
  if show_tech or inv:is_hovered(x, y) or craft_menu:is_hovered(x, y) or (ui.active_window and ui.active_window:is_hovered(x,y)) then
    return
  end
  local sx, sy = get_screen_cell(x, y)
  local tile, wx, wy = get_world_cell(x, y)
  local k = get_key(x, y)
  local tile_type = tile.ore and ores[tile.ore].name .. ' Ore' or tile.is_land and 'Land' or 'Water'
  local biome = tile.is_land and biomes[tile.biome].name or 'Ocean'
  local info = {
    -- [1] = {text = 'Biome: ' .. biome, bg = 0, fg = biomes[tile.biome].map_col},
    [1] = {text = 'Biome: ' .. biome, bg = 0, fg = 10},
    [2] = {text = 'Type: ' .. tile_type, bg = 0, fg = 3},
    [3] = {text = 'Coords: ' .. wx .. ',' .. wy, bg = 0, fg = 11},
    -- [4] = 'Noise: '  .. tile.noise,
    -- [5] = 'Border: ' .. tostring(tile.is_border),
  }
  local resource = resources[tostring(tile.sprite_id)]
  if resource then
    --{id = 5, min =  5, max = 20},
    info[4] = {text = resource.name, bg = 0, fg = 4}
    info[5] = {text = 'Gives ' .. resource.min ..'-' .. resource.max .. ' ' .. ITEMS[resource.id].fancy_name .. ' when harvested', bg = 0, fg = 5}
  end
  if tile.is_tree then
    info[4] = {text = 'Tree', bg = 0, fg = 2}
    info[5] = {text = 'Gives 5-10 Wood Planks when harvested', bg = 0, fg = 5}
    local sx, sy = world_to_screen(wx, wy)
    local c1, c2 = 3, 4
    if tile.biome < 2 then c1, c2 = 2, 3 end
    ui.highlight(sx - 9 + tile.offset.x, sy - 27 + tile.offset.y, 24, 32, false, c1, c2)
  end
  if tile.ore then
    if ORES[k] then
      info[4] = {text = 'Remainig Ore:', bg = 0, fg = 11}
      info[5] = {text = tostring(ORES[k].ore_remaining) .. '/' .. tostring(ORES[k].total_ore), bg = 0, fg = 2}
    end
  end
  ui.draw_text_window(info, x + 8, y + 5, 'Scanning...', 8, 9, 0, 4, 75)
end

function draw_research_icon(id, x, y)
  for k, v in ipairs(TECH[id].sprite) do
    local offset = v.offset or {x=0,y=0}
    local sprite = v
    --rspr(v.id,3+offset.x,12+offset.y,v.rot,v.tw,v.th,v.w,v.h,v.ck,v.page)
    pokey(v.page, v.id, v.tw, v.th, x + offset.x, y + offset.y, v.ck, v.rot)
  end
  if TECH[id].tier then
    rect(x + 19, y + 17, 5, 7, 9)
    prints(TECH[id].tier, x + 20, y + 18, 15, 4, {x = 1, y = 0})
  end
end

function draw_research_screen()
  local AVAILABLE_TECH = AVAILABLE_TECH
  local F_TECH = {}
  for k, v in ipairs(FINISHED_TECH) do
    if v then table.insert(F_TECH, k) end
  end
  local sw = print('Technology Tree',0,-10,0,false,1,true)
  local name = (current_tab and TECH[AVAILABLE_TECH[selected_research]] and TECH[AVAILABLE_TECH[selected_research]].name) or (not current_tab and TECH[F_TECH[selected_research]] and TECH[F_TECH[selected_research]].name or 'Select-a-Tech')
  local rw = print(name,0,-10,0,false,1,true)
  local rsw = print('Research', 0, -10, 0, false, 1, false)/2
  local lpw = 101
  local lph = 57
  local start_x = 69
  -----------MAIN PANEL-------------------
  ui.draw_panel(start_x, 0, 103, 136, UI_FG, UI_FG)
  -------SELECTED TECH HEADER-------------------
  prints(name, start_x + 4 + lpw/2 - rw/2, 1)
  rectr(start_x + 2, 8, lpw - 3, lph - 14, UI_BG, UI_FG, false)
  if ui.draw_button(start_x + 2, lph - 6, current_tab and 0 or 1, UI_BUTTON, 2, 0, 3) then
    current_tab = not current_tab
  end
  if current_tab then
    prints('Available Tech', start_x + 12, lph - 4)
  else
    prints('Known Tech', start_x + 12, lph - 4)
  end
  ----------CURRENT PAGE--------------------------------------------
  local total_current_pages = clamp(math.ceil((current_tab and #AVAILABLE_TECH/12) or #F_TECH/12), 1, 100)
  if ui.draw_button(start_x + (lpw/2) - (rsw/2) + 29, lph - 5, 1, UI_ARROW, 12, 0, 4) then
    current_page = clamp(current_page - 1, 1, total_current_pages)
  end
  if ui.draw_button(start_x + (lpw/2) - (rsw/2) + 56, lph - 5, 0, UI_ARROW, 12, 0, 4) then
    current_page = clamp(current_page + 1, 1, total_current_pages)
  end
  prints(current_page .. '/' .. total_current_pages, start_x + (lpw/2) - (rsw/2) + 41, lph - 4, 0)  
  ----------RESEARCH QUEUE------------------------------
  --removed research queue for now
  --------------TECH TREE------------------------------
  --removed tech tree for now
  ----------------SELECTED TECH PANEL--------------------------
  if current_tab and selected_research then
    --research progress bar
    if not TECH[AVAILABLE_TECH[selected_research]].completed then
      local progress = TECH[AVAILABLE_TECH[selected_research]].progress
      ui.progress_bar(progress, start_x + 29, 10, 69, 5, 0, UI_FG, 6, 2)
    else
      prints('Finished', start_x + 29, 10)
    end    
    --start/pause research button
    if current_research == selected_research then
      if ui.draw_button(start_x + lpw - 11, lph - 15, 0, UI_PAUSE, 12, 0, 4) then
        current_research = false
      end
    elseif current_research ~= selected_research then
      if ui.draw_button(start_x + lpw - 11, lph - 15, 0, UI_ARROW, 12, 0, 4) then
        current_research = selected_research
      end
    end
    local cost_w = print(TECH[AVAILABLE_TECH[selected_research]].science_packs[1].count .. 'x - ', 0, -10, 1, false, 1, true)
    prints(TECH[AVAILABLE_TECH[selected_research]].science_packs[1].count .. 'x -', start_x + 30, 19)
    --available research icons
    --timer sprite & text
    sspr(CRAFTER_TIME_ID, start_x + 30 + cost_w, 18, 1)
    prints(TECH[AVAILABLE_TECH[selected_research]].time .. 's', start_x + 30 + cost_w + 8, 19, 0, 6)
    --item unlocks
    prints('Unlocks:', start_x + 4, 42)
    for k, v in ipairs(TECH[AVAILABLE_TECH[selected_research]].item_unlocks) do
      sspr(ITEMS[v].sprite_id, start_x + 35 + ((k-1)*9), 40, ITEMS[v].color_key)
    end
    --current research icon
    draw_research_icon(AVAILABLE_TECH[selected_research], start_x + 3, 8)
    for k, v in ipairs(TECH[AVAILABLE_TECH[selected_research]].science_packs) do
      sspr(ITEMS[v.id].sprite_id, start_x + 30 + (k-1)*8, 28, ITEMS[v.id].ck)
    end
  end
  
  --------------AVAILABLE or FINISHED TECH GRID PANEL----------------------
  ui.draw_grid(start_x + 1, lph + 2, 3, 4, UI_BG, UI_FG, 25, false)
  local i = 1
  for y = 0, 2 do
    for x = 0, 3 do
      local index = i + ((current_page - 1) * 12)
      local final_index = current_tab and AVAILABLE_TECH[index] or not current_tab and F_TECH[index]
      if final_index then
        draw_research_icon(final_index, start_x + 2+x*25, lph+3+y*25)
        if current_tab and AVAILABLE_TECH[final_index] and final_index == current_research then
          ui.highlight(start_x + x*25, lph + y*25 + 2, 24, 24, true, 3, 4)
        end
      end
      i = i + 1
    end
  end
  --check available research hover
  local slot = get_hovered_slot(cursor.x, cursor.y, start_x + 1, 59, 25, 3, 4)
  if slot then
    local index = false
    if current_tab then
      index = AVAILABLE_TECH[slot.index + ((current_page-1)*12)] or false
    else
      index = F_TECH[slot.index + ((current_page-1)*12)] or false
    end
    ui.highlight(slot.x, slot.y, 24, 24, false, 3, 4)
    if not index then return end
    draw_tech_widget(cursor.x + 5, cursor.y + 5, index)
    if current_tab and cursor.l and not cursor.ll then
      if index then
        selected_research = slot.index + ((current_page-1)*12)
      else
        selected_research = false
      end
      if not current_research then

      elseif current_research ~= slot.index then
        --todo: add to queue
        --removed research queue
      end
    end
    --todo: draw hover widget
  end

  --------MOUSE HOVER/CLICK EVENTS---------------------------
  if selected_research then
    slot = get_hovered_slot(cursor.x, cursor.y, start_x + 34, 39, 9, 1, #TECH[AVAILABLE_TECH[selected_research]].item_unlocks)
    if slot then
      ui.highlight(slot.x, slot.y, 8, 8, false, 3, 4)
      draw_recipe_widget(cursor.x + 5, cursor.y + 5, TECH[AVAILABLE_TECH[selected_research]].item_unlocks[slot.index])
    end
    for k, v in ipairs(TECH[AVAILABLE_TECH[selected_research]].science_packs) do
      if hovered(cursor, {x = start_x + 30 + (k-1)*8, y = 28, w = 8, h = 8}) then
        ui.highlight(start_x + 29 + (k-1)*8, 27, 8, 8, false, 3, 4)
        draw_recipe_widget(cursor.x + 5, cursor.y + 5, v.id)
      end
    end
  end
end

function update_research_progress()
  if not current_research then return false end
  local tech = TECH[AVAILABLE_TECH[current_research]]
  local frac = 1 / tech.science_packs[1].count
  if tech.progress < 1.0 then
    tech.progress = tech.progress + frac
    if tech.progress >= 1.0 then
      sound('tech_done')
      local txt = tech.name .. ' research completed!'
      ui.new_alert(120 - text_width(txt)/2, 68, txt, 2500, 0, 4)
      if tech.callback then tech:callback() end
      tech.completed = true
      for k, v in ipairs(tech.item_unlocks) do
        UNLOCKED_ITEMS[v] = true
      end
      for k, v in ipairs(tech.tech_unlocks) do
        if not FINISHED_TECH[v] and not AVAILABLE_TECH[v] then
          table.insert(AVAILABLE_TECH, v)
        end
      end
      local tid = AVAILABLE_TECH[current_research]
      FINISHED_TECH[AVAILABLE_TECH[current_research]] = true
      table.remove(AVAILABLE_TECH, current_research)
      for k, v in ipairs(TECH) do
        for j, u in ipairs(v.required_tech) do
          if tid == u then
            local n = 0
            for i, m in ipairs(v.required_tech) do
              if FINISHED_TECH[m] then
                n = n + 1
              end
            end
            if n == #v.required_tech and not TECH[k].completed then
              sound('tech_add')
              local txt = '+ ' .. TECH[k].name .. ' research unlocked!'
              ui.new_alert(120 - text_width(txt)/2, 76, txt, 2500, 0, 5)
              table.insert(AVAILABLE_TECH, k)
              break
            end
          end
        end
      end
      return true
    end
  end
  return false
end

function draw_image(x, y, width, height, pixel_data, color_key)
  color_key = color_key or -1
  for i = 0, width - 1 do
    for j = 0, height - 1 do
      local index = j * width + i
      if pixel_data[index] ~= color_key then
        pix(x + i, y + j, pixel_data[index])
      end
    end
  end
end

function draw_logo()
  draw_image(0, 48, 240, 46, logo, 1)
end

function ui.draw_menu()
  if STATE == 'start' then
    draw_logo()
    if ui.draw_text_button(120 - ((text_width('  Start  ') + 2) /2), 100, UI_BUTTON2, _, 8, 9, 15, 10, {text = '  Start  ', x = 1, y = 1, bg = 15, fg = 4, shadow = {x = 1, y = 0}}) then
      STATE = 'game'
      cls(0)
      vbank(0)
    end
    
    --TODO: settings?
    -- if ui.draw_text_button(120 - ((text_width('  Settings  ') + 2) /2), 110, UI_BUTTON2, _, 8, 9, 15, 10, {text = '  Settings  ', x = 1, y = 1, bg = 15, fg = 4, shadow = {x = 1, y = 0}}) then
    --   STATE = 'settings'
    -- end
    
    if ui.draw_text_button(120 - ((text_width('  Controls  ') + 2) /2), 110, UI_BUTTON2, _, 8, 9, 15, 10, {text = '  Controls  ', x = 1, y = 1, bg = 15, fg = 4, shadow = {x = 1, y = 0}}) then
      STATE = 'help'
    end
  elseif STATE == 'help' then
    ui.draw_help_screen()
  end
end

function ui.draw_endgame_window()
  cls(0)
  if tick % 60 > 30 then
    print('Congratulations!', 31, 44, 15, false, 2, false)
    print('Congratulations!', 30, 44, 4, false, 2, false)
    print('You\'ve won the game!', 11, 64, 15, false, 2, false)
    print('You\'ve won the game!', 10, 64, 4, false, 2, false)
  end
  --(x, y, id, width, height, main_color, shadow_color, hover_color, label, locked)
  if ui.draw_text_button(120 - text_width(' Continue ')/2 - 2, 84, 113, 8, 8, 8, 15, 9, {text = ' Continue ', x = 1, y = 1, bg = 0, fg = 4, shadow = {x = 1, y = 0}}) then
    STATE = 'game'
  end
  if ui.draw_text_button(120 - text_width(' Quit ')/2 - 2, 94, 113, 8, 8, 8, 15, 9, {text = ' Quit ', x = 1, y = 1, bg = 0, fg = 2, shadow = {x = 1, y = 0}}) then
    cls()
    exit()
    -- STATE = 'game'
  end
end

function ui.new_alert(sx, sy, text, duration, bg, fg)
  local length = text_width(text)
  local alert = {
    x = clamp(sx, 0, 240 - length),
    y = clamp(sy + #ui.alerts*6, 1, 131),
    text = text,
    duration = duration or 3000,
    bg = bg or UI_TEXT_BG,
    fg = fg or UI_TEXT_FG,
    start = time()
  }
  table.insert(ui.alerts, alert)
end

function ui.update_alerts()
  local trash = {}
  for k, alert in ipairs(ui.alerts) do
    local t = time()
    if t < alert.start + alert.duration then
      local y = alert.y - remap(t, alert.start, alert.start + alert.duration, 0, 20)
      prints(alert.text, alert.x, y, alert.bg, alert.fg)
    else
      table.insert(trash, k)
      alert = nil
    end
  end
  for i = 1, #trash do
    if ui.alerts[trash[i]] then table.remove(ui.alerts, trash[i]) end
  end
end

INVENTORY_SLOT_SIZE = 8
INVENTORY_BG_COL    = 8
INVENTORY_FG_COL    = 9
INVENTORY_GRID_BG   = 8
INVENTORY_GRID_FG   = 9
INVENTORY_SLOT_COL  = 0
INVENTORY_COLS      = 8
INVENTORY_ROWS      = 8
INV_SELECT_TICK     = 0
INV_SELECT_TICKRATE = 10
INV_HOTBAR_OFFSET   = INVENTORY_ROWS * INVENTORY_COLS - INVENTORY_COLS

INVENTORY_WIDTH     = 3 + ((INVENTORY_SLOT_SIZE + 1) * INVENTORY_COLS)
INVENTORY_HEIGHT    = 10 + ((INVENTORY_SLOT_SIZE + 1) * INVENTORY_ROWS)

local inventory = {
  x = (240 / 2) - (INVENTORY_WIDTH/2),
  y = 136 - INVENTORY_HEIGHT - 3,
  w = INVENTORY_WIDTH,
  h = INVENTORY_HEIGHT,
  rows = INVENTORY_ROWS,
  cols = INVENTORY_COLS,
  bg = INVENTORY_BG_COL,
  fg = INVENTORY_FG_COL,
  grid_x = 2,
  grid_y = 9,
  grid_bg = INVENTORY_GRID_BG,
  grid_fg = INVENTORY_GRID_FG,
  slots = {},
  hotbar = {},
  hovered_slot = 0,
  active_slot = 1,
  hotbar_h = INVENTORY_SLOT_SIZE + 4,
  hotbor_w = 4 + ((INVENTORY_SLOT_SIZE + 1) * INVENTORY_COLS),
  hotbar_y = 135 - (INVENTORY_SLOT_SIZE + (INVENTORY_SLOT_SIZE/2)) - 2,
  vis = false,
  hotbar_vis = true,
}

function inventory:draw()
  local x, y = mouse()
  local slot = self:get_hovered_slot(x, y)
  local rows, cols = self.rows - 1, self.cols
  local hx, hy = self.x, self.hotbar_y
  if self.vis and not show_mini_map then
    ui.draw_panel(self.x, self.y, self.w, self.h, self.bg, self.fg, 'Inventory', self.bg)
    ui.draw_grid(self.x + self.grid_x - 1, self.y + self.grid_y - 1, self.rows, self.cols, self.grid_bg, self.grid_fg, INVENTORY_SLOT_SIZE + 1, false)
    for i = 1, INVENTORY_ROWS do
      for j = 1, INVENTORY_COLS do
        local index = ((i-1)*INVENTORY_COLS) + j
        local x, y = self.x + self.grid_x + ((j - 1) * (INVENTORY_SLOT_SIZE + 1)), self.y + self.grid_y + ((i-1) * (INVENTORY_SLOT_SIZE + 1))
        if self.slots[index] and self.slots[index].id ~= 0 then
          local item = ITEMS[self.slots[index].id]
          draw_item_stack(x, y, {id = self.slots[index].id, count = self.slots[index].count})
        end
        if index-56 == self.active_slot then
          ui.highlight(x-1, y-1, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_SIZE, true, 3, 4)
        end
      end
    end
    if slot then
      ui.highlight(slot.x - 1, slot.y - 1, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_SIZE, false, 3, 4)
    end
    local x, y = hx + ((self.active_slot - 1) * (INVENTORY_SLOT_SIZE+1)), hy + offset - 1
     ui.highlight(x, y, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_SIZE, true, 3, 4)
     if cursor.type == 'item' and cursor.item_stack and cursor.item_stack.id ~= 0 and self:is_hovered(cursor.x, cursor.y) then
      draw_item_stack(cursor.x + 5, cursor.y + 5, cursor.item_stack)
    end
  end

  if self.hotbar_vis and not self.vis then
    ui.draw_panel(hx, hy, self.w, INVENTORY_SLOT_SIZE + 4, self.bg, self.fg, false, 8)
    ui.draw_grid(hx + 1, hy + 1, 1, INVENTORY_COLS, self.grid_bg, self.grid_fg, INVENTORY_SLOT_SIZE+1)
    for col = 1, INVENTORY_COLS do
      local x, y = hx + ((col-1) * (INVENTORY_SLOT_SIZE+1)), hy + 4
      if alt_mode then prints(col, x + 5, y - 1, 0, 13) end
      local id, count = self.slots[INV_HOTBAR_OFFSET + col].id, self.slots[INV_HOTBAR_OFFSET + col].count
      if id ~= 0 then
        draw_item_stack(x + 2, hy + 2, {id = id, count = count})
      end
      if col == self.active_slot then
        ui.highlight(x+1, hy+1, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_SIZE, true, 3, 4)
      end
    end
    local xx = (INVENTORY_SLOT_SIZE * INVENTORY_COLS) + INVENTORY_SLOT_SIZE - 2
    pix(self.x + self.grid_x, hy + 1, self.grid_fg)
    pix(self.x + self.grid_x, hy + INVENTORY_SLOT_SIZE, self.grid_fg)
    pix(self.x + self.grid_x + xx, hy + 1, self.grid_fg)
    pix(self.x + self.grid_x + xx, hy + INVENTORY_SLOT_SIZE, self.grid_fg)
    if cursor.type == 'item' and cursor.item_stack and cursor.item_stack.id ~= 0 and self:is_hovered(cursor.x, cursor.y) then
      draw_item_stack(cursor.x + 5, cursor.y + 5, cursor.item_stack)
    end
  end

  if slot and self.slots[slot.index].id ~= 0 then
    if self.vis or (self.hotbar_vis and slot.index >= 57) then
      if key(64) then draw_recipe_widget(cursor.x + 5, cursor.y + 5, self.slots[slot.index].id) end
    end
  end
end

function inventory:draw_hotbar()
  if self.hotbar_vis and not self.vis then
    rectb(self.x, 136 - 2 - (INVENTORY_SLOT_SIZE + 4), self.w, INVENTORY_SLOT_SIZE + 4, INVENTORY_FG_COL)
    rect(self.x + 1, 136 - 2 - (INVENTORY_SLOT_SIZE + 3), self.w - 2, INVENTORY_SLOT_SIZE + 2, INVENTORY_BG_COL)
    for col = 1, INVENTORY_COLS do
      local x, y = (self.x + 2) + ((col - 1) * (INVENTORY_SLOT_SIZE + 1)), 136 - 2 - (INVENTORY_SLOT_SIZE + 2)
      rect(x, y, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_SIZE, INVENTORY_SLOT_COL)
      if col == self.active_slot then
        spr(CURSOR_HIGHLIGHT, x, y, 0)
      end
      if col == 10 then col = 0 end
      print(col, x + 2, y + 1, 0, true, 1, true)
    end
  end
end

function inventory:update()

end

function inventory:add_item(stack, area)
  --self.slots[57 - 64] are hotbar slots 1-8
  area = area or 1
  -- 1st hotbar pass for existing partial stacks, if flag
  if area == 1 or area == 3 then
    for i = 57, #self.slots do
      if stack.id == self.slots[i].id and self.slots[i].count < ITEMS[self.slots[i].id].stack_size then
        local old_count = self.slots[i].count
        self.slots[i].count = self.slots[i].count + stack.count
        if self.slots[i].count > ITEMS[self.slots[i].id].stack_size then
          stack.count = stack.count - (ITEMS[self.slots[i].id].stack_size - old_count)
          self.slots[i].count = ITEMS[self.slots[i].id].stack_size
          -- return self:add_item({id = stack.id, count = stack.count}, 1)
        else
          return true, {id = 0, count = 0}
        end
      end
    end
    --2nd hotbar pass for empty slot
    for i = 57, #self.slots do
      if self.slots[i].id == 0 then
        self.slots[i].id = stack.id
        self.slots[i].count = stack.count
        return true, {id = 0, count = 0}
      end
    end
  end

  --1st pass for existing partial stacks
  for k, v in ipairs(self.slots) do
    if stack.id == v.id and v.count < ITEMS[v.id].stack_size then
      local old_count = v.count
      v.count = v.count + stack.count
      --stack.count = stack.count - (ITEMS[v.id].stack_size - old_count)
      if v.count > ITEMS[v.id].stack_size then
        stack.count = v.count - ITEMS[v.id].stack_size
        v.count = ITEMS[v.id].stack_size
      else
        return true, {id = 0, count = 0}
      end
    end
  end

  --2nd pass for an empty slot
  for k, v in ipairs(self.slots) do
    if v.id == 0 then
      v.id = stack.id
      v.count = stack.count
      return true, {id = 0, count = 0}
    end
  end
  return false, stack
end

function inventory:add_itemNEW(stack, area)
  area = area or 3
  if area == 1 or area == 3 then
    for i = 57, #self.slots do
      if self.slots[i].id == stack.id and self.slots[i].count < ITEMS[self.slots[i].id].stack_size then
        local old_count = self.slots[i].count
        self.slots[i].count = self.slots[i].count + stack.count
        if self.slots[i].count > ITEMS[self.slots[i].id].stack_size then
          self.slots[i].count = ITEMS[self.slots[i].id].stack_size
          stack.count = stack.count - (ITEMS[self.slots[i].id].stack_size - old_count)
          -- return self:add_item({id = stack.id, count = stack.count}, 1)
        end
        return true, {id = 0, count = 0}
      end
      if self.slots[i].id == 0 then
        self.slots[i].id = stack.id
        self.slots[i].count = stack.count
        return true, {id = 0, count = 0}
      end
    end
  end
  for k, v in ipairs(self.slots) do
    if v.id == stack.id and v.count < ITEMS[v.id].stack_size then
      local old_count = v.count
      v.count = v.count + stack.count
      if v.count > ITEMS[v.id].stack_size then
        v.count = ITEMS[v.id].stack_size
        stack.count = stack.count - (ITEMS[v.id].stack_size - old_count)
        return self:add_item(stack)
      end
      return true, {id = 0, count = 0}
    end
    if v.id == 0 then
      v.id = stack.id
      v.count = stack.count
      return true, {id = 0, count = 0}
    end
  end
  return false, stack
end

function inventory:add_itemOLD(stack, area)
  local area = area or 3
  --1st pass, check for same-item
  --check hotbar slots first
  if area == 1 or area == 3 then
    for i = 57, #self.slots do
      local item = ITEMS[self.slots[i].id]
      if stack.count > 0 and self.slots[i].id == stack.id then
        if self.slots[i].count + stack.count <= item.stack_size then
          --deposit stack to existing stack
          self.slots[i].count = self.slots[i].count + stack.count
          return true, {id = 0, count = 0}
        elseif self.slots[i].count < item.stack_size then
          --deposit partial stack
          local diff = item.stack_size - self.slots[i].count
          local remaining_count = stack.count - diff
          self.slots[i].count =  self.slots[i].count + diff
          stack.count = remaining_count
        end
      elseif stack.count > 0 and self.slots[i].id == 0 then
        self.slots[i].id = stack.id
        self.slots[i].count = stack.count
        return true, {id = 0, count = 0}
      end
    end
    if area == 1 then
      return false, stack
    end
  end
  --continue checking inventory, excluding hotbar
  if area == 3 or area == 0 then
    for i = 1, #self.slots - INVENTORY_COLS do
      local item = ITEMS[self.slots[i].id]
      if stack.count > 0 and self.slots[i].id == stack.id then
        if self.slots[i].count + stack.count <= item.stack_size then
          --deposit stack to existing stack
          self.slots[i].count = self.slots[i].count + stack.count
          return true, {id = 0, count = 0}
        elseif self.slots[i].count < item.stack_size then
          --deposit partial stack
          local diff = item.stack_size - self.slots[i].count
          local remaining_count = stack.count - diff
          self.slots[i].count =  self.slots[i].count + diff
          stack.count = remaining_count
        end
      end
    end
  end
  --2nd pass, look for empty slot to deposit remaining (or possibly full) stack
  for k, v in ipairs(self.slots) do
    local item = ITEMS[v.id]
    if stack.count > 0 and v.id == 0 then
      v.id = stack.id
      v.count = stack.count
      return true, {id = 0, count = 0}
    end
  end
  if stack.count > 0 then
    return false, stack
  end
  return false, stack
end

function inventory:remove_item(slot)
  local stack = {id = self.slots[slot].id, count = self.slots[slot].count}
  self.slots[slot].id = 0
  self.slots[slot].count = 0
  return stack
end

function inventory:remove_stack(stack)
  for k, v in ipairs(self.slots) do
    if v.id == stack.id then
      if v.count >= stack.count then
        v.count = v.count - stack.count
        if v.count < 1 then v.id = 0 end
        return true
      else
        stack.count = stack.count - v.count
        v.count = 0
        v.id = 0
      end
    end
  end
  return false


  -- for k, v in ipairs(self.slots) do
  --   if v.id == stack.id and v.count >= stack.count then
  --     v.count = v.count - stack.count
  --     if v.count <= 0 then
  --       v.count = 0
  --       v.id = 0
  --     end
  --     return true
  --   end
  -- end
  -- return false
end

function inventory:slot_clicked(index, button)
  if index == cursor.item_stack.slot then return end
  if cursor.type == 'item' and cursor.item_stack.slot and index ~= cursor.item_stack.slot then
    local old_item = self.slots[index]
    self.slots[cursor.item_stack.slot].id = self.slots[index].id
    self.slots[cursor.item_stack.slot].count = self.slots[index].count
    self.slots[index].id = cursor.item_stack.id
    self.slots[index].count = cursor.item_stack.count
    set_cursor_item()
    return
  end
  if cursor.type == 'item' then
    if self.slots[index].id == 0 then
      --deposit
      self.slots[index].id = cursor.item_stack.id

      if cursor.r then
        self.slots[index].count = 1
        cursor.item_stack.count = cursor.item_stack.count - 1
        if cursor.item_stack.count < 1 then
          set_cursor_item()
        end
      else
        self.slots[index].count = cursor.item_stack.count
        if cursor.item_stack.slot and cursor.item_stack.slot ~= index then
          self.slots[cursor.item_stack.slot].id = 0
          self.slots[cursor.item_stack.slot].count = 0
        end
        set_cursor_item()
      end


    elseif self.slots[index].id == cursor.item_stack.id then
      if cursor.r then
        if self.slots[index].count < ITEMS[self.slots[index].id].stack_size then
          self.slots[index].count = self.slots[index].count + 1
          cursor.item_stack.count = cursor.item_stack.count - 1
          if cursor.item_stack.count < 1 then
            set_cursor_item()
          end
          return true
        end
      end

      local item = ITEMS[self.slots[index].id]
      --swap held partial stack with full stack
      if self.slots[index].count == item.stack_size then
        local stack = {id = self.slots[index].id, count = self.slots[index].count}
        self.slots[index].count = cursor.item_stack.count
        cursor.item_stack = stack
      elseif self.slots[index].count + cursor.item_stack.count <= item.stack_size then
        self.slots[index].count = self.slots[index].count + cursor.item_stack.count
        cursor.item_stack.count = 0
      elseif self.slots[index].count < item.stack_size then
        local diff = item.stack_size - self.slots[index].count
        cursor.item_stack.count = cursor.item_stack.count - diff
        self.slots[index].count = item.stack_size
      end

      if cursor.item_stack.count <= 0 then
        cursor.item_stack = {id = 0, count = 0}
        cursor.type = 'pointer'
      end
    else
      --swap stacks
      local inv_item = {id = self.slots[index].id, count = self.slots[index].count}
      self.slots[index].id = cursor.item_stack.id
      self.slots[index].count = cursor.item_stack.count
      cursor.item_stack = {id = inv_item.id, count = inv_item.count, slot = false}
      cursor.type = 'item'
      cursor.item = ITEMS[inv_item.id].name
    end
  elseif cursor.type == 'pointer' then
    local id, count = self.slots[index].id, self.slots[index].count
    if id ~= 0 then
      if cursor.r and not cursor.lr then
        set_cursor_item({id = id, count = math.ceil(count/2)}, false)
        self.slots[index].count = math.floor(count/2)
        return true
      end
      --try to move to hotbar first
      if index < 57 and key(64) then
        local stack = {id = id, count = count}
        self.slots[index].id = 0
        self.slots[index].count = 0
        local res, stk = self:add_item(stack, 1)
        if res then
          return true
        else
          self.slots[index].id = stk.id
          self.slots[index].count = stk.count
        end
        return true
      end
      cursor.item_stack.id = id
      cursor.item_stack.count = count
      cursor.item_stack.slot = false
      cursor.type = 'item'
      cursor.item = ITEMS[id].name
      self.slots[index].id = 0
      self.slots[index].count = 0
    end
  end
end

function inventory:clicked(x, y)
  if self:is_hovered(x, y) then
    local result = self:get_hovered_slot(x, y)
    if result then
      if key(64) then
        local ent = ui.active_window and ENTS[ui.active_window.ent_key] or false
        if result and ent and self.slots[result.index].id ~= 0 and ui.active_window and ent.deposit_stack then
          local old_stack = {id = self.slots[result.index].id, count = self.slots[result.index].count}
          local deposited, stack = ent:deposit_stack(old_stack, false)
          if deposited then
            ui.new_alert(cursor.x, cursor.y, '-' .. self.slots[result.index].count - stack.count .. ' ' .. ITEMS[old_stack.id].fancy_name, 1000, 0, 2)
            self.slots[result.index].id = stack.id
            self.slots[result.index].count = stack.count
            sound('deposit')
            return true
          end
        end

        if result.index >= 57 and self.slots[result.index].id > 0 then
          local stack = {id = self.slots[result.index].id, count = self.slots[result.index].count}
          self.slots[result.index].id = 0
          self.slots[result.index].count = 0
          local res, stack = self:add_item(stack, 0)
          if stack then
            self.slots[result.index].id = stack.id
            self.slots[result.index].count = stack.count
          end
        end

      end
      self.slots[result.index]:callback()
      
      return true
    end
  end
  return false
end

function inventory:is_hovered(x, y)
  if self.vis then
    return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h
  elseif self.hotbar_vis and not self.vis then
    return x >= self.x and x < self.x + self.w and y >= self.hotbar_y and y < self.hotbar_y + self.hotbar_h
  end
  return false
end

function inventory:get_hovered_slot(x, y)
  local start_x = self.x + self.grid_x
  local start_y = self.y + self.grid_y
  
  local rel_x = x - start_x
  local rel_y = y - start_y
  
  local slot_x = math.floor(rel_x / (INVENTORY_SLOT_SIZE + 1))
  local slot_y = math.floor(rel_y / (INVENTORY_SLOT_SIZE + 1))
  
  local slot_pos_x = start_x + slot_x * (INVENTORY_SLOT_SIZE + 1)
  local slot_pos_y = start_y + slot_y * (INVENTORY_SLOT_SIZE + 1)
  local slot_index = slot_y * INVENTORY_ROWS + slot_x + 1
  if slot_x >= 0 and slot_x < INVENTORY_COLS and slot_y >= 0 and slot_y < INVENTORY_ROWS then
    return {x = slot_pos_x, y = slot_pos_y, index = slot_index}
  else
    return nil
  end
end

function inventory:has_stack(stack)
  local total_items = 0
  for k, v in ipairs(self.slots) do
    if v.id == stack.id then
     total_items = total_items + v.count
     if total_items >= stack.count then
      return true
     end
    end
  end
  return false

  -- for k, v in ipairs(self.slots) do
  --   if v.id == stack.id and v.count >= stack.count then
  --     return true
  --   end
  -- end
  -- return false
end

function new_slot(index)
  local slot = {
    id = 0,
    count = 0,
    index = index,
    callback = function (self)
      inv:slot_clicked(self.index)
    end,
  }
  return slot
end

function make_inventory()
  local inv = {}
  setmetatable(inv, {__index = inventory})
  local i = 1
  for row = 1, INVENTORY_ROWS do
    for col = 1, INVENTORY_COLS do
      inv.slots[i] = new_slot(i)
      i = i + 1
    end
  end
  return inv
end

function add_stack(from, to)
  if to.count == 0 then
    
  elseif to.id == from.id then

  end


  return from, to
end

UBELT_IN           = 278
UBELT_OUT          = 277
UBELT_COLORKEY     = 0
UBELT_TICKRATE     = 5
UBELT_MAXTICK      = 3
UBELT_TICK         = 0

local underground_belt = {
  x = 0, y = 0,
  item_id = 18,
  rot = 0,
  flip = 0,
  lanes = {[1] = {}, [2] = {}},
  screen_pos = {x = 0, y = 0},
  u_lanes = false,
  exit_lanes = false,
  is_exit = false,
  type = 'underground_belt',
  is_hovered = false,
  drawn = false,
  updated = false,
  exit_key = false,
  output_key = false,
  exit_output = false,
  tickrate = 5,
}

UBELT_ROT_MAP = {
  [0] = {in_flip = 0, out_flip = 0, search_dir = {x =  1, y =  0}},
  [1] = {in_flip = 1, out_flip = 1, search_dir = {x =  0, y =  1}},
  [2] = {in_flip = 2, out_flip = 2, search_dir = {x = -1, y =  0}},
  [3] = {in_flip = 0, out_flip = 0, search_dir = {x =  0, y = -1}},
}

UBELT_CLIP_IN = {
  [0] = {x = 6, y = 0, w = 2, h = 8},
  [1] = {x = 0, y = 6, w = 8, h = 2},
  [2] = {x = 0, y = 0, w = 2, h = 8},
  [3] = {x = 0, y = 0, w = 8, h = 2},
}

UBELT_CLIP_OUT = {
  [0] = {x = 0, y = 0, w = 2, h = 8},
  [1] = {x = 0, y = 0, w = 8, h = 2},
  [2] = {x = 6, y = 0, w = 2, h = 8},
  [3] = {x = 0, y = 6, w = 8, h = 2},
}

function underground_belt:draw()
  if self.drawn then return end
  local sx, sy = world_to_screen(self.x, self.y)
  self.screen_pos = {x = sx, y = sy}
  if self.is_exit then
  else
    if self.exit_key and ENTS[self.exit_key] then
      local ent = ENTS[self.exit_key]
      local sx, sy = world_to_screen(ent.x, ent.y)
      if sx >= -7 and sx <= 247 and sy >= -7 and sy <= 143 then
        local c = UBELT_CLIP_OUT[self.rot]
        clip(sx+c.x,sy+c.y,c.w,c.h)
        sspr(BELT_ID_STRAIGHT + BELT_TICK, sx, sy, 0, 1, 0, self.rot)
        clip()
      end
    end
    local c = UBELT_CLIP_IN[self.rot]
    rect(sx+c.x,sy+c.y,c.w,c.h,2)
    clip(sx+c.x,sy+c.y,c.w,c.h)
    sspr(BELT_ID_STRAIGHT + BELT_TICK, sx, sy, 0, 1, 0, self.rot)
    clip()
  end
end

function underground_belt:draw_hover_widget(other)
  local txt = other and 'Underg. Belt Exit' or 'Underground Belt'
  local x, y = cursor.x + 3, cursor.y + 3
  local width = print(txt, 0, -10, 0, false, 1, true)
  local w, h = width + 4, 50
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, txt)
  local c
  if other then
    c = UBELT_CLIP_OUT[self.rot]
  else
    c = UBELT_CLIP_IN[self.rot]
  end
  clip(x + (c.x*3) + w/2 - 12, y + 15+(c.y*3),c.w*3,c.h*3)
  sspr(BELT_ID_STRAIGHT + BELT_TICK, x + w/2 - 12, y + 15, 0, 3, 0, other and ENTS[other].rot or self.rot)
  clip()
  if other then
    sspr(UBELT_OUT, x + w/2 - 12, y + 15, UBELT_COLORKEY, 3, ENTS[other].flip, ENTS[other].rot)
  else
    sspr(UBELT_IN, x + w/2 - 12, y + 15, UBELT_COLORKEY, 3, self.flip, self.rot)
  end  
end

function underground_belt:draw_items()
  --main head unit
  if self.drawn then return end
  self.drawn = true
  local item_locations = BELT_CURVED_ITEM_MAP[self.rot .. self.rot]
  for i = 1, 2 do
    for j = 5, 8 do
      if self.lanes[i][j] > 0 then
        local x, y = item_locations[j][i].x + self.screen_pos.x, item_locations[j][i].y + self.screen_pos.y
        local item = ITEMS[self.lanes[i][j]]
        sspr(item.belt_id, x, y, item.color_key)
      end
    end
  end
  if not self.is_exit then
    local sx, sy = world_to_screen(self.x, self.y)
    sspr(UBELT_IN, sx, sy, 0, 1, self.flip, self.rot)
  end

  --output head
  if self.exit_lanes then
    if ENTS[self.output_key] and (ENTS[self.output_key].type == 'underground_belt' or ENTS[self.output_key].type == 'transport_belt') and
    not ENTS[self.output_key].drawn then
      ENTS[self.output_key]:draw()
      ENTS[self.output_key]:draw_items()
    end
    --trace('try draw exit items')
    local sx, sy = world_to_screen(ENTS[self.exit_key].x, ENTS[self.exit_key].y)
    for i = 1, 2 do
      for j = 1, 2 do
        if self.exit_lanes[i][j] > 0 then
          local x, y = item_locations[j][i].x + sx, item_locations[j][i].y + sy
          local item = ITEMS[self.exit_lanes[i][j]]
          sspr(item.belt_id, x, y, item.color_key)
        end
      end
    end
    sspr(UBELT_OUT, sx, sy, 0, 1, self.flip, self.rot)
  end
end

function underground_belt:update()
  self.updated = true
    --update exit 'belt'
  if self.exit_lanes then
    for i = 1, 2 do
      for j = 1, 8 do
        if j == 1 and self.exit_lanes[i][j] > 0 then
          if self.output_key and ENTS[self.output_key] then
            local ent = ENTS[self.output_key]
            local k = self.output_key
            if ent.type == 'transport_belt' then
              if not ent.updated then ENTS[k]:update() end
              if self.exit_lanes[i][1] ~= 0 then
                ENTS[k].idle = false
                --if i am facing another belt, update that belt first
                if not ent.updated then ENTS[k]:update() end
                --if we find a belt, and the ENTS nearest slot is empty (equals 0) then
                --move item to that belt
                if ent.id == BELT_ID_CURVED and ent.lanes[i][8] == 0 then
                  --add item to other belt
                  ENTS[k].lanes[i][8] = self.exit_lanes[i][1]
                  --remove item from self
                  self.exit_lanes[i][1] = 0
                elseif ent.lanes[self.exit_output[i].a][self.exit_output[i].b] == 0 then
                  ENTS[k].lanes[self.exit_output[i].a][self.exit_output[i].b] = self.exit_lanes[i][1]
                  self.exit_lanes[i][1] = 0
                end
              end
            elseif ent.type == 'underground_belt' or ent.type == 'underground_belt_exit' then
              if ent.type == 'underground_belt_exit' then
                self.output_key = ENTS[key].other_key
                key = self.output_key
              end
              if ENTS[k].lanes[self.exit_output[i].a][self.exit_output[i].b] == 0 then
                ENTS[k].lanes[self.exit_output[i].a][self.exit_output[i].b] = self.exit_lanes[i][j]
                self.exit_lanes[i][j] = 0
              end
            elseif ENTS[k].type == 'splitter' or ENTS[k].type == 'dummy_splitter' then
              --if key is a dummy splitter, then get the parent splitter's key
              if ENTS[k].type == 'dummy_splitter' then
                self.output_key = ENTS[k].exit_key
                k = ENTS[k].exit_key
              end
              if ENTS[k]:input(self.exit_lanes[i][1], i) then
                self.exit_lanes[i][1] = 0
              end
              --if should_shift then ENTS[k].shift = not ENTS[k].shift end
            end
          end
        elseif j > 1 and self.exit_lanes[i][j] > 0 and self.exit_lanes[i][j - 1] == 0 then
          self.exit_lanes[i][j - 1] = self.exit_lanes[i][j]
          self.exit_lanes[i][j] = 0
        end
      end
    end
  end
  --update hidden underground belt
  if self.u_lanes then
    for i = 1, 2 do
      for j = 1, #self.u_lanes[1] do
        if j == 1 and self.exit_lanes and self.u_lanes[i][j] > 0 and self.exit_lanes[i][8] == 0 then
          self.exit_lanes[i][8] = self.u_lanes[i][j]
          self.u_lanes[i][j] = 0
        elseif j > 1 and self.u_lanes[i][j] > 0 and self.u_lanes[i][j - 1] == 0 then
          self.u_lanes[i][j - 1] = self.u_lanes[i][j]
          self.u_lanes[i][j] = 0
        end
      end
    end
  end


  --update entrance 'belt'
  for i = 1, 2 do
    for j = 1, 8 do

      if j == 1 then
        if not self.u_lanes and self.exit_lanes and self.lanes[i][1] ~= 0 and self.exit_lanes[i][8] == 0 then
          self.exit_lanes[i][8] = self.lanes[i][1]
          self.lanes[i][1] = 0
        elseif self.u_lanes and self.lanes[i][1] ~= 0 and self.u_lanes[i][#self.u_lanes[i]] == 0 then
          self.u_lanes[i][#self.u_lanes[i]] = self.lanes[i][1]
          self.lanes[i][1] = 0
        end
      elseif self.lanes[i][j] ~= 0 and self.lanes[i][j - 1] == 0 then
        self.lanes[i][j - 1] = self.lanes[i][j]
        self.lanes[i][j] = 0
      end

    end
  end

end

function underground_belt:connect(world_x, world_y, distance)
  self.exit_lanes = {}
  for i = 1, 2 do
    self.exit_lanes[i] = {}
    for j = 1, 8 do
      self.exit_lanes[i][j] = 0
    end
  end
  
  if distance > 0 then
    self.u_lanes = {}
    for i = 1, 2 do
      self.u_lanes[i] = {}
      for j = 1, distance * 8 do
        self.u_lanes[i][j] = 0
      end
    end
  end

  self.exit_key = world_x .. '-' .. world_y
  local exit = BELT_ROTATION_MAP[self.rot]
  local key = world_x + exit.x .. '-' .. world_y + exit.y
  self.output_key = key
  self:set_output()
end

function underground_belt:set_output()
  if not ENTS[self.exit_key] then return end
  local exit = BELT_ROTATION_MAP[self.rot]
  local k = ENTS[self.exit_key].x + exit.x .. '-' .. ENTS[self.exit_key].y + exit.y
  self.output_key = k

  local ent = ENTS[k]
  if ent then

    if ent.type == 'dummy_splitter' or ent.type == 'underground_belt_exit' then
      self.output_key = ent.other_key
      ent = ENTS[self.output_key]
    end

    if ent.type == 'transport_belt'
    or ent.type == 'splitter' and ENTS[k].rot == self.rot
    or ent.type == 'underground_belt' then

      self.exit_output = BELT_OUTPUT_MAP[self.rot .. ent.rot]

    else
      self.exit_output = nil
    end
  else
    self.exit_output = nil
  end
end

function underground_belt:update_neighbors()
  local cell_x, cell_y = self.x, self.y
  local tiles = {
    [1] = {x = cell_x, y = cell_y - 1},
    [2] = {x = cell_x + 1, y = cell_y},
    [3] = {x = cell_x, y = cell_y + 1},
    [4] = {x = cell_x - 1, y = cell_y}}
  for i = 1, 4 do
    local k = tiles[i].x .. '-' .. tiles[i].y
    if ENTS[k] then
      if ENTS[k].type == 'transport_belt' then ENTS[k]:set_curved() end
      if ENTS[k].type == 'splitter' then ENTS[k]:set_output() end
      if ENTS[k].type == 'dummy_splitter' then ENTS[ENTS[k].other_key]:set_output() end
      if ENTS[k].type == 'underground_belt_exit' then ENTS[ENTS[k].other_key]:set_output() end
      if ENTS[k].type == 'underground_belt' then ENTS[k]:set_output() end
    end
  end
end

function underground_belt:update_neighbors_exit()
  if ENTS[self.exit_key] then
    local cell_x, cell_y = ENTS[self.exit_key].x, ENTS[self.exit_key].y
    local tiles = {
      [1] = {x = cell_x, y = cell_y - 1},
      [2] = {x = cell_x + 1, y = cell_y},
      [3] = {x = cell_x, y = cell_y + 1},
      [4] = {x = cell_x - 1, y = cell_y}
    }
    for i = 1, 4 do
      local k = tiles[i].x .. '-' .. tiles[i].y
      if ENTS[k] then
        if ENTS[k].type == 'transport_belt' then ENTS[k]:set_curved() end
        if ENTS[k].type == 'splitter' then ENTS[k]:set_output() end
        if ENTS[k].type == 'dummy_splitter' then ENTS[ENTS[k].other_key]:set_output() end
        if ENTS[k].type == 'underground_belt_exit' then ENTS[ENTS[k].other_key]:set_output() end
        if ENTS[k].type == 'underground_belt' then ENTS[k]:set_output() end
      end
    end
  end
end

function underground_belt:request_item(keep, lane, slot)
  if not lane and not slot then
    for i = 1, 2 do
      for j = 1, 8 do
        if self.lanes[i][j] ~= 0 then
          local item_id = self.lanes[i][j]
          if not keep then self.lanes[i][j] = 0 end
          return item_id
        end
      end
    end
    return false
  elseif self.lanes[lane][slot] ~= 0 then
    local item_id = self.lanes[lane][slot]
    if not keep then self.lanes[lane][slot] = 0 end
    return item_id
  end
  return false
end

function underground_belt:request_item_exit(keep, lane, slot)
  if not lane and not slot then
    for i = 1, 2 do
      for j = 1, 8 do
        if self.exit_lanes[i][j] ~= 0 then
          local item_id = self.exit_lanes[i][j]
          if not keep then self.exit_lanes[i][j] = 0 end
          return item_id
        end
      end
    end
    return false
  elseif self.exit_lanes[lane][slot] ~= 0 then
    local item_id = self.exit_lanes[lane][slot]
    if not keep then self.exit_lanes[lane][slot] = 0 end
    return item_id
  end
  return false
end

function get_ubelt_connection(x, y, rot)
  local _, wx, wy = get_world_cell(x, y)
  local dir = UBELT_ROT_MAP[rot].search_dir
  local found_key = false
  -- always search going opposite of belt flow
  -- looking for another underground-belt to try connect to first

  --Tier-1 belts can span 4 tiles, 5 being the entrance/exit
  for i = 1, 5 do
    local k = wx + (dir.x * i) .. '-' .. wy + (dir.y * i)
    local ent = ENTS[k]
    if ent and i == 1 and ent.type ==  'underground_belt_exit' and ent.rot == rot then
      return false
    end
    if ent and ent.type == 'underground_belt' then
      if ENTS[k].rot == rot then
        --found another underground_belt, that is facing our same direction
        local cells = {}
        for j = 1, i do
          local sx, sy = world_to_screen(wx + (dir.x * j), wy + (dir.y * j))
          cells[j] = {x = sx, y = sy}
        end
        return true, k, cells
      end
    end
  end

  return false
end

function underground_belt:request_deposit()
  return 'any'
end

function underground_belt:deposit(id, other_rot, is_exit)
  local lane = INSERTER_DEPOSIT_MAP[other_rot][self.rot]
  if is_exit then
    for slot = 8, 1, -1 do
      if self.exit_lanes[lane][slot] == 0 then
        self.exit_lanes[lane][slot] = id
        return true
      end
    end
  else  
    for slot = 8, 1, -1 do
      if self.lanes[lane][slot] == 0 then
        self.lanes[lane][slot] = id
        return true
      end
    end
  end
  return false
end

function underground_belt:item_request(id, is_exit)
  is_exit = is_exit or false
  for i = 1, 2 do
    for j = 8, 1, -1 do
      if is_exit and self.exit_lanes then
        if self.exit_lanes[i][j] > 0 and (self.exit_lanes[i][j] == id or id == 'any' or ITEMS[self.exit_lanes[i][j]].type == id) then
          local item_id = self.exit_lanes[i][j]
          self.exit_lanes[i][j] = 0
          return item_id
        end
      else
        if self.lanes[i][j] > 0 and (self.lanes[i][j] == id or id == 'any' or ITEMS[self.lanes[i][j]].type == id) then
          local item_id = self.lanes[i][j]
          self.lanes[i][j] = 0
          return item_id
        end
      end
    end
  end
  return false
end

function underground_belt:deposit_stack(stack)
  if self.recipe then
    for i = 1, #self.recipe.ingredients do
      local max_stack_per_slot = self.recipe.ingredients[i].count*5
      if self.recipe.ingredients[i].id == stack.id then
        if self.input[i].count + stack.count <= max_stack_per_slot then
          self.input[i].count = self.input[i].count + stack.count
          self.input[i].id = stack.id
          self.state = 'ready'
          return true, {id = 0, count = 0}
        elseif self.input[i].count < max_stack_per_slot and self.input[i].count + stack.count > max_stack_per_slot then
          local diff = max_stack_per_slot - self.input[i].count
          self.input[i].count = max_stack_per_slot
          self.input[i].id = stack.id
          self.state = 'ready'
          return true, {id = stack.id, count = stack.count - diff}
        end
      end
    end
  end
  return false, {id = stack.id, count = stack.count}
end

function underground_belt:return_all()
  local item_stacks = {}
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] > 0 then
        local id = self.lanes[i][j]
        if not item_stacks[id] then item_stacks[id] = 0 end
        item_stacks[id] = item_stacks[id] + 1
        self.lanes[i][j] = 0
      end
    end
  end

  if self.u_lanes then
    for i = 1, 2 do
      for j = 1, #self.u_lanes[1] do
        if self.u_lanes[i][j] > 0 then
          local id = self.u_lanes[i][j]
          if not item_stacks[id] then item_stacks[id] = 0 end
          item_stacks[id] = item_stacks[id] + 1
          self.u_lanes[i][j] = 0
        end
      end
    end
  end

  if self.exit_lanes then
    for i = 1, 2 do
      for j = 1, 8 do
        if self.exit_lanes[i][j] > 0 then
          local id = self.exit_lanes[i][j]
          if not item_stacks[id] then item_stacks[id] = 0 end
          item_stacks[id] = item_stacks[id] + 1
          self.exit_lanes[i][j] = 0
        end
      end
    end
  end

  local offset = 0
  for k, v in pairs(item_stacks) do
    inv:add_item({id = k, count = v})
    ui.new_alert(cursor.x, cursor.y + offset, '+' .. v .. ' ' .. ITEMS[k].fancy_name, 1000, 0, 11)
    offset = offset + 6
  end
end

function new_underground_belt(x, y, rot)
  local new_belt = {x = x, y = y, lanes = {[1] = {0,0,0,0,0,0,0,0}, [2] = {0,0,0,0,0,0,0,0}}, rot = rot, flip = UBELT_ROT_MAP[rot].in_flip}
  setmetatable(new_belt, {__index = underground_belt})
  return new_belt
end

BELT_ID_STRAIGHT  = 256
BELT_ID_CURVED    = 260
BELT_ARROW_ID     = 287
BELT_COLORKEY     = 0
BELT_TICKRATE     = 5
BELT_MAXTICK      = 3
BELT_TICK         = 0

local Belt = {
  pos = {x = 0, y = 0},
  screen_pos = {x = 0, y = 0},
  rot = 0,
  sprite_rot = 0,
  flip = 0,
  lanes = {[1] = {}, [2] = {}},
  id = BELT_ID_STRAIGHT,
  type = 'transport_belt',
  idle = false,
  updated = false,
  belt_drawn = false,
  drawn = false,
  output_key = nil,
  output_item_key = nil,
  output = nil,
  exit = {x = -8, y = 0},
  is_hovered = false,
  index = 0,
  curve_checked = false,
  item_id = 9,
  tickrate = 5,
}

BELT_OUTPUT_MAP = {
  ['00'] = {[1] = {a = 1, b = 8}, [2] = {a = 2, b = 8}},
  ['01'] = {[1] = {a = 1, b = 4}, [2] = {a = 1, b = 6}},
  ['02'] = nil,
  ['03'] = {[1] = {a = 2, b = 6}, [2] = {a = 2, b = 4}},
  ['10'] = {[1] = {a = 2, b = 1}, [2] = {a = 2, b = 4}},
  ['11'] = {[1] = {a = 1, b = 8}, [2] = {a = 2, b = 8}},
  ['12'] = {[1] = {a = 1, b = 5}, [2] = {a = 1, b = 3}},
  ['13'] = nil,
  ['20'] = nil,
  ['21'] = {[1] = {a = 2, b = 4}, [2] = {a = 2, b = 6}},
  ['22'] = {[1] = {a = 1, b = 8}, [2] = {a = 2, b = 8}},
  ['23'] = {[1] = {a = 1, b = 4}, [2] = {a = 1, b = 6}},
  ['30'] = {[1] = {a = 1, b = 1}, [2] = {a = 1, b = 4}},
  ['31'] = nil,
  ['32'] = {[1] = {a = 2, b = 6}, [2] = {a = 2, b = 4}},
  ['33'] = {[1] = {a = 1, b = 8}, [2] = {a = 2, b = 8}}
}

BELT_CURVED_ITEM_MAP = {
  ['01'] = {
    [1] = {[1] = {x =  5, y =  0}, [2] = {x =  1, y =  0}},
    [2] = {[1] = {x =  5, y =  0}, [2] = {x =  1, y =  1}},
    [3] = {[1] = {x =  5, y =  0}, [2] = {x =  1, y =  2}},
    [4] = {[1] = {x =  5, y =  0}, [2] = {x =  2, y =  3}},
    [5] = {[1] = {x =  5, y =  0}, [2] = {x =  3, y =  4}},
    [6] = {[1] = {x =  5, y =  0}, [2] = {x =  4, y =  4}},
    [7] = {[1] = {x =  6, y =  0}, [2] = {x =  5, y =  4}},
    [8] = {[1] = {x =  7, y =  0}, [2] = {x =  7, y =  4}},
  },
  ['00'] = {
    [1] = {[1] = {x =  0, y =  0}, [2] = {x =  0, y =  4}},
    [2] = {[1] = {x =  1, y =  0}, [2] = {x =  1, y =  4}},
    [3] = {[1] = {x =  2, y =  0}, [2] = {x =  2, y =  4}},
    [4] = {[1] = {x =  3, y =  0}, [2] = {x =  3, y =  4}},
    [5] = {[1] = {x =  4, y =  0}, [2] = {x =  4, y =  4}},
    [6] = {[1] = {x =  5, y =  0}, [2] = {x =  5, y =  4}},
    [7] = {[1] = {x =  6, y =  0}, [2] = {x =  6, y =  4}},
    [8] = {[1] = {x =  7, y =  0}, [2] = {x =  7, y =  4}},
  },
  ['03'] = {
    [1] = {[1] = {x =  0, y =  5}, [2] = {x =  4, y =  5}},
    [2] = {[1] = {x =  0, y =  4}, [2] = {x =  4, y =  5}},
    [3] = {[1] = {x =  0, y =  3}, [2] = {x =  4, y =  5}},
    [4] = {[1] = {x =  0, y =  2}, [2] = {x =  4, y =  5}},
    [5] = {[1] = {x =  1, y =  1}, [2] = {x =  5, y =  4}},
    [6] = {[1] = {x =  2, y =  0}, [2] = {x =  5, y =  4}},
    [7] = {[1] = {x =  4, y =  0}, [2] = {x =  6, y =  4}},
    [8] = {[1] = {x =  7, y =  0}, [2] = {x =  7, y =  4}},
  },
  ['10'] = {
    [1] = {[1] = {x =  0, y =  0}, [2] = {x =  0, y =  4}},
    [2] = {[1] = {x =  1, y =  0}, [2] = {x =  0, y =  4}},
    [3] = {[1] = {x =  2, y =  0}, [2] = {x =  1, y =  5}},
    [4] = {[1] = {x =  3, y =  0}, [2] = {x =  1, y =  5}},
    [5] = {[1] = {x =  4, y =  1}, [2] = {x =  1, y =  6}},
    [6] = {[1] = {x =  5, y =  3}, [2] = {x =  1, y =  6}},
    [7] = {[1] = {x =  5, y =  5}, [2] = {x =  1, y =  7}},
    [8] = {[1] = {x =  5, y =  7}, [2] = {x =  1, y =  7}},
  },
  ['11'] = {
    [1] = {[1] = {x =  5, y =  0}, [2] = {x =  1, y =  0}},
    [2] = {[1] = {x =  5, y =  1}, [2] = {x =  1, y =  1}},
    [3] = {[1] = {x =  5, y =  2}, [2] = {x =  1, y =  2}},
    [4] = {[1] = {x =  5, y =  3}, [2] = {x =  1, y =  3}},
    [5] = {[1] = {x =  5, y =  4}, [2] = {x =  1, y =  4}},
    [6] = {[1] = {x =  5, y =  5}, [2] = {x =  1, y =  5}},
    [7] = {[1] = {x =  5, y =  6}, [2] = {x =  1, y =  6}},
    [8] = {[1] = {x =  5, y =  7}, [2] = {x =  1, y =  7}},
  },
  ['12'] = {
    [1] = {[1] = {x =  5, y =  5}, [2] = {x =  5, y =  1}},
    [2] = {[1] = {x =  5, y =  5}, [2] = {x =  4, y =  1}},
    [3] = {[1] = {x =  5, y =  5}, [2] = {x =  3, y =  1}},
    [4] = {[1] = {x =  5, y =  5}, [2] = {x =  2, y =  2}},
    [5] = {[1] = {x =  5, y =  5}, [2] = {x =  1, y =  4}},
    [6] = {[1] = {x =  5, y =  5}, [2] = {x =  1, y =  5}},
    [7] = {[1] = {x =  5, y =  6}, [2] = {x =  1, y =  6}},
    [8] = {[1] = {x =  5, y =  7}, [2] = {x =  1, y =  7}},
  },
  ['21'] = {
    [1] = {[1] = {x =  5, y =  0}, [2] = {x =  1, y =  0}},
    [2] = {[1] = {x =  5, y =  2}, [2] = {x =  1, y =  0}},
    [3] = {[1] = {x =  5, y =  3}, [2] = {x =  0, y =  1}},
    [4] = {[1] = {x =  5, y =  3}, [2] = {x =  0, y =  1}},
    [5] = {[1] = {x =  4, y =  4}, [2] = {x = -1, y =  1}},
    [6] = {[1] = {x =  3, y =  5}, [2] = {x = -1, y =  1}},
    [7] = {[1] = {x =  1, y =  5}, [2] = {x = -2, y =  1}},
    [8] = {[1] = {x =  0, y =  5}, [2] = {x = -2, y =  1}},
  },
  ['22'] = {
    [1] = {[1] = {x =  5, y =  5}, [2] = {x =  5, y =  1}},
    [2] = {[1] = {x =  4, y =  5}, [2] = {x =  4, y =  1}},
    [3] = {[1] = {x =  3, y =  5}, [2] = {x =  3, y =  1}},
    [4] = {[1] = {x =  2, y =  5}, [2] = {x =  2, y =  1}},
    [5] = {[1] = {x =  1, y =  5}, [2] = {x =  1, y =  1}},
    [6] = {[1] = {x =  0, y =  5}, [2] = {x =  0, y =  1}},
    [7] = {[1] = {x = -1, y =  5}, [2] = {x = -1, y =  1}},
    [8] = {[1] = {x = -2, y =  5}, [2] = {x = -2, y =  1}},
  },
  ['23'] = {
    [1] = {[1] = {x =  0, y =  5}, [2] = {x =  4, y =  5}},
    [2] = {[1] = {x =  0, y =  5}, [2] = {x =  4, y =  4}},
    [3] = {[1] = {x =  0, y =  5}, [2] = {x =  4, y =  3}},
    [4] = {[1] = {x =  0, y =  5}, [2] = {x =  3, y =  2}},
    [5] = {[1] = {x =  0, y =  5}, [2] = {x =  2, y =  1}},
    [6] = {[1] = {x =  0, y =  5}, [2] = {x =  0, y =  1}},
    [7] = {[1] = {x = -1, y =  5}, [2] = {x = -1, y =  1}},
    [8] = {[1] = {x = -2, y =  5}, [2] = {x = -2, y =  1}},
  },
  ['30'] = {
    [1] = {[1] = {x =  0, y =  0}, [2] = {x =  0, y =  4}},
    [2] = {[1] = {x =  0, y =  0}, [2] = {x =  1, y =  4}},
    [3] = {[1] = {x =  0, y =  0}, [2] = {x =  2, y =  4}},
    [4] = {[1] = {x =  0, y =  0}, [2] = {x =  3, y =  3}},
    [5] = {[1] = {x =  0, y = -1}, [2] = {x =  4, y =  2}},
    [6] = {[1] = {x =  0, y = -1}, [2] = {x =  4, y =  1}},
    [7] = {[1] = {x =  0, y = -2}, [2] = {x =  4, y = -1}},
    [8] = {[1] = {x =  0, y = -2}, [2] = {x =  4, y = -2}},
  },
  ['33'] = {
    [1] = {[1] = {x =  0, y =  5}, [2] = {x =  4, y =  5}},
    [2] = {[1] = {x =  0, y =  4}, [2] = {x =  4, y =  4}},
    [3] = {[1] = {x =  0, y =  3}, [2] = {x =  4, y =  3}},
    [4] = {[1] = {x =  0, y =  2}, [2] = {x =  4, y =  2}},
    [5] = {[1] = {x =  0, y =  1}, [2] = {x =  4, y =  1}},
    [6] = {[1] = {x =  0, y =  0}, [2] = {x =  4, y =  0}},
    [7] = {[1] = {x =  0, y = -1}, [2] = {x =  4, y = -1}},
    [8] = {[1] = {x =  0, y = -2}, [2] = {x =  4, y = -2}},
  },
  ['32'] = {
    [1] = {[1] = {x =  5, y =  5}, [2] = {x =  5, y =  1}},
    [2] = {[1] = {x =  4, y =  5}, [2] = {x =  5, y =  1}},
    [3] = {[1] = {x =  3, y =  5}, [2] = {x =  5, y =  1}},
    [4] = {[1] = {x =  1, y =  4}, [2] = {x =  4, y =  0}},
    [5] = {[1] = {x =  0, y =  2}, [2] = {x =  4, y =  0}},
    [6] = {[1] = {x =  0, y =  0}, [2] = {x =  4, y = -1}},
    [7] = {[1] = {x =  0, y = -1}, [2] = {x =  4, y = -2}},
    [8] = {[1] = {x =  0, y = -2}, [2] = {x =  4, y = -2}},
  },
}

BELT_ROTATION_MAP = {
  [0] = {x = -1, y =  0},
  [1] = {x =  0, y = -1},
  [2] = {x =  1, y =  0},
  [3] = {x =  0, y =  1},
}
 
BELT_CURVE_MAP = {
  [0] = {
    [1] = {x =  0, y =  1, flip = 0, rot = 1, key = '10', other_rot = 1},
    [2] = {x =  1, y =  0},
    [3] = {x =  0, y = -1, flip = 2, rot = 1, key = '30', other_rot = 3},
  },
  [1] = {
    [1] = {x = -1, y =  0, flip = 0, rot = 2, key = '21', other_rot = 2},
    [2] = {x =  0, y =  1},
    [3] = {x =  1, y =  0, flip = 2, rot = 0, key = '01', other_rot = 0},
  },
  [2] = {
    [1] = {x =  0, y = -1, flip = 0, rot = 3, key = '32', other_rot = 3},
    [2] = {x = -1, y =  0},
    [3] = {x =  0, y =  1, flip = 2, rot = 3, key = '12', other_rot = 1},
  },
  [3] = {
    [1] = {x =  1, y =  0, flip = 0, rot = 0, key = '03', other_rot = 0},
    [2] = {x =  0, y = -1},
    [3] = {x = -1, y =  0, flip = 1, rot = 0, key = '23', other_rot = 2},
  }
}

BELT_TO_UBELT_MAP = {
  [0] = {
    [1] = {x =  0, y =  1, flip = 0, rot = 1, key = '10', other_rot = 1},
    [2] = {x =  1, y =  0},
    [3] = {x =  0, y = -1, flip = 2, rot = 1, key = '30', other_rot = 3},
  },
  [1] = {
    [1] = {x = -1, y =  0, flip = 0, rot = 2, key = '21', other_rot = 2},
    [2] = {x =  0, y =  1},
    [3] = {x =  1, y =  0, flip = 2, rot = 0, key = '01', other_rot = 0},
  },
  [2] = {
    [1] = {x =  0, y = -1, flip = 0, rot = 3, key = '32', other_rot = 3},
    [2] = {x = -1, y =  0},
    [3] = {x =  0, y =  1, flip = 2, rot = 3, key = '12', other_rot = 1},
  },
  [3] = {
    [1] = {x =  1, y =  0, flip = 0, rot = 0, key = '03', other_rot = 0},
    [2] = {x =  0, y = -1},
    [3] = {x = -1, y =  0, flip = 1, rot = 0, key = '23', other_rot = 2},
  }
}

function Belt:draw_hover_widget()
  local sx, sy = cursor.x, cursor.y
  local offset = {x = 8, y = 3}
  local w, h = print('Transport Belt', 0, -10, 0, false, 1, true) + 4, 60
  local x, y = clamp(sx + offset.x, 0, 240 - w - offset.x), clamp(sy + offset.y, 0, 136 - h - offset.y)
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, 'Transport Belt', 0)
  local b = {x = x + w/2 - 20, y = y + 13}
  sspr(self.id + BELT_TICK, b.x, b.y, 0, 5, self.flip, self.sprite_rot)
  local item_locations = BELT_CURVED_ITEM_MAP[self.output_item_key]
  local offsets = {
    [0] = {x = 0, y = 5},
    [1] = {x = 0, y = 0},
    [2] = {x = 7, y = 0},
    [3] = {x = 7, y = 10}
  }
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] > 0 then
        local xx = clamp(b.x + (item_locations[j][i].x * 5 + offsets[self.rot].x), b.x, b.x + 40)
        local yy = clamp(b.y + (item_locations[j][i].y * 5 + offsets[self.rot].y), b.y, b.y + 40)
        local sprite_id = ITEMS[self.lanes[i][j]].sprite_id
        sspr(sprite_id, xx, yy, ITEMS[self.lanes[i][j]].color_key, 1)
      end
    end
  end
end

function Belt:get_info()
  local info = {
    [1] = 'ROT: ' .. self.rot,
    [2] = 'SID: ' .. self.id,
    [3] = 'OTK: ' .. self.output_key,
    [4] = '#IM: ',
    [5] = 'NB1: ',
    [6] = 'NB2: ',
    [7] = 'NB3: ',
  }
  local item_count = 0
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] > 0 then
        item_count = item_count + 1
      end
    end
  end
  info[4] = info[4] .. item_count
  local x, y = self.pos.x, self.pos.y
  local loc1, loc2, loc3 = table.unpack(BELT_CURVE_MAP[self.rot])
  local left, rear, right = get_world_key(loc1.x + x, loc1.y + y), get_world_key(loc2.x + x, loc2.y + y), get_world_key(loc3.x + x, loc3.y + y)
  if ENTS[left]  and ENTS[left].type  == 'transport_belt' and ENTS[left]:is_facing(self)  then info[5] = info[5] .. 'true' else info[5] = info[5] .. 'false' end
  if ENTS[rear]  and ENTS[rear].type  == 'transport_belt' and ENTS[rear]:is_facing(self)  then info[6] = info[6] .. 'true' else info[6] = info[6] .. 'false' end
  if ENTS[right] and ENTS[right].type == 'transport_belt' and ENTS[right]:is_facing(self) then info[7] = info[7] .. 'true' else info[7] = info[7] .. 'false' end
  info[8] = 'OIK: ' .. tostring(self.output_item_key)
  return info
end

function Belt:rotate(rotation)
  if rotation > 3 then rotation = 0 end
  self.rot = rotation
  self.sprite_rot = rotation
  self:set_curved()
end

function Belt:is_facing(other)
  if ENTS[self.output_key] and ENTS[self.output_key].type == 'transport_belt' and ENTS[self.output_key] == other then return true end
  local exit = BELT_ROTATION_MAP[other.rot]
  local k = get_world_key(other.pos.x + exit.x, other.pos.y + exit.y)
  if ENTS[k] and ENTS[k] == self then return true end
  return false
end

function Belt:set_output()
  self.exit = BELT_ROTATION_MAP[self.rot]
  local k = self.pos.x + self.exit.x .. '-' .. self.pos.y + self.exit.y
  self.output_key = k
  local ent = ENTS[self.output_key]
  if ent then

    if ent.type == 'dummy_splitter' then
      self.output_key = ent.other_key
      ent = ENTS[self.output_key]
    end

    if ent.type == 'transport_belt'
    or ent.type == 'splitter' and ENTS[k].rot == self.rot
    or ent.type == 'underground_belt'
    or ent.type == 'underground_belt_exit' then
      if (ent.type == 'transport_belt' and ent.id == BELT_ID_CURVED) then
        self.output = BELT_OUTPUT_MAP[self.rot .. self.rot]
      else
        self.output = BELT_OUTPUT_MAP[self.rot .. ent.rot]
      end

    else
      self.output = nil
    end
  else
    self.output = nil
  end
  if self.id == BELT_ID_STRAIGHT then
    self.output_item_key = self.rot .. self.rot
  end
end

function Belt:has_items()
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] ~= 0 then return true end
    end
  end
  return false
end

function Belt.request_item_furnace(self, keep, desired_type, sub_type)
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] ~= 0 then
        local item = ITEMS[self.lanes[i][j]]
        if item.type == desired_type then
          if sub_type == item.name or sub_type == 'any' then
            item_id = self.lanes[i][j]
            if not keep then self.lanes[i][j] = 0 end
            return item_id
          end
        end
      end
    end
  end
end

function Belt:request_item(keep, lane, slot)
  -- keep = does this belt keep the item, or remove and return it?
  if not lane and not slot then
    for i = 1, 2 do
      for j = 1, 8 do
        if self.lanes[i][j] ~= 0 then
          local item_id = self.lanes[i][j]
          if not keep then self.lanes[i][j] = 0 end
          return item_id
        end
      end
    end
    return false
  elseif self.lanes[lane][slot] ~= 0 then
    local item_id = self.lanes[lane][slot]
    if not keep then self.lanes[lane][slot] = 0 end
    return item_id
  end
  return false
end

function Belt:request_item_inserter(needs)
  for i = 1, 2 do
    for j = 1, 8 do
      if (needs and self.lanes[i][j] == needs) or (not needs and self.lanes[i][j] ~= 0) then
        local id = self.lanes[i][j]
        self.lanes[i][j] = 0
        return id
      end
    end
  end
  return false
end

function Belt:update_neighbors(k)
  local cell_x, cell_y = self.pos.x, self.pos.y
  local tiles = {
    [1] = {x = cell_x, y = cell_y - 1},
    [2] = {x = cell_x + 1, y = cell_y},
    [3] = {x = cell_x, y = cell_y + 1},
    [4] = {x = cell_x - 1, y = cell_y}}
  for i = 1, 4 do
    local k = tiles[i].x .. '-' .. tiles[i].y
    if ENTS[k] then
      if ENTS[k].type == 'transport_belt' then ENTS[k]:set_curved() end
      if ENTS[k].type == 'splitter' then ENTS[k]:set_output() end
      if ENTS[k].type == 'dummy_splitter' then ENTS[ENTS[k].other_key]:set_output() end
      if ENTS[k].type == 'underground_belt_exit' then ENTS[ENTS[k].other_key]:set_output() end
      if ENTS[k].type == 'underground_belt' then ENTS[k]:set_output() end
    end
  end
  self:set_curved()
end

function Belt:item_request(id)
  for i = 1, 2 do
    for j = 8, 1, -1 do
      if self.lanes[i][j] ~= 0 then
        if self.lanes[i][j] == id or id == 'any' or
        (id == 'ore' and ITEMS[self.lanes[i][j]].type == 'ore') or
        (id == 'fuel' and ITEMS[self.lanes[i][j]].type == 'fuel') then
          local id = self.lanes[i][j]
          self.lanes[i][j] = 0
          return id
        end
      end
    end
  end
  return false
end

function Belt:request_deposit()
  return 'any'
end

function Belt:deposit(id, other_rot)
  local lane = INSERTER_DEPOSIT_MAP[other_rot][self.rot]
  for i = 8, 1, -1 do
    if self.lanes[lane][i] == 0 then
      self.lanes[lane][i] = id
      return true
    end
  end
  return false
end

function Belt.set_curved(self)
  local ents = {['underground_belt_exit'] = true, ['transport_belt'] = true, ['splitter'] = true, ['dummy_splitter'] = true}
  if not self.curve_checked then
    self.curve_checked = true
    --checks left, right, and rear tiles (relative to ENTS rotation) for other ENTS
    --ENTS only curve if loc2 (rear input) is not facing me, loc1 XOR loc3, else belt is straight
    --loc1 = left input
    --loc2 = rear input
    --loc3 = right input
    local x, y = self.pos.x, self.pos.y
    local loc1, loc2, loc3 = table.unpack(BELT_CURVE_MAP[self.rot])
    local left, rear, right = get_world_key(loc1.x + x, loc1.y + y), get_world_key(loc2.x + x, loc2.y + y), get_world_key(loc3.x + x, loc3.y + y)
    --conditions to curve:
    --no belt/splitter behind me that's facing me
    --curve left if no belt/splitter to the right facing me AND  >
    --splitter/belt on left facing me
    ------------------------------------------------------------------------------------------
      if not ENTS[rear] or ENTS[rear].rot ~= self.rot then
        --can curve left or right now, since no REAR connection preventing snapping
        --------------------------------------------------------------------------------------
        if ENTS[left]
        and
        (ents[ENTS[left].type])
        and
        ENTS[left].rot == loc1.other_rot
        and
        (not ENTS[right] or (not ents[ENTS[right].type] or ENTS[right].rot ~= loc3.other_rot))
        then
          self.id, self.flip, self.sprite_rot, self.output_item_key = BELT_ID_CURVED, loc1.flip, loc1.rot, loc1.key
        --------------------------------------------------------------------------------------
        elseif ENTS[right]
        and
        (ents[ENTS[right].type])
        and
        ENTS[right].rot == loc3.other_rot
        and
        (not ENTS[left] or (not ents[ENTS[left].type] or ENTS[left].rot ~= loc1.other_rot))
      then
          self.id, self.flip, self.sprite_rot, self.output_item_key = BELT_ID_CURVED, loc3.flip, loc3.rot, loc3.key
        --------------------------------------------------------------------------------------
        else
          self.id = BELT_ID_STRAIGHT
          self.output_item_key = self.rot .. self.rot
        end
      ------------------------------------------------------------------------------------------
      else
        self.id = BELT_ID_STRAIGHT
        self.output_item_key = self.rot .. self.rot
      end
      self:set_output()
  end
end

function Belt.update(self)
  --self.idle = false
  -- if we have NOT updated this frame, continue
  if self.updated then return end
  if not self.updated then
    self.updated = true
    local should_idle = true
    for i = 1, 2 do
      --check each lane
      for j = 1, 8 do
        --check each lane's slots for an item (0 means no item, else number is an ITEM id)
        local id = self.lanes[i][j]
        if id ~= 0 then
          should_idle = false
        end
        if j == 1 and id ~= 0 then
          --if we are the 1st slot (closest to output), check next tile for a belt to output to
          self.output_key = self.pos.x + self.exit.x .. '-' .. self.pos.y + self.exit.y
          if not ENTS[self.output_key] then self.output = nil end
          if self.output ~= nil and ENTS[self.output_key] then
            if ENTS[self.output_key].type == 'transport_belt' then
              ENTS[self.output_key].idle = false
              --if i am facing another belt, update that belt first
              if not ENTS[self.output_key].updated then ENTS[self.output_key]:update() end
              --if we find a belt, and the ENTS nearest slot is empty (equals 0) then
              --move item to that belt
              if ENTS[self.output_key].id == BELT_ID_CURVED and ENTS[self.output_key].lanes[i][8] == 0 then
                --add item to other belt
                ENTS[self.output_key].lanes[i][8] = id
                --remove item from self
                self.lanes[i][j] = 0
              elseif ENTS[self.output_key].lanes[self.output[i].a][self.output[i].b] == 0 then
                ENTS[self.output_key].lanes[self.output[i].a][self.output[i].b] = id
                --ENTS[self.output_key].idle = false
                self.lanes[i][j] = 0
              end
            elseif ENTS[self.output_key].type == 'underground_belt' then
              if not ENTS[self.output_key].updated then ENTS[self.output_key]:update() end
              if ENTS[self.output_key].lanes[self.output[i].a][self.output[i].b] == 0 then
                ENTS[self.output_key].lanes[self.output[i].a][self.output[i].b] = id
                --ENTS[self.output_key].idle = false
                self.lanes[i][j] = 0
              end
            elseif ENTS[self.output_key].type == 'underground_belt_exit' then
              self.output_key = ENTS[self.output_key].other_key
              if not ENTS[self.output_key].updated then ENTS[self.output_key]:update() end
              if ENTS[self.output_key].exit_lanes[self.output[i].a][self.output[i].b] == 0 then
                ENTS[self.output_key].exit_lanes[self.output[i].a][self.output[i].b] = id
                --ENTS[self.output_key].idle = false
                self.lanes[i][j] = 0
              end
            --------------------------------------------------------------------------------------------------
            elseif ENTS[self.output_key].type == 'splitter' or ENTS[self.output_key].type == 'dummy_splitter' then
              local key = self.output_key
              local side = 2
              --if key is a dummy splitter, then get the parent splitter's key
              if ENTS[key].type == 'dummy_splitter' then
                key = ENTS[self.output_key].other_key
                side = 1
              end
              --if not ENTS[key].updated then ENTS[key]:update() end
              if ENTS[key]:input(id, i, side) then
                self.lanes[i][1] = 0
              end
              --if should_shift then ENTS[key].shift = not ENTS[key].shift end
            end
          ------------------------------------------------------------------------------------------------------
          end
        elseif id ~= 0 and j > 1 and j < 9 and self.lanes[i][j-1] == 0 then
          --shift item up 1-index if next slot is empty -> (== 0)
          self.lanes[i][j-1] = id
          --set current space as empty now
          self.lanes[i][j] = 0
        end
      end
    end
    --set flag so we don't update twice in certain cases
    --self.updated = true
    --if should_idle then self.idle = true end
    --self.idle = false
  end
end

function Belt:draw()
  if not self.belt_drawn then
    self.belt_drawn = true
    if ENTS[self.output_key] then
      local key = self.output_key
      if ENTS[key].type == 'transport_belt' and ENTS[key].belt_drawn == false then ENTS[key]:draw() end
    end
    local rot = self.rot
    local flip = 0
    if self.id == BELT_ID_CURVED then rot = self.sprite_rot flip = self.flip end
    local sx, sy = world_to_screen(self.pos.x, self.pos.y)
    self.screen_pos = {x = sx, y = sy}
    sspr(self.id + BELT_TICK, sx, sy, BELT_COLORKEY, 1, flip, rot, 1, 1)
  end
end

function Belt.draw_items(self)
  if not self.drawn then
    self.drawn = true
    if ENTS[self.output_key] and ENTS[self.output_key].type == 'underground_belt' then
      ENTS[self.output_key]:draw()
      ENTS[self.output_key]:draw_items()
    end
    if ENTS[self.output_key] and ENTS[self.output_key].type == 'transport_belt' and ENTS[self.output_key].drawn == false then ENTS[self.output_key]:draw_items() end
    if ENTS[self.output_key] and 
    (ENTS[self.output_key].type == 'splitter' or 
    ENTS[self.output_key].type == 'dummy_splitter') then
      local key = self.output_key
      if ENTS[self.output_key].type == 'dummy_splitter' then key = ENTS[self.output_key].other_key end
      if ENTS[key].drawn == false then ENTS[key]:draw() end
    end
    local item_locations = BELT_CURVED_ITEM_MAP[self.output_item_key]
    for i = 1, 2 do
      local lane = self.lanes[i]
      for j = 1, 8 do
        local item = ITEMS[self.lanes[i][j]]
        local sx, sy = world_to_screen(self.pos.x, self.pos.y)
        if item then
          sspr(item.belt_id, item_locations[j][i].x + sx, item_locations[j][i].y + sy, item.color_key)
        end
      end
    end
  end
end

function Belt:return_all()
  local item_stacks = {}
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes[i][j] > 0 then
        local id = self.lanes[i][j]
        if not item_stacks[id] then item_stacks[id] = 0 end
        item_stacks[id] = item_stacks[id] + 1
        self.lanes[i][j] = 0
      end
    end
  end

  local offset = 0
  for k, v in pairs(item_stacks) do
    inv:add_item({id = k, count = v})
    ui.new_alert(cursor.x, cursor.y + offset, '+' .. v .. ' ' .. ITEMS[k].fancy_name, 1000, 0, 11)
    offset = offset + 6
  end
end

function new_belt(pos, rotation, children)
  local newBelt = {pos = pos, rot = rotation or 0}
  newBelt.id = BELT_ID_STRAIGHT
  if children then
    newBelt.lanes = children
  else
    newBelt.lanes = {}
    for i = 1, 2 do
      newBelt.lanes[i] = {}
      for j = 1, 8 do
        newBelt.lanes[i][j] = 0
      end
    end
  end
  setmetatable(newBelt, {__index = Belt})
  --newBelt:rotate(rotation or 0)
  return newBelt
end

SPLITTER_ID       = 322
SPLITTER_ID_SMALL = 323
SPLITTER_ID_TOP   = 322
SPLITTER_ID_BTM   = 338
SPLITTER_TICKRATE = 5

SPLITTER_ROTATION_MAP = {
  --x,y is for drawing second splitter half
  [0] = {x = 0, y =  1},
  [1] = {x = 1, y =  0},
  [2] = {x = 0, y =  1},
  [3] = {x = 1, y =  0},
}

SPLITTER_OUTPUT_MAP = {
  [0] = {left = {x = -1, y =  1}, right = {x = -1, y =  0}, left_in = {x =  1, y =  1}, right_in = {x =  1, y =  0}},
  [1] = {left = {x =  0, y = -1}, right = {x =  1, y = -1}, left_in = {x =  0, y =  1}, right_in = {x =  1, y =  1}},
  [2] = {left = {x =  1, y =  0}, right = {x =  1, y =  1}, left_in = {x = -1, y =  0}, right_in = {x = -1, y =  1}},
  [3] = {left = {x =  1, y =  1}, right = {x =  0, y =  1}, left_in = {x =  1, y = -1}, right_in = {x =  0, y = -1}}
}

SPLITTER_ITEM_MAP = {
  [0] = {a = {x =  0, y =  0}, b = {x = 0, y = 4}, c = {x = 0, y = 8}, d = {x =  0, y = 12}},
  [1] = {a = {x = 13, y =  0}, b = {x = 9, y = 0}, c = {x = 5, y = 0}, d = {x =  1, y =  0}},
  [2] = {a = {x =  5, y = 13}, b = {x = 5, y = 9}, c = {x = 5, y = 5}, d = {x =  5, y =  1}},
  [3] = {a = {x =  0, y =  5}, b = {x = 4, y = 5}, c = {x = 8, y = 5}, d = {x = 12, y =  5}},
}

SPLITTER_BELT_OUTPUT_MAP = {
    ['00'] = {[1] = {lane = 1, slot = 8}, [2] = {lane = 2, slot = 8}},
    ['01'] = {[1] = {lane = 1, slot = 4}, [2] = {lane = 1, slot = 6}},
    ['02'] = nil,
    ['03'] = {[1] = {lane = 2, slot = 6}, [2] = {lane = 2, slot = 4}},
    ['10'] = {[1] = {lane = 2, slot = 1}, [2] = {lane = 2, slot = 4}},
    ['11'] = {[1] = {lane = 1, slot = 8}, [2] = {lane = 2, slot = 8}},
    ['12'] = {[1] = {lane = 1, slot = 5}, [2] = {lane = 1, slot = 3}},
    ['13'] = nil,
    ['20'] = nil,
    ['21'] = {[1] = {lane = 2, slot = 4}, [2] = {lane = 2, slot = 6}},
    ['22'] = {[1] = {lane = 1, slot = 8}, [2] = {lane = 2, slot = 8}},
    ['23'] = {[1] = {lane = 1, slot = 4}, [2] = {lane = 1, slot = 6}},
    ['30'] = {[1] = {lane = 1, slot = 1}, [2] = {lane = 1, slot = 4}},
    ['31'] = nil,
    ['32'] = {[1] = {lane = 2, slot = 6}, [2] = {lane = 2, slot = 4}},
    ['33'] = {[1] = {lane = 1, slot = 8}, [2] = {lane = 2, slot = 8}}
}

local Splitter = {
  x = 0,
  y = 0,
  rot = 0,
  type = 'splitter',
  key2 = '',
  is_hovered = false,
  lanes = {left = {}, right = {}},
  shift = true,
  output_key_l = 'nil',
  output_l = nil,
  output_r = nil,
  output_key_r = 'nil',
  input_key_l  = 'nil',
  input_key_r  = 'nil',
  updated = false,
  drawn = false,
  item_id = 10,
  tickrate = 5,
}

function Splitter:draw_hover_widget()
  local sx, sy = cursor.x, cursor.y
  rectb(sx, sy, 50, 50, 13)
  rect(sx + 1, sy + 1, 48, 48, 0)
end

function Splitter.get_info(self)
  local world_key = self.x .. '-' .. self.y
  local output_map = SPLITTER_OUTPUT_MAP[self.rot]
  local output_key_l = self.x + output_map.left.x .. '-' .. self.y + output_map.left.y
  local output_key_r = self.x + output_map.right.x .. '-' .. self.y + output_map.right.y
  local left_ent, right_ent = ENTS[output_key_l] and ENTS[output_key_l].type or 'NIL', ENTS[output_key_r] and ENTS[output_key_r].type or 'NIL'
  local info = {
    [1] = 'WORLD KEY: ' .. world_key,
    [2] = 'LEFT KEY: ' .. output_key_l,
    [3] = 'LEFT ENT: ' .. left_ent,
    [4] = 'RIGHT KEY: ' .. output_key_r,
    [5] = 'RIGHT ENT: ' .. right_ent,
  }
  return info
end

function Splitter.set_output(self)
  --trace('setting splitter output')
  local output_map = SPLITTER_OUTPUT_MAP[self.rot]
  self.output_key_l = self.x + output_map.left.x .. '-' .. self.y + output_map.left.y
  self.output_key_r = self.x + output_map.right.x .. '-' .. self.y + output_map.right.y
  self.input_key_l = self.x + output_map.left_in.x .. '-' .. self.y + output_map.left_in.y
  self.input_key_r = self.x + output_map.right_in.x .. '-' .. self.y + output_map.right_in.y
  local l, r = ENTS[self.output_key_l], ENTS[self.output_key_r]
  if l then
    if l.type == 'transport_belt' then
      local rot_key = self.rot .. l.rot
      self.output_l = SPLITTER_BELT_OUTPUT_MAP[rot_key]
      ENTS[self.output_key_l]:set_curved()
    elseif l.type == 'dummy_splitter' then
      self.output_key_l = l.other_key
      local rot_key = self.rot .. l.rot
      self.output_l = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif l.type == 'splitter' then
      local rot_key = self.rot .. l.rot
      self.output_l = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif l.type == 'underground_belt' then
      local rot_key = self.rot .. l.rot
      self.output_l = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif l.type == 'underground_belt_exit' then
      local rot_key = self.rot .. l.rot
      self.output_l = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    end
  else
    self.output_l = nil
  end

  if r then
    if r.type == 'transport_belt' then
      local rot_key = self.rot .. r.rot
      self.output_r = SPLITTER_BELT_OUTPUT_MAP[rot_key]
      ENTS[self.output_key_r]:set_curved()
    elseif r.type == 'dummy_splitter' then
      self.output_key_r = r.other_key
      local rot_key = self.rot .. r.rot
      self.output_r = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif r.type == 'splitter' then
      local rot_key = self.rot .. r.rot
      self.output_r = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif r.type == 'underground_belt' then
      local rot_key = self.rot .. r.rot
      self.output_r = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    elseif r.type == 'underground_belt_exit' then
      local rot_key = self.rot .. r.rot
      self.output_r = SPLITTER_BELT_OUTPUT_MAP[rot_key]
    end
  else
    self.output_r = nil
  end

  if ENTS[self.input_key_l] then
    if ENTS[self.input_key_l].type == 'splitter' then
      ENTS[self.input_key_l]:set_output()
    elseif ENTS[self.input_key_l].type == 'dummy_splitter' then
      local key = ENTS[self.input_key_l].other_key
      ENTS[key]:set_output()
    elseif ENTS[self.input_key_l].type == 'transport_belt' then
      ENTS[self.input_key_l]:set_curved()
    end
  end

  if ENTS[self.input_key_r] then
    if ENTS[self.input_key_r].type == 'splitter' then
      ENTS[self.input_key_r]:set_output()
    elseif ENTS[self.input_key_r].type == 'dummy_splitter' then
      local key = ENTS[self.input_key_r].other_key
      ENTS[key]:set_output()
    elseif ENTS[self.input_key_r].type == 'transport_belt' then
      ENTS[self.input_key_r]:set_curved()
    end
  end

end

function Splitter:input(item_id, lane)
  if self.shift then
    if self.lanes.right[lane][8] == 0 then
      self.lanes.right[lane][8] = item_id
      return true
    elseif self.lanes.left[lane][8] == 0 then
      self.lanes.left[lane][8] = item_id
      return true
    end
  else
    if self.lanes.left[lane][8] == 0 then
      self.lanes.left[lane][8] = item_id
      return true
    elseif self.lanes.right[lane][8] == 0 then
      self.lanes.right[lane][8] = item_id
      return true
    end
  end
  return false
end

function Splitter.give_inserter(self, side)
  if side == 'left' then
    for i = 1, 2 do
      for j = 1, 8 do
        if self.lanes.left[i][j] ~= 0 then
          local item = self.lanes.left[i][j]
          self.lanes.left[i][j] = 0
          return item
        end
      end
    end
  else
    for i = 1, 2 do
      for j = 1, 8 do
        if self.lanes.right[i][j] ~= 0 then
          local item = self.lanes.right[i][j]
          self.lanes.right[i][j] = 0
          return item
        end
      end
    end
  end
  return nil
end

function Splitter.update(self)
  if not self.updated then
    self.shift = not self.shift
    self.updated = true
    for i = 1, 2 do
      for j = 1, 8 do
        if j == 1 then
          local l, r = ENTS[self.output_key_l], ENTS[self.output_key_r]
          if self.output_l ~= nil and l and self.lanes.left[i][1] ~= 0 then
            if l.type == 'splitter' or l.type == 'dummy_splitter' then
              local key = self.output_key_l
              if ENTS[key].type == 'dummy_splitter' then key = ENTS[self.output_key_l].other_key end
              if not ENTS[key].updated then ENTS[key]:update() end
              if ENTS[key]:input(self.lanes.left[i][1], 2) then
                self.lanes.left[i][1] = 0
              end
            elseif l.type == 'transport_belt' then
              if not l.updated then ENTS[self.output_key_l]:update() end
              if l.id == BELT_ID_CURVED and l.lanes[i][8] == 0 then
                --add item to other belt
                ENTS[self.output_key_l].lanes[i][8] = self.lanes.left[i][1]
                --remove item from self
                self.lanes.left[i][1] = 0
              elseif l.lanes[self.output_l[i].lane][self.output_l[i].slot] == 0 then
                ENTS[self.output_key_l].lanes[self.output_l[i].lane][self.output_l[i].slot] = self.lanes.left[i][1]
                --ENTS[self.output_key].idle = false
                self.lanes.left[i][1] = 0                
              end
            elseif l.type == 'underground_belt' then
              if not l.updated then ENTS[self.output_key_l]:update() end
              if l.lanes[self.output_l[i].lane][self.output_l[i].slot] == 0 then
                ENTS[self.output_key_l].lanes[self.output_l[i].lane][self.output_l[i].slot] = self.lanes.left[i][1]
                --ENTS[self.output_key].idle = false
                self.lanes.left[i][1] = 0
              end
            elseif l.type == 'underground_belt_exit' then

            end
          end
          
          if self.output_r ~= nil and r and self.lanes.right[i][1] ~= 0 then
            if r.type == 'splitter' or r.type == 'dummy_splitter' then
              local key = self.output_key_r
              if r.type == 'dummy_splitter' then key = r.other_key end
              if not ENTS[key].updated then ENTS[key]:update() end
              if ENTS[key]:input(self.lanes.right[i][1], 2) then
                self.lanes.right[i][1] = 0
              end
            elseif r.type == 'transport_belt' and r.lanes[i][8] == 0 then
              if not r.updated then ENTS[self.output_key_r]:update() end
              if r.id == BELT_ID_CURVED and r.lanes[i][8] == 0 then
                --add item to other belt
                ENTS[self.output_key_r].lanes[i][8] = self.lanes.right[i][1]
                --remove item from self
                self.lanes.right[i][1] = 0
              elseif r.lanes[self.output_r[i].lane][self.output_r[i].slot] == 0 then
                ENTS[self.output_key_r].lanes[self.output_r[i].lane][self.output_r[i].slot] = self.lanes.right[i][1]
                --ENTS[self.output_key].idle = false
                self.lanes.right[i][1] = 0
              end
            elseif r.type == 'underground_belt' then
              if not r.updated then ENTS[self.output_key_r]:update() end
              if r.lanes[self.output_r[i].lane][self.output_r[i].slot] == 0 then
                ENTS[self.output_key_r].lanes[self.output_r[i].lane][self.output_r[i].slot] = self.lanes.right[i][1]
                --ENTS[self.output_key].idle = false
                self.lanes.right[i][1] = 0
              end
            elseif r.type == 'underground_belt_exit' then

            end
          end
        else
          --left
          if self.lanes.left[i][j] ~= 0 and self.lanes.left[i][j - 1] == 0 then
            self.lanes.left[i][j - 1] = self.lanes.left[i][j]
            self.lanes.left[i][j] = 0
          end
          --flip

          --right
          if self.lanes.right[i][j] ~= 0 and self.lanes.right[i][j - 1] == 0 then
            self.lanes.right[i][j - 1] = self.lanes.right[i][j]
            self.lanes.right[i][j] = 0
          end
        end
      end
    end
  end
end

function Splitter.draw(self)
  if not self.drawn then
    self.drawn = true
    local rot_map = SPLITTER_ROTATION_MAP[self.rot]
    local wx, wy = world_to_screen(self.x, self.y)
    sspr(BELT_ID_STRAIGHT + BELT_TICK, wx, wy, BELT_COLORKEY, 1, 0, self.rot)
    sspr(BELT_ID_STRAIGHT + BELT_TICK, wx + (rot_map.x * 8), wy + (rot_map.y * 8), BELT_COLORKEY, 1, 0, self.rot)

    if ENTS[self.output_key_r] and ENTS[self.output_key_r].type == 'transport_belt' then
      if ENTS[self.output_key_r].belt_drawn == false then ENTS[self.output_key_r]:draw() end
      ENTS[self.output_key_r]:draw_items()
    end
    if ENTS[self.output_key_l] and ENTS[self.output_key_l].type == 'transport_belt' then
      if ENTS[self.output_key_l].belt_drawn == false then ENTS[self.output_key_l]:draw() end
      ENTS[self.output_key_l]:draw_items()
    end
    self:draw_items()
    sspr(SPLITTER_ID, wx, wy, 0, 1, 0, self.rot, 1, 2)
  end
end

function Splitter.draw_items(self)
  --if not self.drawn then
   -- self.drawn = true
    local item_map = SPLITTER_ITEM_MAP[self.rot]
    local a, b, c, d = item_map.a, item_map.b, item_map.c, item_map.d
    local wx, wy = world_to_screen(self.x, self.y)

  local function get_id(side, lane, slot)
    if side == 1 then --left
      return ITEMS[self.lanes.left[lane][slot]]
    else
      return ITEMS[self.lanes.right[lane][slot]]
    end
  end


    for k = 1, 8 do
      if self.rot == 0 then
        if self.lanes.right[1][k] ~= 0 then local item = get_id(0, 1, k) sspr(item.belt_id, wx + a.x + (k - 1), wy + a.y, item.color_key) end
        if self.lanes.right[2][k] ~= 0 then local item = get_id(0, 2, k) sspr(item.belt_id, wx + b.x + (k - 1), wy + b.y, item.color_key) end
        if self.lanes.left[1][k] ~= 0  then local item = get_id(1, 1, k) sspr(item.belt_id, wx + c.x + (k - 1), wy + c.y, item.color_key) end
        if self.lanes.left[2][k] ~= 0  then local item = get_id(1, 2, k) sspr(item.belt_id, wx + d.x + (k - 1), wy + d.y, item.color_key) end
      elseif self.rot == 1 then
        if self.lanes.right[1][k] ~= 0 then local item = get_id(0, 1, k) sspr(item.belt_id, wx + a.x, wy + a.y + (k - 1), item.color_key) end
        if self.lanes.right[2][k] ~= 0 then local item = get_id(0, 2, k) sspr(item.belt_id, wx + b.x, wy + b.y + (k - 1), item.color_key) end
        if self.lanes.left[1][k] ~= 0  then local item = get_id(1, 1, k) sspr(item.belt_id, wx + c.x, wy + c.y + (k - 1), item.color_key) end
        if self.lanes.left[2][k] ~= 0  then local item = get_id(1, 2, k) sspr(item.belt_id, wx + d.x, wy + d.y + (k - 1), item.color_key) end
      elseif self.rot == 2 then
        if self.lanes.right[1][k] ~= 0 then local item = get_id(0, 1, k) sspr(item.belt_id, wx + a.x - (k - 1), wy + a.y, item.color_key) end
        if self.lanes.right[2][k] ~= 0 then local item = get_id(0, 2, k) sspr(item.belt_id, wx + b.x - (k - 1), wy + b.y, item.color_key) end
        if self.lanes.left[1][k] ~= 0  then local item = get_id(1, 1, k) sspr(item.belt_id, wx + c.x - (k - 1), wy + c.y, item.color_key) end
        if self.lanes.left[2][k] ~= 0  then local item = get_id(1, 2, k) sspr(item.belt_id, wx + d.x - (k - 1), wy + d.y, item.color_key) end
      else
        if self.lanes.right[1][k] ~= 0 then local item = get_id(0, 1, k) sspr(item.belt_id, wx + a.x, wy + a.y - (k - 1), item.color_key) end
        if self.lanes.right[2][k] ~= 0 then local item = get_id(0, 2, k) sspr(item.belt_id, wx + b.x, wy + b.y - (k - 1), item.color_key) end
        if self.lanes.left[1][k] ~= 0  then local item = get_id(1, 1, k) sspr(item.belt_id, wx + c.x, wy + c.y - (k - 1), item.color_key) end
        if self.lanes.left[2][k] ~= 0  then local item = get_id(1, 2, k) sspr(item.belt_id, wx + d.x, wy + d.y - (k - 1), item.color_key) end
      end
    end
end

function Splitter:item_request(id)
  for i = 1, 2 do
    for j = 8, 1, -1 do
      local side = (self.lanes.left[i][j] > 0 and {id = self.lanes.left[i][j], lane = 'left'}) or (self.lanes.right[i][j] > 0 and {id = self.lanes.right[i][j], lane = 'right'})
      local item = side and ITEMS[side.id]
      if item then
        if item.type == id or side.id == id or id == 'any' then
          if side.lane == 'left' then
            self.lanes.left[i][j] = 0
          elseif side.lane == 'right' then
            self.lanes.right[i][j] = 0
          end
          return item.id
        end
      end
    end
  end
  return false
end

function Splitter:request_deposit()
  return 'any'
end

function Splitter:deposit(id, other_rot)
  local lane = INSERTER_DEPOSIT_MAP[other_rot][self.rot]
  return self:input(id, lane)
end

function Splitter:return_all()
  local item_stacks = {}
  for i = 1, 2 do
    for j = 1, 8 do
      if self.lanes.left[i][j] > 0 then
        local id = self.lanes.left[i][j]
        if not item_stacks[id] then item_stacks[id] = 0 end
        item_stacks[id] = item_stacks[id] + 1
        self.lanes.left[i][j] = 0
      end
      if self.lanes.right[i][j] > 0 then
        local id = self.lanes.right[i][j]
        if not item_stacks[id] then item_stacks[id] = 0 end
        item_stacks[id] = item_stacks[id] + 1
        self.lanes.right[i][j] = 0
      end
    end
  end

  local offset = 0
  for k, v in pairs(item_stacks) do
    inv:add_item({id = k, count = v})
    ui.new_alert(cursor.x, cursor.y + offset, '+' .. v .. ' ' .. ITEMS[k].fancy_name, 1000, 0, 11)
    offset = offset + 6
  end
end

function new_splitter(x, y, rot)
  local new_splitter = {x = x, y = y, rot = rot}
  setmetatable(new_splitter, {__index = Splitter})
  new_splitter.lanes = {}
  new_splitter.lanes.left = {}
  new_splitter.lanes.right = {}
  for i = 1, 2 do
    new_splitter.lanes.left[i] = {}
    new_splitter.lanes.right[i] = {}
    for j = 1, 8 do
      new_splitter.lanes.left[i][j] = 0
      new_splitter.lanes.right[i][j] = 0
    end
  end
  --new_splitter:set_output()
  return new_splitter
end

INSERTER_BASE_ID       = 264
INSERTER_ARM_ID        = 265
INSERTER_ARM_ANGLED_ID = 266
INSERTER_ANIM_TICKRATE = 4
INSERTER_TICKRATE      = 4
INSERTER_COLORKEY = 15

INSERTER_ARM_OFFSETS = {
  [0] = {id = INSERTER_ARM_ID,        x = -3, y =  0, rot = 0, item_offset = {x = -1, y =  2}},
  [1] = {id = INSERTER_ARM_ANGLED_ID, x = -3, y = -3, rot = 0, item_offset = {x =  1, y =  1}},
  [2] = {id = INSERTER_ARM_ID,        x =  0, y = -3, rot = 1, item_offset = {x =  2, y = -1}},
  [3] = {id = INSERTER_ARM_ANGLED_ID, x =  3, y = -3, rot = 1, item_offset = {x =  4, y =  1}},
  [4] = {id = INSERTER_ARM_ID,        x =  3, y =  0, rot = 2, item_offset = {x =  6, y =  3}},
  [5] = {id = INSERTER_ARM_ANGLED_ID, x =  3, y =  3, rot = 2, item_offset = {x =  5, y =  5}},
  [6] = {id = INSERTER_ARM_ID,        x =  0, y =  3, rot = 3, item_offset = {x =  2, y =  6}},
  [7] = {id = INSERTER_ARM_ANGLED_ID, x = -3, y =  3, rot = 3, item_offset = {x =  3, y =  4}},
}

INSERTER_GRAB_OFFSETS = {
  [0] = {from = {x =  1, y =  0}, to = {x = -1, y =  0}},
  [1] = {from = {x =  0, y =  1}, to = {x =  0, y = -1}},
  [2] = {from = {x = -1, y =  0}, to = {x =  1, y =  0}},
  [3] = {from = {x =  0, y = -1}, to = {x =  0, y =  1}},
}

INSERTER_DEPOSIT_MAP = {
  [0] = {[0] = 1, [1] = 2, [2] = 2, [3] = 1},
  [1] = {[0] = 1, [1] = 2, [2] = 2, [3] = 1},
  [2] = {[0] = 1, [1] = 1, [2] = 2, [3] = 2},
  [3] = {[0] = 2, [1] = 2, [2] = 1, [3] = 1},
}

INSERTER_ANIM_KEYS = {
  [0] = {0,1,2,3,4},
  [1] = {2,3,4,5,6},
  [2] = {4,5,6,7,0},
  [3] = {6,7,0,1,2}
}

local Inserter = {
  pos = {x = 0, y = 0},
  rot = 0,
  color_keys = {15},
  from_key = '0-0',
  to_key = '0-0',
  anim_frame = 5,
  state = 'wait',
  held_item_id = 0,
  is_hovered = false,
  type = 'inserter',
  item_id = 11,
  filter = {item_id = 0},
  tickrate = 5,
}

function Inserter:draw_hover_widget()
  if tick % 60 == 0 then
    trace('state: ' .. self.state)
    trace('id = ' .. self.held_item_id)
  end
end

function Inserter:get_info()
  local info = {
    [1] = 'POS: ' .. get_key(self.pos.x, self.pos.y),
    [2] = 'ROT: ' .. self.rot,
    [3] = 'OUT: ' .. self.to_key,
    [4] = 'INP: ' .. self.from_key,
  }
  return info
end

function Inserter:draw()
  local config = INSERTER_ARM_OFFSETS[INSERTER_ANIM_KEYS[self.rot][self.anim_frame]]
  local sx, sy = world_to_screen(self.pos.x, self.pos.y)
  local screen_pos = {x = sx, y = sy}
  local x, y = config.x + screen_pos.x, config.y + screen_pos.y
  spr(INSERTER_BASE_ID, screen_pos.x, screen_pos.y, self.color_keys, 1, 0, self.rot, 1, 1)
  spr(config.id, x, y, self.color_keys, 1, 0, config.rot, 1, 1)
  if self.held_item_id > 0 then
    local sprite_id = ITEMS[self.held_item_id].belt_id
    local ck = {ITEMS[self.held_item_id].color_key}
    spr(sprite_id, x + config.item_offset.x, y + config.item_offset.y, ck)
  end
end

function Inserter:can_deposit(other, item_id)
  if ENTS[other] then
    if ENTS[other].type == 'transport_belt' then
      return true
    elseif ENTS[other].type == 'stone_furnace' then
      if ENTS[other]:deposit({id = item_id, count = 1}, true) then return true end
    elseif ENTS[other].type == 'splitter' then
      if ENTS[other]:deposit({id = item_id, count = 1}, true) then return true end
    end
  end
  return false
end

function Inserter:request_deposit()
  if not self.state == 'wait' or self.held_item_id ~= 0 then return false end
  return 'any'
end

function Inserter:deposit(id)
  if self.state == 'wait' and self.held_item_id == 0 then
    self.held_item_id = id
    self.state = 'send'
    return true
  end
  return false
end

function Inserter:item_request(id)
  if not self.recipe then return false end
  if self.output.count > 0 and (self.output.id == id or id == 'any') then
    self.output.count = self.output.count - 1
    return self.output.id
  end
  return false
end

function Inserter:set_output()
  local from, to = INSERTER_GRAB_OFFSETS[self.rot].from, INSERTER_GRAB_OFFSETS[self.rot].to
  self.from_key = self.pos.x + from.x .. '-' .. self.pos.y + from.y
  self.to_key = self.pos.x  + to.x .. '-' .. self.pos.y + to.y
end

function Inserter:rotate(rotation)
  rotation = rotation or self.rot + 1
  self.rot = rotation
  if self.rot > 3 then self.rot = 0 end
  self:set_output()
end

function Inserter:update()
  local from, to = self.from_key, self.to_key
  if ENTS[from] and dummies[ENTS[from].type] then
    self.from_key = ENTS[from].other_key
    from = self.from_key
  end
  if ENTS[to] and dummies[ENTS[to].type] then
    self.to_key = ENTS[to].other_key
    to = self.to_key
  end
  if not ENTS[self.from_key] or not ENTS[self.to_key] then
    self:set_output()
    return
  end

  if self.state == 'send' then
    if not ENTS[to] then return end
    self.anim_frame = self.anim_frame - 1
    if self.anim_frame <= 1 then
      self.anim_frame = 1
      --try to deposit item
      if ENTS[to] then
        if ENTS[to]:deposit(self.held_item_id, self.rot) then
          self.state = 'return'
          self.held_item_id = 0
          return
        end
      else
        return
      end
    end
  elseif self.state == 'return' then
    self.anim_frame = self.anim_frame + 1
    if self.anim_frame >= 5 then
      -- inserter has returned, and waits for another item
      self.anim_frame = 5
      self.state = 'wait'
    end
  elseif self.state == 'wait' then
    local desired_item = ENTS[to]:request_deposit(self)
    --if desired_item then trace('inserter: desired item = ' .. tostring(ITEMS[desired_item].fancy_name)) end
    if not desired_item then return end
    local retrieved_item = ENTS[from]:item_request(desired_item, self)
    --if retrieved_item ~= false then trace('inserter: retrieved_item = ' .. tostring(ITEMS[retrieved_item].fancy_name or false)) end
    if not retrieved_item then return end
    if ENTS[to].assign_delivery then ENTS[to]:assign_delivery(retrieved_item) end
    self.held_item_id = retrieved_item
    self.state = 'send'
  end
end

function new_inserter(position, rotation)
  local new_inserter = {
    pos = position,
    rot = rotation,
    color_keys = {15},
    from_key = '0-0',
    to_key = '0-0',
    anim_frame = 5,
    state = 'wait',
    held_item_id = 0,
    is_hovered = false,
    type = 'inserter',
    item_id = 11,
    filter = {item_id = 0}
  }
  setmetatable(new_inserter, {__index = Inserter})
  --new_Inserter.pos = position
  --new_Inserter.rot = rotation
  new_inserter:set_output()
  return new_inserter
end

-- require('classes/cable')
-- require('classes/power_pole')

DRILL_BURNER_SPRITE_ID = 273
DRILL_ELEC_SPRITE_ID = 368
DRILL_INV_ID = 276
DRILL_MINI_BELT_ID = 304
DRILL_BELT_ID = 304
DRILL_BIT_ID = 275
DRILL_TICK_RATE = 8
DRILL_ANIM_TICK = 0
DRILL_BIT_DIR = 1
DRILL_BIT_TICK = 0

--for placing and animating the drill bits, rotated
DRILL_BIT_MAP = {
  [0] = {[0] = {x =  2, y =  2, r = 0}, [1] = {x = 6, y = 5, r = 2}},
  [1] = {[0] = {x =  3, y =  0, r = 3}, [1] = {x = 6, y = 8, r = 1}},
  [2] = {[0] = {x =  2, y =  3, r = 0}, [1] = {x = 6, y = 6, r = 2}},
  [3] = {[0] = {x =  2, y = -1, r = 3}, [1] = {x = 5, y = 7, r = 1}},
}
--for placing and animating the ore-output belt, rotated
DRILL_BELT_MAP = {
  [0] = {x = -4, y =  3},
  [1] = {x =  5, y = -4},
  [2] = {x = 12, y =  5},
  [3] = {x =  3, y = 12},
}

DRILL_MINI_BELT_MAP = {
  [0] = {x =  0, y =  8},
  [1] = {x =  0, y =  0},
  [2] = {x =  8, y =  0},
  [3] = {x =  8, y =  8}
}

DRILL_OUTPUT_MAP = {
  [0] = {x = -1, y =  1},
  [1] = {x = 0, y = -1},
  [2] = {x = 2, y =  0},
  [3] = {x =  1, y = 2},
}

DRILL_AREA_MAP_BURNER = {
  [1] = {x = 0, y = 0},
  [2] = {x = 1, y = 0},
  [3] = {x = 1, y = 1},
  [4] = {x = 0, y = 1}
}

DRILL_AREA_MAP_ELECTRIC = {
  [1] = {x = 0, y = 0},
  [2] = {x = 1, y = 0},
  [3] = {x = 2, y = 0},
  [4] = {x = 0, y = 1},
  [5] = {x = 1, y = 1},
  [6] = {x = 2, y = 1},
  [7] = {x = 0, y = 2},
  [8] = {x = 1, y = 2},
  [9] = {x = 2, y = 2}
}

DRILL_BELT_OUTPUT_MAP = {
  [0] = {
    [0] = {lane = 1, slot = 8},
    [1] = {lane = 1, slot = 5},
    [2] = nil,
    [3] = {lane = 2, slot = 3}},
  [1] = {
    [0] = {lane = 2, slot = 3},
    [1] = {lane = 1, slot = 8},
    [2] = {lane = 1, slot = 4},
    [3] = nil},
  [2] = {
    [0] = nil,
    [1] = {lane = 2, slot = 3},
    [2] = {lane = 2, slot = 8},
    [3] = {lane = 1, slot = 4}},
  [3] = {
    [0] = {lane = 1, slot = 4},
    [1] = nil,
    [2] = {lane = 2, slot = 3},
    [3] = {lane = 1, slot = 8}},
}

local Drill = {
  pos = {x = 0, y = 0},
  rot = 0,
  --output = {},
  ore_type = false,
  ore_id = nil,
  output_key = nil,
  output_slots = 50,
  output = {},
  field_keys = {},
  is_powered = true,
  yield_tick = 0,
  current_tile = 1,
  type = 'mining_drill',
  sub_type = 'burner',
  is_hovered = false,
  drawn = false,
  updated = false,
  idle = false,
  item_id = 13,
  tickrate = 5,
}

function Drill:draw_hover_widget()
  local sx, sy, w, h = clamp(cursor.x + 3, 1, 240 - 51), clamp(cursor.y + 3, 1, 136 - 51), 50, 50
  ui.draw_panel(sx, sy, w, h, UI_BG, UI_FG, 'Mining Drill', 0)
  box(sx + w/2 - 4, sy + h/2 - 4, 10, 10, 0, UI_FG)
  if self.output and self.output.count > 0 then
    local stack = {id = self.output.id, count = self.output.count}
    draw_item_stack(sx + w/2 - 4 + 1, sy + h/2 - 4 + 1, stack)
  end
    -- rectb(sx, sy, 50, 50, 13)
  -- rect(sx + 1, sy + 1, 48, 48, 0)
end

function Drill:open()
  return {
    x = 240 - 83 - 2,
    y = 1,
    w = 58,
    h = 50,
    ent_key = self.pos.x .. '-' .. self.pos.y,
    close = function(self, sx, sy)
      local btn = {x = self.x + self.w - 9, y = self.y + 1, w = 5, h = 5}
      if sx >= btn.x and sy < btn.x + btn.w and sy >= btn.y and sy <= btn.y + btn.h then
        return true
      end
      return false
    end,
    draw = function(self)
      local txt = ITEMS[ENTS[self.ent_key].item_id].fancy_name
      local ent = ENTS[self.ent_key]
      ui.draw_panel(self.x, self.y, self.w, self.h, UI_BG, UI_FG, 'Mining Drill', UI_SH)
      --box(self.x, self.y, self.w, self.h, 8, 9)
      --rect(self.x + 1, self.y + 1, self.w - 2, 9, 9)
      --close button
      sspr(CLOSE_ID, self.x + self.w - 7, self.y + 2, 15)
      box(self.x + self.w/2 - 5, self.y + 20, 10, 10, 0, 9)
        if ent.output.count > 0 then
          draw_item_stack(self.x + self.w/2 - 4, self.y + 21, {id = ent.output.id, count = ent.output.count})
        end
      if self:is_hovered(cursor.x, cursor.y) and cursor.type == 'item' then
        draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
      end
      if hovered(cursor, {x = self.x + self.w/2 - 5, y = self.y + 20, w = 10, h = 10}) then
        ui.highlight(self.x + self.w/2 - 5, self.y + 20, 8, 8, false, 3, 4)
      end
    end,
    click = function(self, sx, sy)
      local ent = ENTS[self.ent_key]
      if self:close(sx, sy) then
        ui.active_window = nil
        return true
      end
      if hovered(cursor, {x = self.x + self.w/2 - 5, y = self.y + 20, w = 10, h = 10}) then
        if cursor.l and not cursor.ll then
          --item interaction
          if cursor.type == 'pointer' then
            if key(64) and ent.output.count > 0 then
              local old_count = ent.output.count
              local result, stack = inv:add_item({id = ent.output.id, count = ent.output.count})
              if result then
                ent.output.count = stack.count
                sound('deposit')
                ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output.id].fancy_name, 1000, 0, 6)
                return true
              end
            else
              if ent.output.count > 0 then
                cursor.type = 'item'
                cursor.item_stack.id = ent.output.id
                cursor.item_stack.count = ent.output.count
                ent.output.count = 0
                return true
              end
            end
          end
        end
      end
      return false
    end,
    is_hovered = function(self, x, y)
      return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
    end,
  }
end

function Drill.yield(self)
  if self.output.count < self.output_slots then
    --trace('current key: ' .. self.current_tile)
    local ore_key = self.field_keys[self.current_tile]
    local ore_id
    if ORES[ore_key] then
      --ore_id = ORES[ore_key].sprite_id
      ore_id = ORES[ore_key].id
      if self.output.id == 0 or self.output.count == 0 then self.output.id = ore_id end
      if ore_id == self.output.id then
        ORES[ore_key].ore_remaining = ORES[ore_key].ore_remaining - 1
        self.output.count = self.output.count + 1
      end
      if ORES[ore_key].ore_remaining < 1 then
        --trace('ore depleted')
        local wx, wy = ORES[ore_key].wx, ORES[ore_key].wy
        --trace('WX = ' .. wx .. ', WY = ' .. wy)
        TileMan:set_tile(wx, wy)
        ORES[ore_key] = nil
      end
    else
      -- self.current_tile = self.current_tile + 1
      -- if self.current_tile > #self.field_keys then self.current_tile = 1 end
      if not self.idle then self.yield_tick = 19 end
      --self:update()
    end
  end
end

function Drill.update(self)
  if self.is_powered and not self.idle then
    local item = ITEMS[self.output.id]
    if item and self.output.count == item.stack_size then return end
    --self:consume_electric()
    self.yield_tick = self.yield_tick + 1
    if self.yield_tick > 20 then
      local idle = true
      self.current_tile = self.current_tile + 1
      if self.current_tile > 4 then self.current_tile = 1 end
      self.yield_tick = 0
      self:yield()
    end

    --if tick % 60 == 0 then trace(tostring(ENTS[self.output_key] and ENTS[self.output_key].type or 'nil')) end
    --check for other ents
    if self.output.count > 0 and ENTS[self.output_key] then
      if ENTS[self.output_key].type == 'transport_belt' or
      ENTS[self.output_key].type == 'underground_belt' or
      ENTS[self.output_key].type == 'underground_belt_exit' then
        local output = DRILL_BELT_OUTPUT_MAP[self.rot][ENTS[self.output_key].rot]
        if output then
          if ENTS[self.output_key].type == 'underground_belt_exit' then
            if ENTS[ENTS[self.output_key].other_key].exit_lanes[output.lane][output.slot] == 0 then
              --trace('drill @ ' .. self.pos.x .. ',' .. self.pos.y .. ' outputting to belt @ ' .. self.output_key)
              ENTS[ENTS[self.output_key].other_key].exit_lanes[output.lane][output.slot] = self.output.id
              self.output.count = self.output.count - 1
              if self.output.count < 1 then self.output.id = 0 end
              return
            end
          elseif ENTS[self.output_key].lanes[output.lane][output.slot] == 0 then
            --trace('drill @ ' .. self.pos.x .. ',' .. self.pos.y .. ' outputting to belt @ ' .. self.output_key)
            ENTS[self.output_key].lanes[output.lane][output.slot] = self.output.id
            self.output.count = self.output.count - 1
            if self.output.count < 1 then self.output.id = 0 end
          end
        end
      end
    end

    local idle = true
    for i = 1, 4 do
      if ORES[self.field_keys[i]] then
        idle = false
        break
      end
    end
    if idle == true and self.output.count < 1 then
      self.idle = true
    end
  end
end

function Drill.draw(self)
  if not self.idle then
    --draw main drill body
    local sx, sy = world_to_screen(self.pos.x, self.pos.y)
    local belt_pos = DRILL_MINI_BELT_MAP[self.rot]
    --trace(tick % 2)
    --sspr(DRILL_BURNER_SPRITE_ID + (DRILL_ANIM_TICK * 2), sx, sy, 0, 1, 0, self.rot, 2, 2)
    sspr(DRILL_BIT_ID, sx + 0 + (DRILL_BIT_TICK), sy + 5, 0, 1, 0, 0, 1, 1)
    sspr(DRILL_BURNER_SPRITE_ID, sx, sy, 0, 1, 0, 0, 2, 2)
    sspr(DRILL_MINI_BELT_ID + DRILL_ANIM_TICK, sx + belt_pos.x, sy + belt_pos.y, 0, 1, 0, self.rot, 1, 1)
  else
    local sx, sy = world_to_screen(self.pos.x, self.pos.y)
    local belt_pos = DRILL_MINI_BELT_MAP[self.rot]
    -- sspr(DRILL_BURNER_SPRITE_ID, sx, sy, 0, 1, 0, self.rot, 2, 2)
    -- sspr(DRILL_BIT_ID, sx, sy + 9, 0, 1, 0, self.rot + 1, 1, 1)
    sspr(DRILL_BURNER_SPRITE_ID, sx, sy, 0, 1, 0, 0, 2, 2)
    sspr(DRILL_BIT_ID, sx + 5, sy + 12, 0, 1, 0, 0, 1, 1)
    sspr(DRILL_MINI_BELT_ID, sx + belt_pos.x, sy + belt_pos.y, 0, 1, 0, self.rot, 1, 1)
  end
end

function Drill:return_all()
  if self.output.count > 0 then
    local result, stack = inv:add_item({id = self.output.id, count = self.output.count})
    if stack.count < self.output.count then
      sound('deposit')
      ui.new_alert(cursor.x, cursor.y, '+ ' .. self.output.count - stack.count .. ' ' .. ITEMS[self.output.id].fancy_name, 1000, 0, 6)
    end
    self.output.count = stack.count
  end
end

function Drill:deposit()
  return false
end

function Drill:request_deposit()
  return false
end

function Drill:item_request(id)
  --trace('DRILL: requested item id = ' .. tostring(id))
  if self.output.count < 1 then return false end
  if self.output.id == id or id == 'any' or
  (id == 'ore' and ITEMS[self.output.id].type == 'ore') or
  (id == 'fuel' and ITEMS[self.output.id].type == 'fuel') then
    self.output.count = self.output.count - 1
    return self.output.id
  end
  return false
end

function return_all()
  if self.output.count > 0 then
    return {id = self.output.id, count = self.output.count}
  end
end

function new_drill(pos, rot, tiles)
  local out_pos = DRILL_OUTPUT_MAP[rot]
  local output_key = pos.x + out_pos.x .. '-' .. pos.y + out_pos.y
  local newdrill = {pos = pos, rot = rot, field_keys = tiles, output_key = output_key, output = {id = 0, count = 0}}
  setmetatable(newdrill, {__index = Drill})
  return newdrill
end

FURNACE_ID = 488
FURNACE_FUEL_ICON = 291
FURNACE_ANIM_TICK = 0
FURNACE_ANIM_TICKRATE = 9
FURNACE_ANIM_TICKS = 2
FURNACE_TICKRATE = 5
FURNACE_BUFFER_INPUT = 50
FURNACE_BUFFER_OUTPUT = 100
FURNACE_BUFFER_FUEL = 50
FURNACE_SMELT_TIME = 3 * 60
FURNACE_COLORKEY = 6
FURNACE_FIRE_KEYS = {7,11,10}


Furnace = {
  x = 0,
  y = 0,
  type = 'stone_furnace',
  is_hovered = false,
  updated = false,
  drawn = false,
  item_id = 14,
  fuel_slots = FURNACE_BUFFER_FUEL,
  last_fuel = false,
  output_slots = FURNACE_BUFFER_SIZE,
  output_buffer = {id = 0, count = 0},
  input_buffer = {id = 0, count = 0},
  fuel_buffer = {id = 0, count = 0},
  dummy_keys = {},
  fuel_time = 0,
  smelt_timer = 0,
  ore_type = false,
  is_smelting = false,
  tickrate = 5,
}

function Furnace:draw_hover_widget()
  local sx, sy = cursor.x, cursor.y
  local offset = {x = 3, y = 3}
  local w, h = print('Stone Furnace', 0, -10, 0, false, 1, true) + 4, 50
  local x, y = clamp(sx + offset.x, 0, 240 - w - offset.x), clamp(sy + offset.y, 0, 136 - h - offset.y)
  --window fill and border
  ui.draw_panel(x, y, w, h, _, _, 'Stone Furnace', UI_BG)
  -- rectb(x, y, w, h, 9)
  -- rect(x + 1, y + 1, w - 2, h - 2, 8)
  --top bar for text
  rect(x + 1, y + 1, w - 2, 8, 9)
  prints('Stone Furnace', x + 2, y + 2, 0, 4)
  --furnace sprite icon
  self:draw_sprite(x + w/2 - 8, y + 15)
  --item slots
  box(x + 5, y + 18, 10, 10, 0, 9)
  box(x + w - 15, y + 18, 10, 10, 0, 9)
  box(x + w/2 - 5, y + 35, 10, 10, 0, 9)
  if self.input_buffer.count > 0 then
    draw_item_stack(x + 6, y + 19, self.input_buffer)
  end
  if self.output_buffer.count > 0 then
    draw_item_stack(x + w - 14, y + 19, self.output_buffer)
  end
  if self.fuel_buffer.count > 0 then
    draw_item_stack(x + w/2 - 3, y + 36, self.fuel_buffer)
  end
end

function Furnace:open()
  return {
    x = 163,
    y = 2,
    width = 74,
    height = 89,
    input  = {x = 4, y = 45, w = 10, h = 10},
    output = {x = 60, y = 45, w = 10, h = 10},
    fuel   = {x = 4, y = 68, w = 10, h = 10},
    close = function(self, sx, sy)
      -- 5x5 close button sprite
      local cx, cy, cw, ch = self.x + self.width - 9, self.y + 2, 5, 5
      if sx >= cx and sx < cx + cw and sy >= cy and sy < cy + ch then
        return true
      end
      return false
    end,
    ent_key = self.x .. '-' .. self.y,
    click = function(self, sx, sy)
      if self:is_hovered(sx, sy) then
        if self:close(sx, sy) then
          ui.active_window = nil
          return true
        end

        local ent = ENTS[self.ent_key]
        local stack = cursor.item_stack

        if hovered(cursor, {x = self.input.x + self.x, y = self.input.y + self.y, w = self.input.w, h = self.input.h}) then
          --item interaction
          if key(64) and ent.input_buffer.count > 0 then
            local old_count = ent.input_buffer.count
            local result, stack = inv:add_item({id = ent.input_buffer.id, count = ent.input_buffer.count})
            if result then
              ent.input_buffer.count = stack.count
              sound('deposit')
              ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.input_buffer.id].fancy_name, 1000, 0, 6)
              return true
            end
          end
          if cursor.type == 'pointer' then
            if ent.input_buffer.count > 0 then
              if cursor.r and ent.input_buffer.count > 1 then
                set_cursor_item({id = ent.input_buffer.id, count = math.ceil(ent.input_buffer.count/2)}, false)
                ent.input_buffer.count = floor(ent.input_buffer.count/2)
                return true
              else
                set_cursor_item({id = ent.input_buffer.id, count = ent.input_buffer.count}, false)
                ent.input_buffer.count = 0
                ent.input_buffer.id = 0
                return true
              end
            end
          elseif cursor.type == 'item' and cursor.item_stack.id == ent.input_buffer.id  or (ent.input_buffer.id == 0 and ITEMS[cursor.item_stack.id].type == 'ore') then
            if ITEMS[cursor.item_stack.id].required_tech and not TECH[ITEMS[cursor.item_stack.id].required_tech].completed then
              return false
            end
            local stack_size = ITEMS[cursor.item_stack.id].stack_size
            --try to combine stacks, leaving extra on cursor
            if key(64) then
              if ent.input_buffer.count > 0 and ent.input_buffer.id > 0 then
                local id = ent.input_buffer.id
                local result, stack = inv:add_item({id = ent.input_buffer.id, count = ent.input_buffer.count})
                if result then
                  ent.input_buffer.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[id].fancy_name, 1000, 0, 6)
                end
              end
              return true
            end
            ent.input_buffer.id = cursor.item_stack.id
            if cursor.r then
              if ent.input_buffer.count + 1 < stack_size then
                ent.input_buffer.count = ent.input_buffer.count + 1
                cursor.item_stack.count = cursor.item_stack.count - 1
                if cursor.item_stack.count < 1 then
                  set_cursor_item()
                end
                return true
              end
            else
              if cursor.item_stack.count + ent.input_buffer.count > stack_size then
                local old_count = ent.input_buffer.count
                ent.input_buffer.count = stack_size
                cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                return true
              else
                ent.input_buffer.count = ent.input_buffer.count + cursor.item_stack.count
                set_cursor_item()
                return true
              end
            end
          end
        elseif hovered(cursor, {x = self.output.x + self.x, y = self.output.y + self.y, w = self.output.w, h = self.output.h}) then

          --item interaction
          if cursor.type == 'pointer' then
            if key(64) and ent.output_buffer.count > 0 then
              local old_count = ent.output_buffer.count
              local result, stack = inv:add_item({id = ent.output_buffer.id, count = ent.output_buffer.count})
              if result then
                ent.output_buffer.count = stack.count
                sound('deposit')
                ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output_buffer.id].fancy_name, 1000, 0, 6)
                return true
              end
            elseif ent.output_buffer.count > 0 then
              if cursor.r and ent.output_buffer.count > 1 then
                set_cursor_item({id = ent.output_buffer.id, count = math.ceil(ent.output_buffer.count/2)}, false)
                ent.output_buffer.count = floor(ent.output_buffer.count/2)
                return true
              else
                set_cursor_item({id = ent.output_buffer.id, count = ent.output_buffer.count}, false)
                ent.output_buffer.count = 0
                return true
              end
            end
          elseif cursor.type == 'item' then
            local stack_size = ITEMS[cursor.item_stack.id].stack_size
            --try to combine stacks, leaving extra on cursor
            if key(64) then
              if ent.output_buffer.count > 0 then
                local result, stack = inv:add_item({id = ent.output_buffer.id, count = ent.output_buffer.count})
                if result then
                  ent.output_buffer.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output_buffer.id].fancy_name, 1000, 0, 6)
                end
              end
              return true
            end
          end
        elseif hovered(cursor, {x = self.fuel.x + self.x, y = self.fuel.y + self.y, w = self.fuel.w, h = self.fuel.h}) then
          --item interaction
          if cursor.type == 'pointer' then
            if key(64) and ent.fuel_buffer.count > 0 then
              local old_count = ent.fuel_buffer.count
              local result, stack = inv:add_item({id = ent.fuel_buffer.id, count = ent.fuel_buffer.count})
              if result then
                ent.fuel_buffer.count = stack.count
                sound('deposit')
                ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.fuel_buffer.id].fancy_name, 1000, 0, 6)
                return true
              end
            elseif ent.fuel_buffer.count > 0 then
              if cursor.r and ent.fuel_buffer.count > 1 then
                set_cursor_item({id = ent.fuel_buffer.id, count = math.ceil(ent.fuel_buffer.count/2)}, false)
                ent.fuel_buffer.count = floor(ent.fuel_buffer.count/2)
                return true
              else
                set_cursor_item({id = ent.fuel_buffer.id, count = ent.fuel_buffer.count}, false)
                ent.fuel_buffer.count = 0
                return true
              end
            end
          elseif cursor.type == 'item' and cursor.item_stack.id == ent.fuel_buffer.id  or (ent.fuel_buffer.id == 0 and ITEMS[cursor.item_stack.id].type == 'fuel') then
            if ITEMS[cursor.item_stack.id].required_tech and not TECH[ITEMS[cursor.item_stack.id].required_tech].completed then
              return false
            end
            local stack_size = ITEMS[cursor.item_stack.id].stack_size
            --try to combine stacks, leaving extra on cursor
            if key(64) then
              if ent.fuel_buffer.count > 0 then
                local result, stack = inv:add_item({id = ent.fuel_buffer.id, count = ent.fuel_buffer.count})
                if result then
                  ent.fuel_buffer.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.fuel_buffer.id].fancy_name, 1000, 0, 6)
                end
              end
              return true
            end
            ent.fuel_buffer.id = cursor.item_stack.id
            if cursor.r then
              if ent.fuel_buffer.count + 1 < stack_size then
                ent.fuel_buffer.count = ent.fuel_buffer.count + 1
                cursor.item_stack.count = cursor.item_stack.count - 1
                if cursor.item_stack.count < 1 then
                  set_cursor_item()
                end
                return true
              end
            else
              if cursor.item_stack.count + ent.fuel_buffer.count > stack_size then
                local old_count = ent.fuel_buffer.count
                ent.fuel_buffer.count = stack_size
                cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                return true
              else
                ent.fuel_buffer.count = ent.fuel_buffer.count + cursor.item_stack.count
                set_cursor_item()
                return true
              end
            end
          end
        end
      end
      return false
    end,
    is_hovered = function(self, x, y)
      return x >= self.x and x < self.x + self.width and y >= self.y and y < self.y + self.height and true or false
    end,
    draw = function(self)
      --trace('drawing furnace UI')
      local bg, fg = 8, 9
      local ent = ENTS[self.ent_key]
      if not ent then return end
      local input, output, fuel = ent.input_buffer, ent.output_buffer, ent.fuel_buffer
      local x, y, w, h = self.x, self.y, self.width, self.height
      local fx, fy = x + (w / 2) - 8, y + 19 --furnace icon screen pos
      --background window and border
      ui.draw_panel(x, y, w, h, bg, fg, 'Stone Furnace', UI_BG)
      -- --close button
       sspr(CLOSE_ID, x + w - 9, y + 2, 15)
      --input slot
      box(self.input.x + self.x, self.input.y + self.y, self.input.w, self.input.h, 0, 9)
      if ent.input_buffer.count > 0 then
        draw_item_stack(self.input.x + self.x + 1, self.input.y + self.y + 1, ent.input_buffer)
      end
       --self.input:draw(self.x, self.y, ent.input_buffer)
       --box(x + 4, y + 45, 10, 10, 0, fg)
       --prints(input.count .. '/' .. FURNACE_BUFFER_INPUT, x + 4, y + 57, 0, 4)
      if input.count > 0 then
        --sspr(ITEMS[input.id].sprite_id, x + 5, y + 46, ITEMS[input.id].color_key)
      end
      --smelting progress bar
      box(x + 16, y + 47, 42, 5, 0, fg)
      if ent.smelt_timer > 0 then
        rect(x + 17, y + 48, 40 - remap(ent.smelt_timer, 0, FURNACE_SMELT_TIME, 0, 40), 3, 6)
      end
      --output slot
      box(self.output.x + self.x, self.output.y + self.y, self.output.w, self.output.h, 0, 9)
      if ent.output_buffer.count > 0 then
        draw_item_stack(self.output.x + self.x + 1, self.output.y + self.y + 1, ent.output_buffer)
      end
      --self.output:draw(self.x, self.y, ent.output_buffer)
      --box(x + w - 14, y + 45, 10, 10, 0, fg)
      local text_width = print(output.count .. '/' .. FURNACE_BUFFER_OUTPUT, 0, -10, 0, false, 1, true)
      --prints(output.count .. '/' .. FURNACE_BUFFER_OUTPUT, x + w - 4 - text_width, y + 57, 0, 4)
      --if output.count > 0 then sspr(ITEMS[output.id].sprite_id, x + w - 13, y + 46, ITEMS[output.id].color_key) end
      -- --divider
      line(x + 4, y + 65, x + w - 5, y + 65, fg)
      -- --fuel slot
      --rectb(x + 4, y + 68, 10, 10, fg)
      box(self.fuel.x + self.x, self.fuel.y + self.y, self.fuel.w, self.fuel.h, 0, 9)
      if ent.fuel_buffer.count > 0 then
        draw_item_stack(self.fuel.x + self.x + 1, self.fuel.y + self.y + 1, ent.fuel_buffer)
      end
      --self.fuel:draw(self.x, self.y, ent.fuel_buffer)
      if fuel.count > 0 then
        --sspr(ITEMS[fuel.id].sprite_id, x + 5, y + 69, ITEMS[fuel.id].color_key)
      else
        sspr(FURNACE_FUEL_ICON, x + 5, y + 69, -1)
      end
      -- --fuel progress bar
      box(x + 16, y + 71, 42, 5, 0, fg)
      if ent.fuel_time > 0 and ent.last_fuel then
        rect(x + 17, y + 72, remap(ent.fuel_time, 0, ITEMS[ent.last_fuel].fuel_time, 0, 40), 3, 2)
      end
      --prints(fuel.count .. '/' .. FURNACE_BUFFER_FUEL, x + 4, y + 80, 0, 4)
      -- --terrain background-------------------------
      local sprite_id = FURNACE_ID
      for i = -1, 2 do
        for j = -3, 4 do
          local tile = TileMan.tiles[ent.y + i][ent.x + j]
          local tile_id = tile.sprite_id
          if tile.ore then
            sspr(biomes[tile.biome].tile_id_offset, fx + (j*8), fy + (i*8), -1, 1, 0, tile.rot)
            sspr(ores[tile.ore].tile_id, fx + (j*8), fy + (i*8), 4, 1, 0, tile.rot)
          elseif tile.is_border and tile.biome == 1 then
            sspr(WATER_SPRITE, fx + (j*8), fy + (i*8), -1, 1, 0, tile.rot)
            sspr(tile.sprite_id, fx + (j*8), fy + (i*8), 0, 1, 0, tile.rot)
          else
            sspr(tile.sprite_id, fx + (j*8), fy + (i*8), -1, 1, 0, tile.rot)
          end
        end
      end
      -- --terrain border
      rectb(fx - 25, fy - 8, 66, 33, fg)
      --furnace graphic
      ent:draw_sprite(fx, fy, ent.is_smelting)
      local hov = self:is_hovered(cursor.x, cursor.y)
      if hov and cursor.type == 'item' and cursor.item_stack.id > 0 then
        draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
      end

      if hov then
        local slots = {[1] = self.input, [2] = self.output, [3] = self.fuel}
        for k, v in ipairs(slots) do
          if hovered({x = cursor.x, y = cursor.y}, {x = v.x + self.x, y = v.y + self.y, w = v.w, h = v.h}) then
            ui.highlight(self.x + v.x, self.y + v.y, 8, 8, false, 3, 4)
          end
        end
      end

    end
  }
end

function Furnace:draw_sprite(x, y, smelting)
  local color_keys = {2, 3, 4}
  local fire_keys = {7,11,10}
  sspr(FURNACE_ID, x, y, FURNACE_COLORKEY, 1, 0, 0, 2, 2)
  if self.is_smelting or smelting then
    sspr(490, x + 7, y + 12, 0)
  end
end

function Furnace:update()
  --update fuel ticks
  if self.fuel_time > 0 then
    self.fuel_time = self.fuel_time - FURNACE_TICKRATE
  end

  if self.fuel_time <= 0 then
    --if we run out of fuel_time, check fuel_buffer to re-fuel self
    if self.is_smelting then
      if self.fuel_buffer.count > 0 then
        self.fuel_buffer.count = self.fuel_buffer.count - 1
        self.fuel_time = ITEMS[self.fuel_buffer.id].fuel_time
        self.last_fuel = self.fuel_buffer.id
        if self.fuel_buffer.count == 0 then
          self.fuel_buffer.id = 0
        end
      else
        --otherwise we have ran out of fuel completely, so shut-down
        self.is_smelting = false
      end
    end
  end

  if self.is_smelting then
    --update smelting countdown timer
    self.smelt_timer = self.smelt_timer - FURNACE_TICKRATE
    if self.smelt_timer <= 0 then
      --smelting operation completed
      --pop last item from output_buffer to input_buffer
      local smelted_ore = self.input_buffer.count > 0 and ITEMS[self.input_buffer.id].smelted_id or false
      self.is_smelting = false
      if not smelted_ore then
        return
      end
      if self.output_buffer.count == 0 then
        self.output_buffer.id = smelted_ore
        self.input_buffer.count = self.input_buffer.count - 1
        self.output_buffer.count = self.output_buffer.count + 1
      elseif self.output_buffer.count < ITEMS[self.output_buffer.id].stack_size then
        self.input_buffer.count = self.input_buffer.count - 1
        self.output_buffer.count = self.output_buffer.count + 1
      end
      return
    end
  end


    --check for incoming ore
  if not self.is_smelting and self.input_buffer.count > 0 and self.output_buffer.count < FURNACE_BUFFER_OUTPUT and (self.fuel_time > 0 or self.fuel_buffer.count > 0) then
    self.is_smelting = true
    self.smelt_timer = FURNACE_SMELT_TIME
  end
  if self.input_buffer.count == 0 and self.output_buffer.count == 0 then
    self.input_buffer.id = 0
    self.output_buffer.id = 0
    self.ore_type = false
  end
end

function Furnace:draw()
  local sx, sy = world_to_screen(self.x, self.y)
  self:draw_sprite(sx, sy)
  --if self.is_hovered then self:draw_hover_widget() end
end

function Furnace:deposit_stack(stack)
  local item = ITEMS[stack.id]
  if item.type == 'fuel' then
    if self.fuel_buffer.id == 0 or self.fuel_buffer.id == stack.id then
      if self.fuel_buffer.count + stack.count <= ITEMS[stack.id].stack_size then
        --add stack to fuel slot, return true\
        self.fuel_buffer.id = stack.id
        self.fuel_buffer.count = self.fuel_buffer.count + stack.count
        return true, {id = 0, count = 0}
      elseif self.fuel_buffer.count + stack.count > ITEMS[self.fuel_buffer.id].stack_size then
        --fill slot count, return partial stack
        local remaining = stack.count - (ITEMS[self.fuel_buffer.id].stack_size - self.fuel_buffer.count)
        self.fuel_buffer.count = ITEMS[self.fuel_buffer.id].stack_size
        stack.count = remaining
        return true, stack
      end
    end
  elseif item.type == 'ore' then
    if item.required_tech and not TECH[item.required_tech].completed then
      return false, stack
    end
    if self.input_buffer.id == 0 or self.input_buffer.id == stack.id then
      if self.input_buffer.count + stack.count <= ITEMS[stack.id].stack_size then
        --add stack to input slot, return true\
        self.input_buffer.id = stack.id
        self.input_buffer.count = self.input_buffer.count + stack.count
        return true, {id = 0, count = 0}
      elseif self.input_buffer.count + stack.count > ITEMS[self.input_buffer.id].stack_size then
        --fill slot count, return partial stack
        local remaining = stack.count - (ITEMS[self.input_buffer.id].stack_size - self.input_buffer.count)
        self.input_buffer.count = ITEMS[self.input_buffer.id].stack_size
        stack.count = remaining
        return true, stack
      end
    end
  end
  return false, stack
end

function Furnace:request()
  if self.fuel_buffer.count < 5 and self.input_buffer.count > 0 then
    local desired_fuel = 'any'
    if self.fuel_buffer.count > 0 then
      desired_fuel = ITEMS[self.fuel_buffer.id].name
    end
    return 'fuel', desired_fuel
  elseif self.input_buffer.count < 5 then
    local desired_ore = 'any'
    if self.input_buffer.count > 0 then
      desired_ore = ITEMS[self.input_buffer.id].name
    end
    return 'ore', desired_ore
  end
  return false
end

function Furnace:request_output(keep)
  if self.output_buffer.count > 0 then
    local id = self.output_buffer.id
    if self.output_buffer.count < 0 then
      --set ore_type to nil?
      --self.output_buffer.id = 0
    end
    if keep then
      return true
    else
      self.output_buffer.count = self.output_buffer.count - 1
      return id
    end
  end
  return false
end

function Furnace:request_deposit(inserter)
  if self.fuel_buffer.count < 5 then
    if self.input_buffer.count < 1 and self.fuel_buffer.count > 1  then
      return self.input_buffer.id > 0 and self.input_buffer.id or 'ore'
    else
      return self.fuel_buffer.id > 0 and self.fuel_buffer.id or 'fuel'
    end
  end
  if self.input_buffer.count < 5 then
    if self.fuel_buffer.count < 1 and self.fuel_buffer.count > 1  then
      return self.fuel_buffer.id > 0 and self.fuel_buffer.id or 'fuel'
    else
      return self.input_buffer.id > 0 and self.input_buffer.id or 'ore'
    end
  end
  return false
end

function Furnace:deposit(id)
  local item = ITEMS[id]
  if not item or item.type ~= 'fuel' and not item.smelted_id then return false end
  if item.type == 'fuel' then
    if self.fuel_buffer.id == id or self.fuel_buffer.id == 0 then
      self.fuel_buffer.id = id
      if self.fuel_buffer.count < ITEMS[id].stack_size then
        self.fuel_buffer.count = self.fuel_buffer.count + 1
        return true
      end
    end
  elseif ((item.required_tech and TECH[item.required_tech].completed) or not item.required_tech) and (self.input_buffer.id == id or self.input_buffer.id == 0) then
    self.input_buffer.id = id
    if self.input_buffer.count < ITEMS[id].stack_size then
      self.input_buffer.count = self.input_buffer.count + 1
      return true
    end
  end
  return false
end

function Furnace:item_request(id)
  if self.output_buffer.id < 1 or self.output_buffer.count < 1 then return false end
  if self.output_buffer.id == id or id == 'any' or ITEMS[self.output_buffer.id].type == id then
    local item_id = self.output_buffer.id
    self.output_buffer.count = self.output_buffer.count - 1
    if self.output_buffer.count == 0 and self.input_buffer == 0 then
      self.output_buffer.id = 0
    end
    return item_id
  end
  return false
end

function Furnace:return_all()
  local x, y = cursor.x, cursor.y
  if self.output_buffer.count > 0 then
    local result, stack = inv:add_item({id = self.output_buffer.id, count = self.output_buffer.count})
    if stack.count < self.output_buffer.count then
      sound('deposit')
      ui.new_alert(x, y, '+' .. self.output_buffer.count - stack.count .. ' ' .. ITEMS[self.output_buffer.id].fancy_name, 1500, 0, 5)
      y = y + 7
    end
    self.output_buffer.count = stack.count
  end
  if self.input_buffer.count > 0 then
    local result, stack = inv:add_item({id = self.input_buffer.id, count = self.input_buffer.count})
    if stack.count < self.input_buffer.count then
      sound('deposit')
      ui.new_alert(x, y, '+' .. self.input_buffer.count - stack.count .. ' ' .. ITEMS[self.input_buffer.id].fancy_name, 1500, 0, 5)
      y = y + 7
    end
    self.input_buffer.count = stack.count
  end
  if self.fuel_buffer.count > 0 then
    local result, stack = inv:add_item({id = self.fuel_buffer.id, count = self.fuel_buffer.count})
    if stack.count < self.fuel_buffer.count then
      sound('deposit')
      ui.new_alert(x, y, '+' .. self.fuel_buffer.count - stack.count .. ' ' .. ITEMS[self.fuel_buffer.id].fancy_name, 1500, 0, 5)
    end
    self.fuel_buffer.count = stack.count
  end
end

function new_furnace(x, y, keys)
  local new_furnace = {
    x = x,
    y = y,
    type = 'stone_furnace',
    is_hovered = false,
    updated = false,
    drawn = false,
    fuel_slots = FURNACE_BUFFER_FUEL,
    output_slots = FURNACE_BUFFER_SIZE,
    output_buffer = {id = 0, count = 0},
    input_buffer = {id = 0, count = 0},
    fuel_buffer = {id = 0, count = 0},
    dummy_keys = keys,
    fuel_time = 0,
    smelt_timer = 0,
    ore_type = false,
    is_smelting = false,
  }
  setmetatable(new_furnace, {__index = Furnace})
  return new_furnace
end

CRAFTER_ID = 312
CRAFTER_TICKRATE = 5
CRAFTER_TIME_ID = 337
CRAFTER_ANIM_FRAME = 0
CRAFTER_ANIM_RATE = 5
CRAFTER_ANIM_DIR = 1

local Crafter = {
  x = 0,
  y = 0,
  id = 19,
  item_id = 19,
  type = 'assembly_machine',
  is_hovered = false,
  updated = false,
  drawn = false,
  state = 'ready',
  input = {},
  output = {},
  requests = false,
  recipe = false,
  progress = 0,
  tickrate = 5,
}

function Crafter:draw_hover_widget(sx, sy)
  sx, sy = sx or cursor.x + 5, sy or cursor.y + 5
  if not self.recipe then
    return
  end
  local w = 73
  local h = 74
  local x = clamp(sx, 1, 240 - w - 1)
  local y = clamp(sy, 1, 136 - h - 1)
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, 'Assembly Machine', UI_SH)
  ui.progress_bar(math.min(1.0, self.progress/self.recipe.crafting_time), x + w/2 - 30, y + 12, 60, 6, UI_BG, UI_FG, 6, 0)
  prints('Input', x + w/2 - 12, y + h - 24)
  for k, v in ipairs(self.input) do
    box(x + w/2 - ((#self.input*13)/2) + (k-1)*13, y + h - 15, 10, 10, 8, 9)
    if v.id ~= 0 and v.count > 0 then
      draw_item_stack(x + w/2 - ((#self.input*13)/2) + (k-1)*13 + 1, y + h - 15 + 1, v)
    end
  end
  --draw output items
  prints('Output', x + w/2 - 12, y + 19)
  box(x + w/2 - 6, y + 27, 10, 10, 8, 9)
  for k, v in ipairs(self.recipe.ingredients) do
    draw_item_stack(x + 10 + (k-1)*15 + 1, y + h - 35 + 1, v, true)
    if k < #self.recipe.ingredients then
      prints('+', x + 10 + (k-1)*15 + 1 + 10, y + h - 34 + 1)
    else
      prints('=', x + 10 + (k-1)*15 + 1 + 10, y + h - 34 + 1)
    end
  end
  draw_item_stack(x + 12 + #self.recipe.ingredients*15, y + h - 35 + 1, {id = self.recipe.id, count = self.recipe.count}, true)
  if self.output.count > 0 then
    draw_item_stack(x + w/2 - 5, y + 28, {id = self.output.id, count = self.output.count})
  end
end

function Crafter:draw()
  local x, y = world_to_screen(self.x, self.y)
  local offset = 0
  local blink = tick % 60 < 30
  sspr(CRAFTER_ID, x, y, 0, 1, 0, 0, 3, 3)
  if self.recipe and alt_mode then
    sspr(ITEMS[self.recipe.id].sprite_id, x + 6, y + 5, ITEMS[self.recipe.id].color_key)
  end
  if self.state == 'crafting' then
    if blink then
      sspr(339, x + 16, y + 15, 0)
      --rect(x + 16, y + 15, 2, 2, 7)
    end
    offset = CRAFTER_ANIM_FRAME
    --pix(sx + 6, sy + 5, blink and 5 or 7)
    --line(sx + 6, sy + 9, sx + 6 + remap(self.progress, 0, self.recipe.crafting_time, 0, 12), sy + 9, 5)

  end
  sspr(348, x + 7 + offset, y + 12, 0)
  sspr(348, x + 14, y + (6 - offset), 0, 1, 0, 3)
  if self.state == 'idle' then
    pal({4,2,4,3,6,3})
    sspr(339, x + 16, y + 15, 0)
    pal()
    --pix(sx + 11, sy + 5, blink and 0 or 3)
  end
  if self.state == 'ready' then
    pal({4,2,5,2,6,2})
    sspr(339, x + 16, y + 15, 0)
    pal()
    --pix(sx + 16, sy + 5, blink and 0 or 2)
  end
end

function Crafter:update()
  if self.recipe then
    self:update_requests()
    if self.state == 'ready' or self.state == 'idle' then
      if self.output.count >= self.recipe.count * 5 then
        self.state = 'ready'
        return
      end
      for i = 1, #self.recipe.ingredients do
        if self.input[i].count < self.recipe.ingredients[i].count then
          return
        end
      end
    end

    self.state = 'crafting'

    --if crafting in progress, update it
    self.progress = self.progress + CRAFTER_TICKRATE
    for i = 1, #self.recipe.ingredients do
      if self.input[i].count < self.recipe.ingredients[i].count then
        self.state = 'ready'
        return
      end
    end

    if self.progress >= self.recipe.crafting_time then
      --we have reached full progress, so check for ingredients to make new item
      self.progress = 0
      self.state = 'ready'
      for i = 1, #self.recipe.ingredients do
        self.input[i].count = self.input[i].count - self.recipe.ingredients[i].count
      end
      self.output.count = self.output.count + self.recipe.count
    end
  end
end

function Crafter:open()
  if not self.recipe then
    -------------NO recipe--------------------
    return {
      width = 73,
      height = 55,
      x = 73,
      y = 18,
      bg = 8,
      fg = 9,
      close = function(self, sx, sy)
        -- 5x5 close button sprite
        local cx, cy, cw, ch = self.x + self.width - 7, self.y + 2, 5, 5
        if sx >= cx and sx < sx + cw and sy >= cy and sy < cy + ch then
          return true
        end
        return false
      end,
      ent_key = self.x .. '-' .. self.y,
      click = function(self, sx, sy)
        --check for close-button
        if self:close(sx, sy) then
          craft_menu.current_output = 'player'
          ui.active_window = false
          return true
        end
        --if no recipe, check the 'set-recipe' button
        local width = print('Select a recipe', 0, -10, 0, false, 1, true) + 4
        local btn = {x = self.x + ((width + 4)/2) - width/2 - 2, y = self.y + 32, w = width + 4, h = 9}
        local x, y, w, h = btn.x, btn.y, btn.w, btn.h
        if sx >= x and sx < x + w and sy >= y and sy < sy + h then
          --open recipe selection widget
          ui.active_window = false
          --ui.assembly_recipe_widget(self)
          craft_menu.current_output = self.ent_key
          toggle_crafting(true)
          return true
        end
        return false
      end,

      is_hovered = function(self, x, y)
        return x >= self.x and x < self.x + self.width and y >= self.y and y < self.y + self.height and true or false
      end,
      draw = function(self)
        local ent = ENTS[self.ent_key]
        if not ent then self = nil return end
        local input, output, fuel = ent.input_buffer, ent.output_buffer, ent.fuel_buffer
        local x, y, w, h, bg, fg = self.x, self.y, self.width, self.height, self.bg, self.fg
        local width = print('Select a recipe', 0, -10, 0, false, 1, true)
        local c = cursor          
        local btn = {x = x + w/2 - width/2 - 2, y = y + 32, w = width + 4, h = 9}
        btn.color = c.x >= btn.x and c.x < btn.x + btn.w and c.y >= btn.y and c.y < btn.y + btn.h and 9 or 8
        --background window and border
        ui.draw_panel(x, y, w, h, bg, fg, ITEMS[ent.id].fancy_name)
        --input input icon, and item count----------------------------------------
        box(btn.x, btn.y, btn.w, btn.h, btn.color, 9)
        prints('Select a recipe', btn.x + 2, btn.y + 2, 0, 4)
        --assembly machine graphic-and terrain background-------------------------
        sspr(483, x + w/2 - 4, y + 16, 1, 1, 0, 0, 1, 1)
        sspr(CLOSE_ID, x + w - 7, y + 2, 15)
      end
    }
  else
    ------------HAS recipe--------------------
    return {
      x = 240 - 85,
      y = 1,
      w = 80,
      h = 74,
      ent_key = self.x .. '-' .. self.y,
      close = function(self, sx, sy)
        local btn = {x = self.x + self.w - 9, y = self.y + 1, w = 5, h = 5}
        if sx >= btn.x and sy < btn.x + btn.w and sy >= btn.y and sy <= btn.y + btn.h then
          return true
        end
        return false
      end,
      draw = function(self)
        local ent = ENTS[self.ent_key]
        ui.draw_panel(self.x, self.y, self.w, self.h, UI_BG, UI_FG, 'Assembly Machine', UI_SH)
        ui.progress_bar(math.min(1.0, ent.progress/ent.recipe.crafting_time), self.x + self.w/2 - 30, self.y + 12, 60, 6, UI_BG, UI_FG, 6, 0)
        sspr(CLOSE_ID, self.x + self.w - 9, self.y + 2, 15)
        prints('Input', self.x + self.w/2 - 12, self.y + self.h - 24)
        for k, v in ipairs(ent.input) do
          box(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, self.y + self.h - 15, 10, 10, 8, 9)
          if v.id ~= 0 and v.count > 0 then
            draw_item_stack(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13 + 1, self.y + self.h - 15 + 1, v)
          end
        end
      --draw output items
        prints('Output', self.x + self.w/2 - 12, self.y + 19)
        box(self.x + self.w/2 - 6, self.y + 27, 10, 10, 8, 9)
        --draw recipe icons
        local total_width = (#ent.recipe.ingredients + 1) * 15
        local start_x = (self.x + self.w/2) - (total_width/2)
        for k, v in ipairs(ent.recipe.ingredients) do
          draw_item_stack(start_x + (k-1)*15 + 1, self.y + self.h - 35 + 1, v, true)
          if k < #ent.recipe.ingredients then
            prints('+', start_x + (k-1)*15 + 1 + 10, self.y + self.h - 34 + 1)
          else
            prints('=', start_x + (k-1)*15 + 1 + 10, self.y + self.h - 34 + 1)
          end
        end
        draw_item_stack(start_x + total_width - 12, self.y + self.h - 35 + 1, {id = ent.recipe.id, count = ent.recipe.count}, true)
        if ent.output.count > 0 then
          draw_item_stack(self.x + self.w/2 - 5, self.y + 28, {id = ent.output.id, count = ent.output.count})
        end
        if hovered(cursor, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
          ui.highlight(self.x + self.w/2 - 6, self.y + 27, 8, 8, false, 3, 4)
          draw_recipe_widget(cursor.x + 5, cursor.y + 5, ent.output.id)
        end
        --draw cursor item
        if self:is_hovered(cursor.x, cursor.y) and cursor.type == 'item' then
          draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
        end
        --input slots hover
        for k, v in ipairs(ent.input) do
          if hovered(cursor, {x = self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, y = self.y + self.h - 15, w = 10, h = 10}) then
            ui.highlight(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, self.y + self.h - 15, 8, 8, false, 3, 4)
            if v.id ~= 0 then draw_recipe_widget(cursor.x + 5, cursor.y + 5, v.id) end
          end
        end
      end,
      click = function(self, sx, sy)
        local ent = ENTS[self.ent_key]
        if self:close(sx, sy) then
          ui.active_window = nil
          return true
        end
        for k, v in ipairs(ent.input) do
          if v.id ~= 0 and hovered(cursor, {x = self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, y = self.y + self.h - 15, w = 10, h = 10}) then
            local stack_size = ITEMS[ent.output.id].stack_size
            --item interaction
            -----------------------------------------------------------------------------------------------------
            if cursor.type == 'pointer' then
              if key(64) then
                local old_count = v.count
                local result, stack = inv:add_item({id = v.id, count = v.count})
                if result then
                  v.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                  return true
                end
              elseif v.count > 0 then
                if cursor.r and v.count > 1 then
                  set_cursor_item({id = v.id, count = math.ceil(v.count/2)}, false)
                  v.count = math.floor(v.count/2)
                  return true
                else
                  set_cursor_item({id = v.id, count = (v.count)}, false)
                  v.count = 0
                  return true
                end
              end
            elseif cursor.type == 'item' and cursor.item_stack.id == v.id then
              --try to combine stacks, leaving extra on cursor
              if key(64) then
                if v.count > 0 then
                  local old_count = v.count
                  local result, stack = inv:add_item({id = v.id, count = v.count})
                  if result then
                    v.count = stack.count
                    sound('deposit')
                    ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                  end
                end
                return true
              end
              if cursor.r then
                if v.count + 1 < stack_size then
                  v.count = v.count + 1
                  cursor.item_stack.count = cursor.item_stack.count - 1
                  if cursor.item_stack.count < 1 then
                    set_cursor_item()
                  end
                  return true
                end
              else
                if cursor.item_stack.count + v.count > stack_size then
                  local old_count = v.count
                  v.count = stack_size
                  cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                  return true
                else
                  v.count = v.count + cursor.item_stack.count
                  set_cursor_item()
                  return true
                end
              end
            end
            --------------------------------------------------------------------------------------------
          end
        end
        --check output slot
        if ent.output.count > 0 and cursor.type == 'pointer' and hovered({x = sx, y = sy}, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
          if key(64) then
            local old_count = ent.output.count
            local result, stack = inv:add_item({id = ent.output.id, count = ent.output.count})
            if result then
              ent.output.count = stack.count
              ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output.id].fancy_name, 1000, 0, 6)
              sound('deposit')
              return true
            end
          else
            if cursor.r and ent.output.count > 1 then
              set_cursor_item({id = ent.output.id, count = math.ceil(ent.output.count/2)}, false)
              ent.output.count = math.floor(ent.output.count/2)
              return true
            else
              set_cursor_item({id = ent.output.id, count = (ent.output.count)}, false)
              ent.output.count = 0
              return true
            end
          end
        end
        return false
      end,
      is_hovered = function(self, x, y)
        return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
      end,
    }
  end
end

function Crafter:set_recipe(item)
  self.recipe = item.recipe
  for i = 1, #self.recipe.ingredients do
    self.input[i].id = self.recipe.ingredients[i].id
  end
  self.output.id = self.recipe.id
  self.output.count = 0
  self.requests = {}
  for i = 1, #self.recipe.ingredients do
    self.requests[i] = {[1] = true, [2] = false}
    --[1] = 'do I need this item'
    --[2] = 'is an inserter currently delivering this'
  end
end

function Crafter:update_requests()
  for i = 1, #self.requests do
    --if ingredients are low, request more items
    if self.input[i].count < self.recipe.ingredients[i].count*2 then
      self.requests[i][1] = true
    end
    --self.requests[i][2] = false
  end
end

function Crafter:get_request()
  for i = 1, #self.requests do
    -- check if inserter is already dispatched for this item
    if self.requests[i][1] and not self.requests[i][2] then
      return self.recipe.ingredients[i].id
    end
  end
  return false
end

function Crafter:assign_delivery(id)
  for k, v in ipairs(self.recipe.ingredients) do
    if v.id == id then
      self.requests[k][2] = true
      --now, an inserter has been dispatched to retrieve this item
      --freeing up other possible inserters for different tasks
      return
    end
  end
end

function Crafter:request_deposit()
  if not self.recipe then return false end
  return self:get_request()
end

function Crafter:deposit(id)
  if not self.recipe then return false end
  for k, v in ipairs(self.recipe.ingredients) do
    if id == self.input[k].id then
      self.input[k].count = self.input[k].count + 1
      self.requests[k][2] = false
      if self.input[k].count >= v.count*2 then
        self.requests[k][1] = false
      end
      return true
    end
  end
  return false
end

function Crafter:item_request(id)
  if not self.recipe then return false end
  if self.output.count > 0 and (self.output.id == id or id == 'any') then
    self.output.count = self.output.count - 1
    return self.output.id
  end
  return false
end

function Crafter:deposit_stack(stack)
  if self.recipe then
    for i = 1, #self.recipe.ingredients do
      local max_stack_per_slot = ITEMS[self.recipe.ingredients[i].id].stack_size
      if self.recipe.ingredients[i].id == stack.id then
        if self.input[i].count + stack.count <= max_stack_per_slot then
          self.input[i].count = self.input[i].count + stack.count
          self.input[i].id = stack.id
          self.state = 'ready'
          -- sound('deposit')
          -- ui.new_alert(cursor.x, cursor.y, stack.count .. ' ' .. ITEMS[stack.id].fancy_name, 1000, 0, 11)
          return true, {id = 0, count = 0}
        elseif self.input[i].count < max_stack_per_slot and self.input[i].count + stack.count > max_stack_per_slot then
          local diff = max_stack_per_slot - self.input[i].count
          self.input[i].count = max_stack_per_slot
          self.input[i].id = stack.id
          self.state = 'ready'
          -- sound('deposit')
          -- ui.new_alert(cursor.x, cursor.y, stack.count .. ' ' .. ITEMS[stack.id].fancy_name, 1000, 0, 11)
          return true, {id = stack.id, count = stack.count - diff}
        end
      end
    end
  end
  return false, {id = stack.id, count = stack.count}
end

function Crafter:return_all()
  if not self.recipe then return end
  for k, v in ipairs(self.input) do
    if v.count > 0 then
      local result, stack = inv:add_item(v)
      if stack.count < v.count then
        sound('deposit')
        ui.new_alert(cursor.x, cursor.y, '+' .. v.count - stack.count .. ' ' .. ITEMS[v.id].fancy_name, 1500, 0, 5)
      end
      v.count = stack.count
    end
  end
  if self.output.count > 0 then
    local result, stack = inv:add_item({id = self.output.id, count = self.output.count})
    if self.output.count > stack.count then
      sound('deposit')
      ui.new_alert(cursor.x, cursor.y, '+' .. self.output.count - stack.count .. ' ' .. ITEMS[self.output.id].fancy_name, 1500, 0, 5)
    end
    self.output.count = stack.count
  end
end

function new_assembly_machine(wx, wy)
  local obj = {x = wx, y = wy}
  obj.output = {id = 0, count = 0, sprite = 0, stack_size = 0}
  obj.input = {
    [1] = {id = 0, count = 10},
    [2] = {id = 0, count = 0},
    [3] = {id = 0, count = 0},
    [4] = {id = 0, count = 0},
  }
  setmetatable(obj, {__index = Crafter})
  return obj
end

LAB_ID = 396
LAB_TICKRATE = 5
LAB_ANIM_TICKRATE = 0
LAB_ANIM_TICK = 0

local Lab = {
  x = 0,
  y = 0,
  item_id = 22,
  type = 'research_lab',
  input = {},
  dummy_keys = {},
  requests = {},
  progress = 0,
  tickrate = 5,
}

function Lab:open()
  return {
    x = 240 - 83 - 2,
    y = 1,
    w = 83,
    h = 66,
    ent_key = self.x .. '-' .. self.y,
    close = function(self, sx, sy)
      local btn = {x = self.x + self.w - 9, y = self.y + 1, w = 5, h = 5}
      if sx >= btn.x and sy < btn.x + btn.w and sy >= btn.y and sy <= btn.y + btn.h then
        return true
      end
      return false
    end,
    draw = function(self)
      local txt = ITEMS[ENTS[self.ent_key].id].fancy_name
      local txt2 = current_research and TECH[AVAILABLE_TECH[current_research]].name or 'No Active Research'
      local ent = ENTS[self.ent_key]
      ui.draw_panel(self.x, self.y, self.w, self.h, UI_BG, UI_FG, 'Research Lab', UI_SH)
      --box(self.x, self.y, self.w, self.h, 8, 9)
      --rect(self.x + 1, self.y + 1, self.w - 2, 9, 9)
      --close button
      sspr(CLOSE_ID, self.x + self.w - 9, self.y + 2, 15)
      prints(txt, self.x + self.w/2 - print(txt, 0, -10, 0, false, 1, true)/2, self.y + 2, 0, 4)
      prints(txt2, self.x + self.w/2 - print(txt2, 0, -10, 0, false, 1, true)/2, self.y + 12, 0, 4)
      for i = 1, 4 do
        box(self.x + 14 + (i - 1)*13, self.y + 50, 10, 10, 0, 9)
        if ent.input[i].count > 0 then
          draw_item_stack(self.x + 15 + (i - 1)*13, self.y + 51, ent.input[i])
        end
      end
      --progress bar
      --box(self.x + 10, self.y + 20, self.w - 20, 6, 0, 9)
      local time = current_research and TECH[AVAILABLE_TECH[current_research]].time or 0
      ui.progress_bar(ent.progress/(time * 60), self.x + 10, self.y + 20, self.w - 20, 6, UI_BG, UI_FG, 6, 2)

      if self:is_hovered(cursor.x, cursor.y) and cursor.type == 'item' then
        draw_item_stack(cursor.x + 5, cursor.y + 5, cursor.item_stack)
      end
      for i = 1, 4 do
        if hovered(cursor, {x = self.x + 14 + (i - 1)*13, y = self.y + 50, w = 10, h = 10}) then
          ui.highlight(self.x + 13 + (i - 1)*13, self.y + 49, 10, 10, false, 3, 4)
        end
      end
    end,
    click = function(self, sx, sy)
      local ent = ENTS[self.ent_key]
      if self:close(sx, sy) then
        ui.active_window = nil
        return true
      end
      for i = 1, 4 do
        if hovered(cursor, {x = self.x + 14 + (i - 1)*13, y = self.y + 50, w = 10, h = 10}) then
          -- ui.highlight(self.x + 13 + (i - 1)*13, self.y + 49, 10, 10, false, 3, 4)
          
          --item interaction
          if cursor.type == 'pointer' then
            if key(64) then
              local old_count = ent.input[i].count
              local result, stack = inv:add_item(ent.input[i])
              if result then
                ent.input[i].count = stack.count
                sound('deposit')
                ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.input[i].id].fancy_name, 1000, 0, 6)
                return true
              end
            else
              if ent.input[i].count > 0 then
                if cursor.r then
                  cursor.item_stack.count = math.ceil(ent.input[i].count/2)
                  ent.input[i].count = floor(ent.input[i].count/2)
                else
                  cursor.item_stack.count = ent.input[i].count
                  ent.input[i].count = 0
                end
                cursor.type = 'item'
                cursor.item_stack.id = ent.input[i].id
                return true
              end

            end
          elseif cursor.type == 'item' then
            local stack_size = ITEMS[ent.input[i].id].stack_size
            if cursor.item_stack.id == ent.input[i].id then
              if cursor.r then
                if ent.input[i].count < stack_size then
                  ent.input[i].count = ent.input[i].count + 1
                  cursor.item_stack.count = cursor.item_stack.count - 1
                  if cursor.item_stack.count < 1 then set_cursor_item() end
                end
              else
                if ent.input[i].count + cursor.item_stack.count <= stack_size then
                  ent.input[i].count = ent.input[i].count + cursor.item_stack.count
                  cursor.type = 'pointer'
                  cursor.item_stack.id = 0
                  cursor.item_stack.count = 0
                elseif ent.input[i].count + cursor.item_stack.count > stack_size then
                  local old_count = ent.input[i].count
                  ent.input[i].count = stack_size
                  cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                end
              end

            end
          end

        end
      end
      return false
    end,
    is_hovered = function(self, x, y)
      return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
    end,
  }
end

function Lab:draw()
  local sx, sy = world_to_screen(self.x, self.y)
  if self.progress > 0 and tick%60 > math.random(60) then
    local r =  math.random()
    if r > 0.75 then
      pal(9, 4)
    elseif r > 0.5 then
      pal(10, 4)
    else
      pal(10, 11)
    end
    sspr(LAB_ID, sx, sy, ITEMS[Lab.item_id].color_key, 1, 0, 0, 3, 3)
    pal()
  else
    sspr(LAB_ID, sx, sy, ITEMS[Lab.item_id].color_key, 1, 0, 0, 3, 3)
  end
end

function Lab:draw_hover_widget(x, y)
  local x, y = clamp(cursor.x + 5, 1, 240 - 85), clamp(cursor.y + 5, 1, 136 - 46)
  local w, h = 83, 46
  local txt = ITEMS[self.item_id].fancy_name
  local txt2 = current_research and TECH[AVAILABLE_TECH[current_research]].name or 'No Active Research'
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, 'Research Lab', UI_SH)
  prints(txt, x + w/2 - print(txt, 0, -10, 0, false, 1, true)/2, y + 2, 0, 4)
  prints(txt2, x + w/2 - print(txt2, 0, -10, 0, false, 1, true)/2, y + 12, 0, 4)
  for i = 1, 4 do
    box(x + 14 + (i - 1)*13, y + 30, 10, 10, 0, 9)
    if self.input[i].count > 0 then
      draw_item_stack(x + 15 + (i - 1)*13, y + 31, self.input[i])
    end
  end
  local time = current_research and TECH[AVAILABLE_TECH[current_research]].time or 0
  ui.progress_bar(self.progress/(time * 60), x + 10, y + 20, w - 20, 6, UI_BG, UI_FG, 6, 2)
end

function Lab:update()
  self:update_requests()
  if not current_research then
    self.progress = 0
    return
  end
  if current_research and self.progress < TECH[AVAILABLE_TECH[current_research]].time * 60 and not TECH[AVAILABLE_TECH[current_research]].completed then
    for i = 1, #TECH[AVAILABLE_TECH[current_research]].science_packs do
      if self.input[i].count < 1 then return end
    end
    self.progress = self.progress + LAB_TICKRATE
    if self.progress >= TECH[AVAILABLE_TECH[current_research]].time * 60 then
      self.progress = 0
      local science_packs = TECH[AVAILABLE_TECH[current_research]].science_packs
      for i = 1, #science_packs do
        local k = self.slot_keys[tostring(science_packs[i].id)]
        --trace('k = ' .. k)
        if self.input[k].count < 1 then return end
        self.input[k].count = self.input[k].count - 1
      end
      if update_research_progress() then
        current_research = false
        selected_research = false
      end
    end
  end
end

function Lab:deposit_stack(stack)
  for i = 1, 4 do
    local stack_size = ITEMS[self.input[i].id].stack_size
    if stack.id == self.input[i].id then
      if self.input[i].count + stack.count <= stack_size then
        self.input[i].count = self.input[i].count + stack.count
        return true, {id = 0, count = 0}
      elseif self.input[i].count + stack.count > stack_size then
        local old_count = self.input[i].count
        self.input[i].count = stack_size
        stack.count = stack.count - (stack_size - old_count)
        return true, stack
      end
    end
  end
  return false, stack
end

function Lab:update_requests()
  for i = 1, #self.requests do
    --if ingredients are low, request more items
    if self.input[i].count < 2 then
      self.requests[i][1] = true
    end
    --self.requests[i][2] = false
  end
end

function Lab:get_request()
  for i = 1, #self.requests do
    -- check if inserter is already dispatched for this item
    if self.requests[i][1] and not self.requests[i][2] then
      return self.input[i].id
    end
  end
  return false
end

function Lab:assign_delivery(id)
  for k, v in ipairs(self.input) do
    if v.id == id then
      self.requests[k][2] = true
      --now, an inserter has been dispatched to retrieve this item
      --freeing up other possible inserters for different tasks
      return
    end
  end
end

function Lab:request_deposit(inserter)
      --   for i = 1, 4 do
    --     if ENTS[from].input[i].count > 0 and ENTS[to].input[i].count < 2 then
    --       self.held_item_id = ENTS[from].input[i].id
    --       ENTS[from].input[i].count = ENTS[from].input[i].count - 1
    --       self.state = 'send'
    --       break
    --     end
    --   end
  return self:get_request()
end

function Lab:deposit(id)
  if id < 23 or id > 26 then return false end
  for k, v in ipairs(self.input) do
    if id == self.input[k].id then
      self.input[k].count = self.input[k].count + 1
      self.requests[k][2] = false
      if self.input[k].count >= 2 then
        self.requests[k][1] = false
      end
      return true
    end
  end
  return false
end

function Lab:item_request(id, inserter)
  if id < 23 or id > 26 then return false end
  local ent = ENTS[inserter.to_key]
  if ent.type == 'research_lab' then
    for k, v in ipairs(self.input) do
      if v.count > 1 and v.id == id then
        v.count = v.count - 1
        return v.id
      end
    end
  end
  return false
end

function Lab:return_all()
  for k, v in ipairs(self.input) do
    if v.count > 0 then
      local result, stack = inv:add_item(v)
      if stack.count < v.count then
        sound('deposit')
        ui.new_alert(cursor.x, cursor.y, '+' .. v.count - stack.count .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 5)
      end
      v.count = stack.count
    end
  end
end

function new_lab(x, y, dummy_keys)
  -- local slotmap = {
  --   [1] = ,
  --   [2] = ,
  --   [3] = ,
  --   [4] = ,
  --   [5] = ,
  --   [6] = ,
  -- }
  local newlab = {
    x = x,
    y = y,
    type = 'research_lab',
    id = 22,
    input = {},
    progress = 10,
    dummy_keys = dummy_keys,
    slot_keys = {},
    requests = {},
  }
  for i = 1, 4 do
    newlab.input[i] = {id = 22 + i, count = 0}
    newlab.slot_keys[tostring(22+i)] = i
    newlab.requests[i] = {true, false}
    --trace('created new_lab with slot_key[' .. tostring(22+i) .. '] = ' .. i)
  end
  setmetatable(newlab, {__index = Lab})
  return newlab
end

-----------------------------------------------
---Simplex Noise
-- Original Java Source: http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
-- (most) Original comments included
-----------------------------------------------

local math = math
local table = table
local tonumber = tonumber
local ipairs = ipairs
local error = error
--local bit = require("bit")

simplex = {}

simplex.DIR_X = 0
simplex.DIR_Y = 1
simplex.DIR_Z = 2
simplex.DIR_W = 3
simplex.internalCache = false


local Gradients3D = {{1,1,0},{-1,1,0},{1,-1,0},{-1,-1,0},
{1,0,1},{-1,0,1},{1,0,-1},{-1,0,-1},
{0,1,1},{0,-1,1},{0,1,-1},{0,-1,-1}};
local Gradients4D = {{0,1,1,1}, {0,1,1,-1}, {0,1,-1,1}, {0,1,-1,-1},
{0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},
{1,0,1,1}, {1,0,1,-1}, {1,0,-1,1}, {1,0,-1,-1},
{-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},
{1,1,0,1}, {1,1,0,-1}, {1,-1,0,1}, {1,-1,0,-1},
{-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},
{1,1,1,0}, {1,1,-1,0}, {1,-1,1,0}, {1,-1,-1,0},
{-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}};
local p = {151,160,137,91,90,15,
131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180};

-- To remove the need for index wrapping, double the permutation table length

for i=1,#p do
	p[i-1] = p[i]
	p[i] = nil
end

for i=1,#Gradients3D do
	Gradients3D[i-1] = Gradients3D[i]
	Gradients3D[i] = nil
end

for i=1,#Gradients4D do
	Gradients4D[i-1] = Gradients4D[i]
	Gradients4D[i] = nil
end

local perm = {}

for i=0,255 do
	perm[i] = p[i]
	perm[i+256] = p[i]
end

-- A lookup table to traverse the sim around a given point in 4D.
-- Details can be found where this table is used, in the 4D noise method.

local sim = {
{0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},
{0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},
{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
{1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},
{1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},
{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
{2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},
{2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}};

local function Dot2D(tbl, x, y)
	return tbl[1]*x + tbl[2]*y; 
end

local function Dot3D(tbl, x, y, z)
	return tbl[1]*x + tbl[2]*y + tbl[3]*z
end

local function Dot4D( tbl, x,y,z,w) 
	return tbl[1]*x + tbl[2]*y + tbl[3]*z + tbl[3]*w;
end

local Prev2D = {}

function simplex.seed(seed)
  seed = seed or tstamp()
  math.randomseed(seed * seed)
  for i = 1, 256 do
    p[i] = math.floor(math.random()*256)
  end
end

-- 2D simplex noise

function simplex.Noise2D(xin, yin)
	if simplex.internalCache and Prev2D[xin] and Prev2D[xin][yin] then return Prev2D[xin][yin] end 

	local n0, n1, n2; -- Noise contributions from the three corners
	-- Skew the input space to determine which simplex cell we're in
	local F2 = 0.5*(math.sqrt(3.0)-1.0);
	local s = (xin+yin)*F2; -- Hairy factor for 2D
	local i = math.floor(xin+s);
	local j = math.floor(yin+s);
	local G2 = (3.0-math.sqrt(3.0))/6.0;
	
	local t = (i+j)*G2;
	local X0 = i-t; -- Unskew the cell origin back to (x,y) space
	local Y0 = j-t;
	local x0 = xin-X0; -- The x,y distances from the cell origin
	local y0 = yin-Y0;
	
	-- For the 2D case, the simplex shape is an equilateral triangle.
	-- Determine which simplex we are in.
	local i1, j1; -- Offsets for second (middle) corner of simplex in (i,j) coords
	if(x0>y0) then 
		i1=1 
		j1=0  -- lower triangle, XY order: (0,0)->(1,0)->(1,1)
	else
		i1=0
		j1=1 -- upper triangle, YX order: (0,0)->(0,1)->(1,1)
	end
	
	-- A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	-- a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	-- c = (3-sqrt(3))/6

	local x1 = x0 - i1 + G2; -- Offsets for middle corner in (x,y) unskewed coords
	local y1 = y0 - j1 + G2;
	local x2 = x0 - 1.0 + 2.0 * G2; -- Offsets for last corner in (x,y) unskewed coords
	local y2 = y0 - 1.0 + 2.0 * G2;

	-- Work out the hashed gradient indices of the three simplex corners
	local ii = i & 255
	local jj = j & 255
	local gi0 = perm[ii+perm[jj]] % 12;
	local gi1 = perm[ii+i1+perm[jj+j1]] % 12;
	local gi2 = perm[ii+1+perm[jj+1]] % 12;

	-- Calculate the contribution from the three corners
	local t0 = 0.5 - x0*x0-y0*y0;
	if t0<0 then 
		n0 = 0.0;
	else
		t0 = t0 * t0
		n0 = t0 * t0 * Dot2D(Gradients3D[gi0], x0, y0); -- (x,y) of Gradients3D used for 2D gradient
	end
	
	local t1 = 0.5 - x1*x1-y1*y1;
	if (t1<0) then
		n1 = 0.0;
	else
		t1 = t1*t1
		n1 = t1 * t1 * Dot2D(Gradients3D[gi1], x1, y1);
	end
	
	local t2 = 0.5 - x2*x2-y2*y2;
	if (t2<0) then
		n2 = 0.0;
	else
		t2 = t2*t2
		n2 = t2 * t2 * Dot2D(Gradients3D[gi2], x2, y2);
	end

	
	-- Add contributions from each corner to get the final noise value.
	-- The result is scaled to return values in the localerval [-1,1].
	
	local retval = 70.0 * (n0 + n1 + n2)
	
	if simplex.internalCache then
		if not Prev2D[xin] then Prev2D[xin] = {} end
		Prev2D[xin][yin] = retval
	end
	
	return retval;
end

local Prev3D = {}

-- 3D simplex noise
function simplex.Noise3D(xin, yin, zin)
	
	if simplex.internalCache and Prev3D[xin] and Prev3D[xin][yin] and Prev3D[xin][yin][zin] then return Prev3D[xin][yin][zin] end
	
	local n0, n1, n2, n3; -- Noise contributions from the four corners
	
	-- Skew the input space to determine which simplex cell we're in
	local F3 = 1.0/3.0;
	local s = (xin+yin+zin)*F3; -- Very nice and simple skew factor for 3D
	local i = math.floor(xin+s);
	local j = math.floor(yin+s);
	local k = math.floor(zin+s);
	
	local G3 = 1.0/6.0; -- Very nice and simple unskew factor, too
	local t = (i+j+k)*G3;
	
	local X0 = i-t; -- Unskew the cell origin back to (x,y,z) space
	local Y0 = j-t;
	local Z0 = k-t;
	
	local x0 = xin-X0; -- The x,y,z distances from the cell origin
	local y0 = yin-Y0;
	local z0 = zin-Z0;
	
	-- For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	-- Determine which simplex we are in.
	local i1, j1, k1; -- Offsets for second corner of simplex in (i,j,k) coords
	local i2, j2, k2; -- Offsets for third corner of simplex in (i,j,k) coords
	
	if (x0>=y0) then
		if (y0>=z0) then
			i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; -- X Y Z order
		elseif (x0>=z0) then
			i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; -- X Z Y order
		else 
			i1=0; j1=0; k1=1; i2=1; j2=0; k2=1;  -- Z X Y order
		end
	else -- x0<y0
		if (y0<z0) then 
			i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; -- Z Y X order
		elseif (x0<z0) then 
			i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; -- Y Z X order
		else 
			i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; -- Y X Z order
		end
	end
	
	-- A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	-- a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	-- a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	-- c = 1/6.
	
	local x1 = x0 - i1 + G3; -- Offsets for second corner in (x,y,z) coords
	local y1 = y0 - j1 + G3;
	local z1 = z0 - k1 + G3;
	
	local x2 = x0 - i2 + 2.0*G3; -- Offsets for third corner in (x,y,z) coords
	local y2 = y0 - j2 + 2.0*G3;
	local z2 = z0 - k2 + 2.0*G3;
	
	local x3 = x0 - 1.0 + 3.0*G3; -- Offsets for last corner in (x,y,z) coords
	local y3 = y0 - 1.0 + 3.0*G3;
	local z3 = z0 - 1.0 + 3.0*G3;
	
	-- Work out the hashed gradient indices of the four simplex corners
	local ii = i & 255
	local jj = j & 255
	local kk = k & 255
	
	local gi0 = perm[ii+perm[jj+perm[kk]]] % 12;
	local gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;
	local gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;
	local gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;
	
	-- Calculate the contribution from the four corners
	local t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;
	
	if (t0<0) then
		n0 = 0.0;
	else 
		t0 = t0*t0;
		n0 = t0 * t0 * Dot3D(Gradients3D[gi0], x0, y0, z0);
	end
	
	local t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;
	
	if (t1<0) then 
		n1 = 0.0;
	else
		t1 = t1*t1;
		n1 = t1 * t1 * Dot3D(Gradients3D[gi1], x1, y1, z1);
	end
	
	local t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;
	
	if (t2<0) then 
		n2 = 0.0;
	else
		t2 = t2*t2;
		n2 = t2 * t2 * Dot3D(Gradients3D[gi2], x2, y2, z2);
	end
	
	local t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;
	
	if (t3<0) then 
		n3 = 0.0;
	else
		t3 = t3*t3;
		n3 = t3 * t3 * Dot3D(Gradients3D[gi3], x3, y3, z3);
	end
	
	
	-- Add contributions from each corner to get the final noise value.
	-- The result is scaled to stay just inside [-1,1]
	local retval = 32.0*(n0 + n1 + n2 + n3)
	
	if simplex.internalCache then
		if not Prev3D[xin] then Prev3D[xin] = {} end
		if not Prev3D[xin][yin] then Prev3D[xin][yin] = {} end
		Prev3D[xin][yin][zin] = retval
	end
	
	return retval;
end

local Prev4D = {}

-- 4D simplex noise
function simplex.Noise4D(x,y,z,w)

	if simplex.internalCache and Prev4D[x] and Prev4D[x][y] and Prev4D[x][y][z] and Prev4D[x][y][z][w] then return Prev4D[x][y][z][w] end
	
	-- The skewing and unskewing factors are hairy again for the 4D case
	local F4 = (math.sqrt(5.0)-1.0)/4.0;
	local G4 = (5.0-math.sqrt(5.0))/20.0;
	local n0, n1, n2, n3, n4; -- Noise contributions from the five corners
	-- Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
	local s = (x + y + z + w) * F4; -- Factor for 4D skewing
	local i = math.floor(x + s);
	local j = math.floor(y + s);
	local k = math.floor(z + s);
	local l = math.floor(w + s);
	local t = (i + j + k + l) * G4; -- Factor for 4D unskewing
	local X0 = i - t; -- Unskew the cell origin back to (x,y,z,w) space
	local Y0 = j - t;
	local Z0 = k - t;
	local W0 = l - t;
	local x0 = x - X0; -- The x,y,z,w distances from the cell origin
	local y0 = y - Y0;
	local z0 = z - Z0;
	local w0 = w - W0;
	-- For the 4D case, the simplex is a 4D shape I won't even try to describe.
	-- To find out which of the 24 possible simplices we're in, we need to
	-- determine the magnitude ordering of x0, y0, z0 and w0.
	-- The method below is a good way of finding the ordering of x,y,z,w and
	-- then find the correct traversal order for the simplex we�re in.
	-- First, six pair-wise comparisons are performed between each possible pair
	-- of the four coordinates, and the results are used to add up binary bits
	-- for an localeger index.
	local c1 = (x0 > y0) and 32 or 1;
	local c2 = (x0 > z0) and 16 or 1;
	local c3 = (y0 > z0) and 8 or 1;
	local c4 = (x0 > w0) and 4 or 1;
	local c5 = (y0 > w0) and 2 or 1;
	local c6 = (z0 > w0) and 1 or 1;
	local c = c1 + c2 + c3 + c4 + c5 + c6;
	local i1, j1, k1, l1; -- The localeger offsets for the second simplex corner
	local i2, j2, k2, l2; -- The localeger offsets for the third simplex corner
	local i3, j3, k3, l3; -- The localeger offsets for the fourth simplex corner
	
	-- sim[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
	-- Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
	-- impossible. Only the 24 indices which have non-zero entries make any sense.
	-- We use a thresholding to set the coordinates in turn from the largest magnitude.
	-- The number 3 in the "sim" array is at the position of the largest coordinate.
	
	i1 = sim[c][1]>=3 and 1 or 0;
	j1 = sim[c][2]>=3 and 1 or 0;
	k1 = sim[c][3]>=3 and 1 or 0;
	l1 = sim[c][4]>=3 and 1 or 0;
	-- The number 2 in the "sim" array is at the second largest coordinate.
	i2 = sim[c][1]>=2 and 1 or 0;
	j2 = sim[c][2]>=2 and 1 or 0;
	k2 = sim[c][3]>=2 and 1 or 0;
	l2 = sim[c][4]>=2 and 1 or 0;
	-- The number 1 in the "sim" array is at the second smallest coordinate.
	i3 = sim[c][1]>=1 and 1 or 0;
	j3 = sim[c][2]>=1 and 1 or 0;
	k3 = sim[c][3]>=1 and 1 or 0;
	l3 = sim[c][4]>=1 and 1 or 0;
	-- The fifth corner has all coordinate offsets = 1, so no need to look that up.
	local x1 = x0 - i1 + G4; -- Offsets for second corner in (x,y,z,w) coords
	local y1 = y0 - j1 + G4;
	local z1 = z0 - k1 + G4;
	local w1 = w0 - l1 + G4;
	local x2 = x0 - i2 + 2.0*G4; -- Offsets for third corner in (x,y,z,w) coords
	local y2 = y0 - j2 + 2.0*G4;
	local z2 = z0 - k2 + 2.0*G4;
	local w2 = w0 - l2 + 2.0*G4;
	local x3 = x0 - i3 + 3.0*G4; -- Offsets for fourth corner in (x,y,z,w) coords
	local y3 = y0 - j3 + 3.0*G4;
	local z3 = z0 - k3 + 3.0*G4;
	local w3 = w0 - l3 + 3.0*G4;
	local x4 = x0 - 1.0 + 4.0*G4; -- Offsets for last corner in (x,y,z,w) coords
	local y4 = y0 - 1.0 + 4.0*G4;
	local z4 = z0 - 1.0 + 4.0*G4;
	local w4 = w0 - 1.0 + 4.0*G4;
	
	-- Work out the hashed gradient indices of the five simplex corners
	local ii = i & 255
	local jj = j & 255
	local kk = k & 255
	local ll = l & 255
	local gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;
	local gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;
	local gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;
	local gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;
	local gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;
	
	
	-- Calculate the contribution from the five corners
	local t0 = 0.5 - x0*x0 - y0*y0 - z0*z0 - w0*w0;
	if (t0<0) then
		n0 = 0.0;
	else
		t0 = t0*t0;
		n0 = t0 * t0 * Dot4D(Gradients4D[gi0], x0, y0, z0, w0);
	end
	
	local t1 = 0.5 - x1*x1 - y1*y1 - z1*z1 - w1*w1;
	if (t1<0) then
		n1 = 0.0;
	else 
		t1 = t1*t1;
		n1 = t1 * t1 * Dot4D(Gradients4D[gi1], x1, y1, z1, w1);
	end
	
	local t2 = 0.5 - x2*x2 - y2*y2 - z2*z2 - w2*w2;
	if (t2<0) then
		n2 = 0.0;
	else
		t2 = t2*t2;
		n2 = t2 * t2 * Dot4D(Gradients4D[gi2], x2, y2, z2, w2);
	end
	
	local t3 = 0.5 - x3*x3 - y3*y3 - z3*z3 - w3*w3;
	if (t3<0) then
		n3 = 0.0;
	else 
		t3 = t3*t3;
		n3 = t3 * t3 * Dot4D(Gradients4D[gi3], x3, y3, z3, w3);
	end
	
	local t4 = 0.5 - x4*x4 - y4*y4 - z4*z4 - w4*w4;
	if (t4<0) then
		n4 = 0.0;
	else
		t4 = t4*t4;
		n4 = t4 * t4 * Dot4D(Gradients4D[gi4], x4, y4, z4, w4);
	end
	
	-- Sum up and scale the result to cover the range [-1,1]
	
	local retval = 27.0 * (n0 + n1 + n2 + n3 + n4)
	
	if simplex.internalCache then
		if not Prev4D[x] then Prev4D[x] = {} end
		if not Prev4D[x][y] then Prev4D[x][y] = {} end
		if not Prev4D[x][y][z] then Prev4D[x][y][z] = {} end
		Prev4D[x][y][z][w] = retval
	end
	
	return retval;


end 

local e = 2.71828182845904523536

local PrevBlur2D = {}

function simplex.GBlur2D(x,y,stdDev)
	if simplex.internalCache and PrevBlur2D[x] and PrevBlur2D[x][y] and PrevBlur2D[x][y][stdDev] then return PrevBlur2D[x][y][stdDev] end
	local pwr = ((x^2+y^2)/(2*(stdDev^2)))*-1
	local ret = (1/(2*math.pi*(stdDev^2)))*(e^pwr)
	
	if simplex.internalCache then
		if not PrevBlur2D[x] then PrevBlur2D[x] = {} end
		if not PrevBlur2D[x][y] then PrevBlur2D[x][y] = {} end
		PrevBlur2D[x][y][stdDev] = ret
	end
	return ret
end 

local PrevBlur1D = {}

function simplex.GBlur1D(x,stdDev)
	if simplex.internalCache and PrevBlur1D[x] and PrevBlur1D[x][stdDev] then return PrevBlur1D[x][stdDev] end
	local pwr = (x^2/(2*stdDev^2))*-1
	local ret = (1/(math.sqrt(2*math.pi)*stdDev))*(e^pwr)

	if simplex.internalCache then
		if not PrevBlur1D[x] then PrevBlur1D[x] = {} end
		PrevBlur1D[x][stdDev] = ret
	end
	return ret
end

function simplex.FractalSum(func, iter, ...)
    local ret = func(...)
    for i=1,iter do
        local power = 2^iter
        local s = power/i
        
        local scaled = {}
        for elem in ipairs({...}) do
            table.insert(scaled, elem*s)
        end
        ret = ret + (i/power)*(func(table.unpack(scaled)))
    end
    return ret
end

function simplex.FractalSumAbs(func, iter, ...)
    local ret = math.abs(func(...))
    for i=1,iter do
        local power = 2^iter
        local s = power/i
        
        local scaled = {}
        for elem in ipairs({...}) do
            table.insert(scaled, elem*s)
        end
        ret = ret + (i/power)*(math.abs(func(table.unpack(scaled))))
    end
    return ret
end

function simplex.Turbulence(func, direction, iter, ...)
    local ret = math.abs(func(...))
    for i=1,iter do
        local power = 2^iter
        local s = power/i
        
        local scaled = {}
        for elem in ipairs({...}) do
            table.insert(scaled, elem*s)
        end
        ret = ret + (i/power)*(math.abs(func(table.unpack(scaled))))
    end
    local args = {...}
    local dir_component = args[direction+1]
    return math.sin(dir_component+ret)
end

TileManager = {}
TileManager.__index =  TileManager

auto_map = {
  --N E S W
  --tiles surrounding land
  --0 is land, 1 is water or other biome

  ['1000'] = {sprite_id = 1, rot = 0},
  ['0100'] = {sprite_id = 1, rot = 1},
  ['0010'] = {sprite_id = 1, rot = 2},
  ['0001'] = {sprite_id = 1, rot = 3},

  ['1100'] = {sprite_id = 2, rot = 1},
  ['0110'] = {sprite_id = 2, rot = 2},
  ['0011'] = {sprite_id = 2, rot = 3},
  ['1001'] = {sprite_id = 2, rot = 0},

  ['1101'] = {sprite_id = 3, rot = 0},
  ['1110'] = {sprite_id = 3, rot = 1},
  ['0111'] = {sprite_id = 3, rot = 2},
  ['1011'] = {sprite_id = 3, rot = 3},
  ['0101'] = {sprite_id = 4, rot = 0},
  ['1010'] = {sprite_id = 4, rot = 1},
  ['1111'] = {sprite_id = 0, rot = 0},
}

function ore_sample(x, y, tile)
  local biome = tile.biome
  --if
  for i = 1, #ores do
    local scale = ores[i].scale -- ((4 - biome)/100)
    local noise = (simplex.Noise2D(x * scale + ((ores[i].offset * biome) * scale) + offset * scale, (y * scale) + ((ores[i].offset * biome) * scale) + (offset * scale)) / 2 + 0.5) * 16
    --if noise >= ores[i].min and noise <= ores[i].max and ores[i].biome_id == biome then return i end
    if noise >= ores[i].min and noise <= ores[i].max and tile.noise >= ores[i].bmin and tile.noise <= ores[i].bmax then return i end
  end
  return false
end

function AutoMap(x, y)
  local tile = TileMan.tiles[y][x]
  TileMan.tiles[y][x].visited = true
  --Here, 'adj' is the north, east, south, and west 'neighboring' tiles (in local space)
  local adj = {
    [1] = {x = 0, y = -1},
    [2] = {x = 1, y = 0},
    [3] = {x = 0, y = 1},
    [4] = {x = -1, y = 0},
  }
  local key = ''
  for i = 1, 4 do
    --Grab the neighbor tile
    local near = TileMan.tiles[y + adj[i].y][x + adj[i].x]

    --Determine if neighbor is a '0' or '1', meaning 0 is land, 1 is water or a different biome
    if not near.is_land or near.biome < tile.biome then
      key = key .. '1'
      TileMan.tiles[y][x].border_col = biomes[near.biome].map_col
    else
      key = key .. '0'
    end
  end

  --Try to index the key we just created
  local new_tile = auto_map[key]

  --If key exists, then valid config detected, so set tile to the returned value, otherwise return
  if not new_tile then return end

  TileMan.tiles[y][x].sprite_id = new_tile.sprite_id + 11 + biomes[tile.biome].tile_id_offset
  TileMan.tiles[y][x].is_border = true
  --TileMan.tiles[y][x].is_tree  = false
  TileMan.tiles[y][x].ore = false
  TileMan.tiles[y][x].flip = 0
  --TileMan.tiles[y][x].is_tree = false
  TileMan.tiles[y][x].rot = new_tile.rot
end

function  TileManager.new()
  --Creates a TileManager instance - cache's all the generated terrain in memory

  --Here, using __index metemethod, we can automatically trigger the create_tile
  --method whenever a non-existent value is indexed


  local self = setmetatable({},  TileManager)
  local tile_mt = {
    __index = function(row, x)
      --Here's where the magic happens, in create_tile
      local tile =  TileManager.create_tile(x, row.y)
      row[x] = tile
      return tile
    end
  }
  local tiles_mt = {
    __index = function(tiles, y)
      local row = setmetatable({y = y}, tile_mt)
      tiles[y] = row
      return row
    end
  }
  self.tiles = setmetatable({}, tiles_mt)
  return self
end

function  TileManager.create_tile(x, y)
  --Replace with your own function, this gets called once whenever a 'new' tile is indexed

  local scale  = 0.0005
  local scale2 = 0.025
  --Here we sample 2 noise values and blend them together
  local base_noise = (simplex.Noise2D(x * scale + offset * scale, (y * scale) + (offset * scale)) / 2 + 0.5) * 100
  local addl_noise = (simplex.Noise2D(x * scale2 + offset * scale2, (y * scale2) + (offset * scale2))) * 100

  --Now base_noise is used to determine biome and land/water
  --base_noise = ((base_noise * 3) + addl_noise) / 4
  base_noise = lerp(base_noise, addl_noise, 0.02)

  local tile = {
    noise = base_noise,
    is_land = base_noise >= 20 and true or false,
    biome = 1,
    --biome = base_noise < 30 and 1 or base_noise < 45 and 2 or 3,
    is_border = false,
    is_tree = false,
    visited = false,
    b_visited = false,
    rot = 0,
    offset = {x = math.random(1, 2), y = math.random(1, 4)},
  }
  for i = 1, #biomes do
    if base_noise > biomes[i].min and base_noise < biomes[i].max then
      tile.biome = i
      break
    end
  end
  tile.flip = math.random() > 0.5 and 1 or 0
  --If base_noise value is high enough, then try to generate an ore type
  tile.ore = tile.is_land and base_noise > 21 and ore_sample(x, y, tile) or false
  
  if not tile.is_land then
    --Water tile
    tile.color = floor(math.random(2)) + 8
    tile.sprite_id = WATER_SPRITE
    tile.rot = floor(math.random(0,3))
  else
    tile.sprite_id = biomes[tile.biome].tile_id_offset
    tile.color = biomes[tile.biome].map_col
  end

  --If ore-generation was successful, then set sprite_id and color
  if tile.ore then
    tile.color = ores[tile.ore].map_cols[floor(math.random(#ores[tile.ore].map_cols))]
    tile.rot = math.random(4) % 4
  end

  if tile.is_land and not tile.ore then
    --Generate clutter based on biome clutter scale, ex grass, rocks, trees, etc
    scale = 0.001
    local tree = base_noise
    --local tree = (simplex.Noise2D((x * scale) + (offset * scale), (y * scale) + (offset * scale)) / 2 + 0.5) * 100
    local tmin = biomes[tile.biome].t_min
    local tmax = biomes[tile.biome].t_max
    --local flip = math.random(0, 1)
    --trace('Tspawn try: ' .. biomes[tile.biome].name .. ', tmin: ' .. tmin .. ", tmax" .. tmax .. ', tnoise: ' .. tree .. ', tflip = ' .. flip)
    if tree >= biomes[tile.biome].t_min and tree <= biomes[tile.biome].t_max and math.random(0, 100) < (biomes[tile.biome].tree_density * 100) then
      --trace('trying to spawn a tree')
      tile.is_tree = true
      --tile.flip = flip
    elseif math.random(100) <= (biomes[tile.biome].clutter * 100) then
      local rand = floor(math.random(10))
      tile.sprite_id = biomes[tile.biome].tile_id_offset + rand
      --tile.flip = math.random(1) > 0.5 and 1 or 0
      if rand == 1 then
        tile.rot = math.random(4) % 4
      end
    else
      tile.rot = math.random(4) % 4
    end
  end

  return tile
end

function  TileManager:set_tile(x, y, tile_id)
  local tile = self.tiles[y][x]
  tile_id = tile_id or biomes[tile.biome].tile_id_offset
  if tile.is_land and not tile.ore and not tile.is_border then
    self.tiles[y][x].sprite_id = tile_id
    self.tiles[y][x].is_tree = false
  end
  if tile.ore then
    self.tiles[y][x].ore = false
    self.tiles[y][x].is_tree = false
    self.tiles[y][x].sprite_id = biomes[tile.biome].tile_id_offset
  end
end

function  TileManager:draw_terrain(player, screenWidth, screenHeight)
  local cameraTopLeftX = player.x - 116
  local cameraTopLeftY = player.y - 64
  local subTileX = cameraTopLeftX % 8
  local subTileY = cameraTopLeftY % 8
  local startX = floor(cameraTopLeftX / 8)
  local startY = floor(cameraTopLeftY / 8)
  for screenY = 1, screenHeight do
    for screenX = 1, screenWidth do
      local worldX = startX + screenX
      local worldY = startY + screenY
      local tile = self.tiles[worldY][worldX]
      if not show_mini_map then
        local sx = (screenX - 1) * 8 - subTileX
        local sy = (screenY - 1) * 8 - subTileY

        --Here, AutoMap is called once per tile during draw
        --AutoMap is what sets the 'border' or edge tiles
        if not tile.visited and tile.is_land then AutoMap(worldX, worldY) end
        
        if tile.ore then
          rect(sx, sy, 8, 8, biomes[tile.biome].map_col)
          sspr(ores[tile.ore].tile_id, sx, sy, ores[tile.ore].color_keys, 1, 0, tile.rot)
        elseif not tile.is_border then
          local id, rot, flip = tile.sprite_id, tile.rot, tile.flip
          if not tile.is_land then
            --for water tiles only
            if worldX % 2 == 1 and worldY % 2 == 1 then
              flip = 3 -- Both horizontal and vertical flip
            elseif worldX % 2 == 1 then
              flip = 1 -- Horizontal flip
            elseif worldY % 2 == 1 then
              flip = 2 -- Vertical flip
            end
            --procedural water sprite id = 224
            sspr(224, sx, sy, 0, 1, flip, rot)
          else
            --else is land
            rect(sx, sy, 8, 8, biomes[tile.biome].map_col)
            sspr(biomes[tile.biome].tile_id_offset, sx, sy, biomes[tile.biome].map_col, 1, 0, tile.rot)
            if id ~= biomes[tile.biome].tile_id_offset then
              sspr(id, sx, sy, biomes[tile.biome].map_col, 1, flip)
            end
          end
        else
          if tile.biome == 1 then
            local flip = 0
            if worldX % 2 == 1 and worldY % 2 == 1 then
              flip = 3 -- Both horizontal and vertical flip
            elseif worldX % 2 == 1 then
              flip = 1 -- Horizontal flip
            elseif worldY % 2 == 1 then
              flip = 2 -- Vertical flip
            end
            sspr(224, sx, sy, -1, 1, flip)
            sspr(tile.sprite_id, sx, sy, 0, 1, 0, tile.rot)
          else
            sspr(tile.sprite_id, sx, sy, -1, 1, 0, tile.rot)
          end
          --if tile.ore then sspr(ores[tile.ore].tile_id, sx, sy, ores[tile.ore].color_keys, 1, tile.flip, tile.rot) end
        end
        --rectb(sx, sy, 8, 8, 4)
        --sspr(340, sx, sy, -1)
      end
    end
  end
end

function TileManager:draw_clip(x, y, width, height, draw_ents)
end

function  TileManager:draw_clutter(player, screenWidth, screenHeight)
  local cameraTopLeftX = player.x - 116
  local cameraTopLeftY = player.y - 64
  local subTileX = cameraTopLeftX % 8
  local subTileY = cameraTopLeftY % 8
  local startX = floor(cameraTopLeftX / 8)
  local startY = floor(cameraTopLeftY / 8)
  
  for screenY = 1, screenHeight do
    for screenX = 1, screenWidth do
      local worldX = startX + screenX
      local worldY = startY + screenY
      local tile = self.tiles[worldY][worldX]
      local sx = (screenX - 1) * 8 - subTileX
      local sy = (screenY - 1) * 8 - subTileY

      --Here, the 19, 25, and 41 are just randomly chosen biome tiles
      --picked to spawn trees on, but you can use any tiles to limit trees to certain biomes
      if tile.is_tree then
        --trace('drawing tree')
        sspr(biomes[tile.biome].tree_id, sx - 9 + tile.offset.x, sy - 27 + tile.offset.y, biomes[tile.biome].color_key, 1, tile.flip, 0, 3, 4)
        --rectb(sx, sy, 8,8,2)
      end
    end
  end
end

function  TileManager:draw_worldmap(player, x, y, width, height, center)
  --Simple pixel map, using the tile's assigned biome in - biome[i].map_col
  x, y, width, height = x or 0, y or 0, width or 240, height or 136
  if center then
    x = (240/2) - (width/2)
    y = (136/2) - (height/2)
  end
  local map_x, map_y = x or 120 - (width/2) + 1, y or 68 - (height/2) + 2
  local startX, startY = floor(player.x/8 - (width/2) + 1), floor(player.y/8 - (height/2) + 2)
  --local biome_col = biomes[self.tiles[startY][startX].biome].map_col
  local skipped = 0
  rect(map_x - 1, map_y - 1, width + 2, height + 2, 0)
  --rect(map_x, map_y, width, height, biome_col)
  for y = 0, height - 1 do
    -- if y == 0 then
    --   local biome = self.tiles[startY + y - 1][startX + x - 1].biome
    --   start_col = biomes[biome].map_col
    -- end
    for x = 0, width - 1 do
      if rawget(self.tiles, startY + y - 1) and rawget(self.tiles[startY + y - 1], startX + x - 1) then
        local tile = self.tiles[startY + y - 1][startX + x - 1]
        --trace('biome color = ' .. biomes[tile.biome].map_col)
        local color = biomes[tile.biome].map_col
        if tile.is_tree then
          color = 6
        elseif tile.ore or not tile.is_land then
          color = tile.color
        end
        pix(x + map_x, y + map_y, color)
      end
    end
  end
  --trace('skipped drawing ' .. skipped .. ' pixels')
  --trace('start color: ' .. biome_col)
end

-- local biome_count
-- for i = 1, #biomes do
--   biome_count[i] = {}
-- end

recipes = {
  --logistics/production
  [1] = {
    [1] = { 33, },
    [2] = { 9, 18, 10, 11},
    [3] = { },
    [4] = { },
    [5] = { },
    [6] = { }
  },
  --biology/chemistry
  [2] = {
    [1] = { 2, 1, 37},
    [2] = { 15, 16, 17, 27, 29, 28},
    [3] = { 20, 21, 36},
    [4] = { 13, 14, 19, 31, 32},
    [5] = { 22, 30},
    [6] = { 40, 41, 42, 43, 44}
  },
  --intermediate/science
  [3] = {
    [1] = { 3, 4, 5, 6, 7, 8},
    [2] = { 32, 35, 45},
    [3] = { },
    [4] = { },
    [5] = { 23, 24, 25, 26},
    [6] = { },
  }
}

AVAILABLE_TECH = {1,2,5,6}--{1,2,3,4,5,6,12,13}--,6,7,8,9,10,11,12,13}
FINISHED_TECH = {}
UNLOCKED_TECH = {}
UNLOCKED_ITEMS = {}
current_research = false
selected_research = false
current_page = 1
current_tab = true --tab to show available or unlocked tech
starting_unlocked_items = {9, 20, 17, 21, 23, 15, 16, 3, 4, 5, 6, 7, 8, 14, 33, 22, 2, 28}
for i = 1, #ITEMS do
  UNLOCKED_ITEMS[i] = false
end
for k, v in ipairs(starting_unlocked_items) do
  UNLOCKED_ITEMS[v] = true
end

TECH = {
  [1] = {
    name = 'Logistics',
    progress = 0,
    completed = false,
    time = 3,
    tier = 1,
    science_packs = {
      {id = 23, count = 5},
    },
    required_tech = {},
    item_unlocks = {18, 10, 11},
    tech_unlocks = {},
    sprite = {{id=12,tw=3,th=3,w=24,h=24,rot=0,ck=1,page=1,offset={x=0,y=0}}},
  },
  [2] = {
    name = 'Automation',
    progress = 0,
    completed = false,
    time = 5,
    tier = 1,
    science_packs = {
      {id = 23, count = 15}
    },
    required_tech = {},
    item_unlocks = {19, 13},
    tech_unlocks = {},
    sprite = {{id=312,tw=3,th=3,w=24,h=24,rot=0,ck=0,page=0,offset={x=0,y=0}}},
  },
  [3] = {
    name = 'Logistics Pack',
    progress = 0,
    completed = false,
    time = 3,
    science_packs = {
      {id = 23, count = 30}
    },
    required_tech = {1},
    item_unlocks = {24},
    tech_unlocks = {},
    sprite = {
      {id=269,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=1,offset={x=4,y=4}},
      {id=461,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=1,y=1}},
      {id=399,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=15,y=1}},
    },
  },
  [4] = {
    name = 'Steel Processing',
    progress = 0,
    completed = false,
    time = 1,
    science_packs = {
      {id = 23, count = 35}
    },
    required_tech = {3},
    item_unlocks = {27},
    tech_unlocks = {},
    sprite = {
      {id=448,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=1,y=3}},
      {id=448,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=2,y=5}},
      {id=270,tw=1,th=1,w=8,h=8,rot=2,ck=0,page=0,offset={x=8,y=2}},
      {id=503,tw=1,th=1,w=8,h=8,rot=0,ck=6,page=0,offset={x=15,y=2}},
      {id=468,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=8,y=13}}
    },
  },
  [5] = {
    name = 'Electronics 1',
    progress = 0,
    completed = false,
    time = 5,
    tier = 1,
    science_packs = {
      {id = 23, count = 10}
    },
    required_tech = {},
    item_unlocks = {1},
    tech_unlocks = {},
    sprite = {
      {id=309,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=0,offset={x=4,y=4}},
    },
  },
  [6] = {
    name = 'Laser Mining 1',
    progress = 0,
    completed = false,
    time = 5,
    tier = 1,
    science_packs = {
      {id = 23, count = 35}
    },
    required_tech = {},
    item_unlocks = {34},
    info = {'Increases mining speed', 'by 150%'},
    tech_unlocks = {},
    sprite = {
      {id=341,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=4}},
      {id=342,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=4}},
      {id=357,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=12}},
      {id=358,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=12}},
    },
    callback = function(self)
      CURSOR_MINING_SPEED = floor(CURSOR_MINING_SPEED - (CURSOR_MINING_SPEED*0.5))
    end,
  },
  [7] = {
    name = 'Laser Mining 2',
    progress = 0,
    completed = false,
    time = 5,
    tier = 1,
    science_packs = {
      {id = 23, count = 50},
      {id = 24, count = 50},
    },
    required_tech = {6, 10},
    item_unlocks = {38},
    info = {'Increases mining speed', 'by 150%'},
    tech_unlocks = {},
    sprite = {
      {id=343,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=4}},
      {id=342,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=4}},
      {id=357,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=12}},
      {id=359,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=12}},
    },
    callback = function(self)
      CURSOR_MINING_SPEED = floor(CURSOR_MINING_SPEED - (CURSOR_MINING_SPEED*0.5))
    end,
  },
  [8] = {
    name = 'Laser Mining 3',
    progress = 0,
    completed = false,
    time = 5,
    tier = 1,
    science_packs = {
      {id = 23, count = 100},
      {id = 24, count = 100},
      {id = 25, count = 100},
    },
    required_tech = {7, 15},
    item_unlocks = {39},
    info = {'Increases mining speed', 'by 150%'},
    tech_unlocks = {},
    sprite = {
      {id=327,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=4}},
      {id=342,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=4}},
      {id=357,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=4,y=12}},
      {id=360,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=12,y=12}},
    },
    callback = function(self)
      CURSOR_MINING_SPEED = floor(CURSOR_MINING_SPEED - (CURSOR_MINING_SPEED*0.5))
    end,
  },
  [9] = {
    name = 'Oil Processing',
    progress = 0,
    completed = false,
    time = 5,
    science_packs = {
      {id = 23, count = 50},
      {id = 24, count = 50},
    },
    required_tech = {1, 3, 4},
    item_unlocks = {30, 45},
    tech_unlocks = {},
    sprite = {{id=371,tw=3,th=3,w=24,h=24,rot=0,ck=1,page=0,offset={x=0,y=0}}},
  },
  [10] = {
    name = 'Electronics 2',
    progress = 0,
    completed = false,
    time = 30,
    tier = 2,
    science_packs = {
      {id = 23, count = 25},
      {id = 24, count = 25},
    },
    required_tech = {5, 13},
    item_unlocks = {37},
    tech_unlocks = {},
    sprite = {
      {id=309,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=0,offset={x=0,y=0}},
      {id=309,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=0,offset={x=8,y=8}},
    },
  },
  [11] = {
    name = 'Biofuel Processing',
    progress = 0,
    completed = false,
    time = 30,
    science_packs = {
      {id = 23, count = 25},
      {id = 24, count = 25},
      {id = 25, count = 25},
    },
    required_tech = {12, 3, 9, 14},
    item_unlocks = {31, 35},
    tech_unlocks = {},
    sprite = {
      {id=462,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=2,y=2}},
      {id=165,tw=1,th=1,w=8,h=8,rot=0,ck=4,page=0,offset={x=15,y=2}},
      {id=483,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=2,y=13}},
      {id=482,tw=1,th=1,w=8,h=8,rot=0,ck=6,page=0,offset={x=15,y=14}},
    },
  },
  [12] = {
    name = 'Fiber Extraction',
    progress = 0,
    completed = false,
    time = 5,
    science_packs = {
      {id = 25, count = 10}
    },
    required_tech = {14},
    item_unlocks = {32},
    tech_unlocks = {},
    sprite = {
      {id=451,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=0,y=3}},
      {id=270,tw=1,th=1,w=8,h=8,rot=2,ck=0,page=0,offset={x=8,y=5}},
      {id=268,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=16,y=2}},
    },
  },
  [13] = {
    name = 'Plastic Bar',
    progress = 0,
    completed = false,
    time = 5,
    science_packs = {
      {id = 23, count = 25},
      {id = 24, count = 25},
      {id = 25, count = 25},
    },
    required_tech = {9},
    item_unlocks = {36},
    tech_unlocks = {},
    sprite = {
      {id=283,tw=1,th=1,w=8,h=8,rot=0,ck=4,page=0,offset={x=0,y=2}},
      {id=268,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=16,y=1}},
      {id=165,tw=1,th=1,w=8,h=8,rot=0,ck=4,page=0,offset={x=8,y=2}},
      {id=270,tw=1,th=1,w=8,h=8,rot=3,ck=0,page=0,offset={x=8,y=6}},
      {id=374,tw=1,th=1,w=8,h=8,rot=0,ck=1,page=0,offset={x=9,y=14}},
    },
  },
  [14] = {
    name = 'Biology Pack',
    progress = 0,
    completed = false,
    time = 3,
    science_packs = {
      {id = 23, count = 25},
      {id = 24, count = 25},
    },
    required_tech = {3, 9, 11, 12},
    item_unlocks = {25},
    tech_unlocks = {},
    sprite = {
      {id=301,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=1,offset={x=4,y=4}},
      {id=462,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=1,y=1}},
      {id=399,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=15,y=1}},
    },
  },
  [15] = {
    name = 'Production Pack',
    progress = 0,
    completed = false,
    time = 3,
    science_packs = {
      {id = 23, count = 100},
      {id = 24, count = 100},
      {id = 25, count = 100}
    },
    required_tech = {14},
    item_unlocks = {26},
    tech_unlocks = {},
    sprite = {
      {id=333,tw=2,th=2,w=16,h=16,rot=0,ck=1,page=1,offset={x=4,y=4}},
      {id=463,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=1,y=1}},
      {id=399,tw=1,th=1,w=8,h=8,rot=0,ck=0,page=0,offset={x=15,y=1}},
    },
  },
  [16] = {
    name = 'Rocket Silo',
    progress = 0,
    completed = false,
    time = 3,
    science_packs = {
      {id = 23, count = 100},
      {id = 24, count = 100},
      {id = 25, count = 100},
      {id = 26, count = 100},
    },
    required_tech = {15},
    item_unlocks = {40, 41, 42, 43, 44},
    tech_unlocks = {},
    sprite = {
      {id=386,tw=1,th=1,w=8,h=8,rot=0,ck=-1,page=0,offset={x=4,y=4}},
    },
  },
}

for k, v in ipairs(TECH) do
  FINISHED_TECH[k] = false
end
--copy defs so runtime changes are independant
RESEARCH = TECH

--require('classes/solar_panel')

CHEST_ID = 464

local Chest = {
  x = 0,
  y = 0,
  slots = {},
  type = 'chest',
  rows = 2,
  cols = 8,
  is_hovered = false,
  item_id = 33,
  id = CHEST_ID,
  updated = false,
  drawn = false,
}

function Chest:draw()
  local sx, sy = world_to_screen(self.x, self.y)
  sspr(CHEST_ID, sx, sy)
end

function Chest:draw_hover_widget(x, y)
  self:draw_inventory(x or cursor.x + 5, y or cursor.y + 5)
end

function Chest:draw_inventory(x, y)
  local grid_x = 2
  local grid_y = 9
  local rows = self.rows
  local cols = self.cols
  local w = (self.cols * 9) + 4
  local h = (self.rows * 9) + 11
  local name = 'Wooden Chest'
  x = clamp(x, 1, 240 - w - 2)
  y = clamp(y, 1, 136 - h - 2)
  
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, name, UI_BG)
  ui.draw_grid(x + grid_x, y + grid_y, rows, cols, UI_BG, UI_FG, 9, true, true)
  local i = 1
  for j = 1, rows do
    for k = 1, cols do
      local item = ITEMS[self.slots[i].id]
      if item then
        local sx, sy = x + grid_x + 1 + ((k-1)*9), y + grid_y + 1 + ((j-1)*9)
        sspr(item.sprite_id, sx, sy, item.color_key)
      end
      i = i + 1
    end
  end
if show_count then
    i = 1
    for j = 1, rows do
      for k = 1, cols do
        local item = ITEMS[self.slots[i].id]
        if item then
          local sx, sy = x + grid_x + 1 + ((k-1)*9), y + grid_y + 1 + ((j-1)*9)
          local count = self.slots[i].count < 100 and self.slots[i].count or floor(self.slots[i].count/100) .. 'H'
          prints(count, sx + 2, sy + 4, 0, 4)
        end
        i = i + 1
      end
    end
  end
end

function Chest:deposit_stack(stack)
  for k, v in ipairs(self.slots) do
    local item = ITEMS[v.id]
    if item then
      if v.id == stack.id and v.count + stack.count <= item.stack_size then
        v.count = v.count + stack.count
        return true, {id = 0, count = 0}
      elseif v.id == stack.id and v.count < item.stack_size and v.count + stack.count > item.stack_size then
        local diff = item.stack_size - v.count
        v.count = item.stack_size
        stack.count = stack.count - diff
      end
    elseif v.id == 0 then
      v.count = stack.count
      v.id = stack.id
      return true, {id = 0, count = 0}
    end
  end
  return false, stack
end

function Chest:deposit(id)
  for k, v in ipairs(self.slots) do
    if v.id == 0 or (v.id == id and v.count < ITEMS[id].stack_size) then
      v.id = id
      v.count = v.count + 1
      return true
    end
  end
  return false
end

function Chest:can_deposit(stack)
  for k, v in ipairs(self.slots) do
    if (v.id == id and v.count + stack.count <= ITEMS[id].stack_size) or v.id == 0 then
      return true
    end
  end
  return false
end

function Chest:open()
  return {
    ent_key = self.x .. '-' .. self.y,
    x = 240/2 - (((self.cols * 9) + 4)/2),
    y = 20,
    grid_x = 2,
    grid_y = 9,
    rows = self.rows,
    cols = self.cols,
    w = (self.cols * 9) + 4,
    h = (self.rows * 9) + 11,
    name = 'Wooden Chest',
    vis = true,
    draw = function(self)
      if self.vis then
        local slot = self:get_hovered_slot(cursor.x, cursor.y)
        ENTS[self.ent_key]:draw_inventory(self.x, self.y)
        self:close(cursor.x, cursor.y)
        if self:is_hovered(cursor.x, cursor.y) then
          sspr(CURSOR_POINTER, cursor.x, cursor.y, 0)
          if cursor.item_stack.id ~= 0 then
            draw_item_stack(cursor.x + 5, cursor.y + 5, cursor.item_stack)
          end
          if slot then ui.highlight(slot.x, slot.y, 8, 8, false, 3, 4) end
          if (alt_mode and key(64)) and slot and ENTS[self.ent_key].slots[slot.index].id > 0 then
            draw_recipe_widget(cursor.x + 5, cursor.y + 5, ENTS[self.ent_key].slots[slot.index].id)
          end
        end
      end
    end,
    close = function(self)
      if ui.draw_button(self.x + self.w - 10, self.y + 2, 0, UI_CLOSE, 2, 0, 3) then
        return true
      end
      return false
    end,
    click = function(self, x, y)
      local slot = self:get_hovered_slot(x, y)
      local ent = ENTS[self.ent_key]
      if slot and ent.slots[slot.index].id > 0 then
        --trace('slot# ' .. slot.index .. ' clicked')
        if key(64) then
          local result, stack = inv:add_item({id = ent.slots[slot.index].id, count = ent.slots[slot.index].count})
          if result then
            sound('deposit')
            ui.new_alert(cursor.x, cursor.y, '+' .. ent.slots[slot.index].count - stack.count .. ' ' .. ITEMS[ent.slots[slot.index].id].fancy_name, 1500, 0, 4)
            ent.slots[slot.index].id = stack.id
            ent.slots[slot.index].id = stack.count
            return true
          end
          return false
        end
        if cursor.type == 'pointer' and ent.slots[slot.index].id ~= 0 then
          if cursor.r then
            set_cursor_item({id = ent.slots[slot.index].id, count = math.ceil(ent.slots[slot.index].count/2)})
            ent.slots[slot.index].count = floor(ent.slots[slot.index].count/2)
            if ent.slots[slot.index].count < 1 then
              ent.slots[slot.index].id = 0
              ent.slots[slot.index].count = 0
              return true
            end
          else
            set_cursor_item({id = ent.slots[slot.index].id, count = ent.slots[slot.index].count})
            ent.slots[slot.index].id = 0
            ent.slots[slot.index].count = 0
            return true
          end
        elseif cursor.type == 'item' then
          if cursor.item_stack.id ~= ent.slots[slot.index].id and ent.slots[slot.index].count > 0 then
            --swap stacks
            local chest_stack = {id = ent.slots[slot.index].id, count = ent.slots[slot.index].count}
            ent.slots[slot.index].id = cursor.item_stack.id
            ent.slots[slot.index].count = cursor.item_stack.count
            set_cursor_item({id = chest_stack.id, count = chest_stack.count})
            return true
          end

          ent.slots[slot.index].id = cursor.item_stack.id

          if cursor.r then
            ent.slots[slot.index].count = ent.slots[slot.index].count + 1
            cursor.item_stack.count = cursor.item_stack.count - 1
            if cursor.item_stack.count < 1 then
              set_cursor_item()
            end
          elseif cursor.l then
            --try deposit whole stack
            local stack_size = ITEMS[ent.slots[slot.index].id].stack_size
            if ent.slots[slot.index].id == 0 then
              ents.slots[slot.index].id = cursor.item_stack.id
              ent.slots[slot.index].count = cursor.item_stack.count
              set_cursor_item()
              return true
            elseif ent.slots[slot.index].count + cursor.item_stack.count <= stack_size then
              ent.slots[slot.index].count = ent.slots[slot.index].count + cursor.item_stack.count
              set_cursor_item()
              return true
            elseif ent.slots[slot.index].count + cursor.item_stack.count > stack_size then
              local old_count = ent.slots[slot.index].count
              ent.slots[slot.index].count = stack_size
              cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
              return true
            end
          end
          
          return false
        end
      end
      if self:close(x, y) then
        ui.active_window = false
      end
    end,
    is_hovered = function(self, x, y)
      return x >= self.x and x <= self.x + self.w and y >= self.y and y <= self.y + self.h
    end,
    get_hovered_slot = function(self, x, y)
      return get_hovered_slot(x, y, self.x + self.grid_x, self.y + self.grid_y, 9, 2, 8)
    end,
  }
end

function Chest:request(stack, keep)
  for k, v in ipairs(self.slots) do
    if v.id == stack.id and v.count >= stack.count then
      if not keep then
        v.count = v.count - stack.count
        if v.count <= 0 then
          v.count = 0
          v.id = 0
        end
      end
      return true
    end
  end
  return false
end

function Chest:item_request(id)
  for k, v in ipairs(self.slots) do
    local item = ITEMS[v.id]
    if v.id > 0 and (v.id == id or id == 'any' or (item and id == item.type)) then
      v.count = v.count - 1
      if v.count < 1 then v.id = 0 end
      return v.id
    end
  end
  return false
end

function Chest:request_deposit()
  return 'any'
end

function Chest:request_inserter()
  local result = false
  for k, v in ipairs(self.slots) do
    if v.id ~= 0 and v.count > 0 then
      result = v.id
      v.count = v.count - 1
      if v.count < 1 then
        v.count = 0
        v.id = 0
      end
      return result
    end
  end
  return result
end

function Chest:return_all()
  for k, v in ipairs(self.slots) do
    if ITEMS[v.id] and v.count > 0 then
      local old_stack = {id = v.id, count = v.count}
      local result, stack = inv:add_item(old_stack)
      v.id = stack.id
      v.count = stack.count
      if v.count < old_stack.count then
        ui.new_alert(cursor.x, cursor.y, '+' .. (old_stack.count - v.count) .. ' ' .. ITEMS[old_stack.id].fancy_name, 1000, 0, 4)
        sound('deposit')
      end
    end
  end
end

function new_chest(x, y, tier)
  local new_chest = {x = x, y = y, slots = {}}
  setmetatable(new_chest, {__index = Chest})
  for i = 1, Chest.rows*Chest.cols do
    new_chest.slots[i] = {id = 0, count = 0}
  end
  -- chest.slots[1] = {id = 5, count = 10}
  return new_chest
end

REFINERY_ID = 371

local Refinery = {
  x = 0,
  y = 0,
  recipe = false,
  input = {},
  output = {},
  type = 'bio_refinery',
  id = 30,
  item_id = 30,
  is_hovered = false,
  updated = false,
  drawn = false,
  state = 'ready',
  -- requests = false,
  progress = 0,
  requests = {},
  dummy_keys = {},
  tickrate = 5,
}

function Refinery:update()
  --trace('crafter state: ' .. tostring(self.state))
  if not self.recipe then return end
  self:update_requests()
  local max_output = ITEMS[self.output.id].recipe.count * 5
  --self:update_requests()
  if self.state ~= 'crafting' and self.state ~= 'idle' then
    local has_enough = true
    for i = 1, #self.recipe.ingredients do
      if self.input[i].count < self.recipe.ingredients[i].count then
        has_enough = false
      end
    end

    if has_enough and self.output.count < max_output then
      self.state = 'crafting'
    end
  end
  --if crafting in progress, update it
  if self.state == 'crafting' then
    --trace(self.progress)
    self.progress = self.progress + CRAFTER_TICKRATE
    --we have reached full progress, so check for ingredients to make new item
    if self.progress >= self.recipe.crafting_time then
      self.progress = 0
      self.state = 'ready'

      local has_enough = false
      for i = 1, #self.recipe.ingredients do
        if self.input[i].count >= self.recipe.ingredients[i].count then
          has_enough = true
        end
      end

      if has_enough and self.output.count < max_output then
        for i = 1, #self.recipe.ingredients do
          self.input[i].count = self.input[i].count - self.recipe.ingredients[i].count
        end
        self.output.count = self.output.count + self.recipe.count
      end
      --idle mode?
      -- if self.output.count >= ITEMS[self.output.id].stack_size then
      --   self.state = 'idle'
      -- end
    end
  end
end

function Refinery:draw()
  local sx, sy = world_to_screen(self.x, self.y)
  sspr(REFINERY_ID, sx, sy, ITEMS[30].color_key, 1, 0, 0, 3, 3)
  self.drawn = true
end

function Refinery:draw_hover_widget()
  local w, h = 63, 66
  local x, y = clamp(cursor.x + 5, 1, 240 - w - 2), clamp(cursor.y + 5, 1, 135 - h - 1)
  if not self.recipe then
    ui.draw_panel(x, y, w, 10, 8, 9, 'No Recipe Set', 0)
    return
  end
  
  --local txt = ITEMS[ENTS[self.ent_key].id].fancy_name
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, 'Bio Refinery', UI_SH)
  ui.progress_bar(math.min(1.0, self.progress/self.recipe.crafting_time), x + w/2 - 25, y + 12, 50, 6, UI_BG, UI_FG, 6, 0)
  prints('Input', x + w/2 - 12, y + h - 24)
  for k, v in ipairs(self.input) do
    box(x + w/2 - ((#self.input*13)/2) + (k-1)*13, y + h - 15, 10, 10, 8, 9)
    if v.id ~= 0 and v.count > 0 then
      draw_item_stack(x + w/2 - ((#self.input*13)/2) + (k-1)*13 + 1, y + h - 15 + 1, v)
    end
  end
--draw output items
  prints('Output', x + w/2 - 12, y + 19)
  box(x + w/2 - 6, y + 27, 10, 10, 8, 9)
  if self.output.count > 0 then
    draw_item_stack(x + w/2 - 4, y + 28, {id = self.output.id, count = self.output.count})
  end
end

function Refinery:deposit_stack(stack)
  if not self.recipe then return end
  for k, v in ipairs(self.input) do
    if v.id == stack.id then
      local stack_size = ITEMS[self.recipe.ingredients[k].id].stack_size
      if v.count < stack_size then
        if v.count + stack.count <= stack_size then
          v.count = v.count + stack.count
          return true, {id = 0, count = 0}
        elseif v.count + stack.count > stack_size then
          stack.count = stack.count - (stack_size - v.count)
          v.count = stack_size
          return true, stack
        end
        return false, stack
      end
    end
  end
  return false, stack
end

function Refinery:set_recipe(item)
  self.recipe = item.recipe
  for i = 1, #self.recipe.ingredients do
    self.input[i].id = self.recipe.ingredients[i].id
    --self.input[i].count = ITEMS[self.input[i].id].stack_size
  end
  self.output.id = self.recipe.id
  self.requests = {}
  for i = 1, #self.recipe.ingredients do
    self.requests[i] = {[1] = true, [2] = false}
    --[1] = 'do I need this item'
    --[2] = 'is an inserter currently delivering this'
  end
end

function Refinery:open()
  if self.recipe then
    return {
      x = 240 - 65,
      y = 1,
      w = 63,
      h = 66,
      ent_key = self.x .. '-' .. self.y,
      close = function(self, sx, sy)
        local btn = {x = self.x + self.w - 9, y = self.y + 1, w = 5, h = 5}
        if sx >= btn.x and sy < btn.x + btn.w and sy >= btn.y and sy <= btn.y + btn.h then
          return true
        end
        return false
      end,
      draw = function(self)
        --local txt = ITEMS[ENTS[self.ent_key].id].fancy_name
        local ent = ENTS[self.ent_key]
        ui.draw_panel(self.x, self.y, self.w, self.h, UI_BG, UI_FG, 'Bio Refinery', UI_SH)
        ui.progress_bar(math.min(1.0, ent.progress/ent.recipe.crafting_time), self.x + self.w/2 - 25, self.y + 12, 50, 6, UI_BG, UI_FG, 6, 0)
        sspr(CLOSE_ID, self.x + self.w - 9, self.y + 2, 15)
        prints('Input', self.x + self.w/2 - 12, self.y + self.h - 24)
        for k, v in ipairs(ent.input) do
          box(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, self.y + self.h - 15, 10, 10, 8, 9)
          if v.id ~= 0 and v.count > 0 then
            draw_item_stack(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13 + 1, self.y + self.h - 15 + 1, v)
          end
        end
        --draw output items
        prints('Output', self.x + self.w/2 - 12, self.y + 19)
        box(self.x + self.w/2 - 6, self.y + 27, 10, 10, 8, 9)
        if ent.output.count > 0 then
          draw_item_stack(self.x + self.w/2 - 4, self.y + 28, {id = ent.output.id, count = ent.output.count})
        end
        if hovered(cursor, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
          ui.highlight(self.x + self.w/2 - 6, self.y + 27, 8, 8, false, 3, 4)
          if key(64) then draw_recipe_widget(cursor.x + 5, cursor.y + 5, ent.output.id) end
        end
        --draw cursor item
        if self:is_hovered(cursor.x, cursor.y) and cursor.type == 'item' then
          draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
        end
        --input slots hover
        for k, v in ipairs(ent.input) do
          if hovered(cursor, {x = self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, y = self.y + self.h - 15, w = 10, h = 10}) then
            ui.highlight(self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, self.y + self.h - 15, 8, 8, false, 3, 4)
            if key(64) then draw_recipe_widget(cursor.x + 5, cursor.y + 5, v.id) end
          end
        end
      end,
      click = function(self, sx, sy)
        local ent = ENTS[self.ent_key]
        if self:close(sx, sy) then
          ui.active_window = nil
          return true
        end
        for k, v in ipairs(ent.input) do
          if hovered(cursor, {x = self.x + self.w/2 - ((#ent.input*13)/2) + (k-1)*13, y = self.y + self.h - 15, w = 10, h = 10}) then
            -- ui.highlight(self.x + 13 + (i - 1)*13, self.y + 49, 10, 10, false, 3, 4)
            
            local stack_size = ITEMS[v.id].stack_size
            --item interaction
            if cursor.type == 'pointer' then
              if key(64) then
                local old_count = v.count
                local result, stack = inv:add_item({id = v.id, count = v.count})
                if result then
                  v.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                  return true
                end
              elseif v.count > 0 then
                if cursor.r and v.count > 1 then
                  set_cursor_item({id = v.id, count = math.ceil(v.count/2)}, false)
                  v.count = floor(v.count/2)
                  return true
                else
                  set_cursor_item({id = v.id, count = v.count}, false)
                  v.count = 0
                  return true
                end
              end
            elseif cursor.type == 'item' and cursor.item_stack.id == v.id then
              --try to combine stacks, leaving extra on cursor
              if key(64) then
                if v.count > 0 then
                  local result, stack = inv:add_item({id = v.id, count = v.count})
                  if result then
                    v.count = stack.count
                    sound('deposit')
                    ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                  end
                end
                return true
              end
              if cursor.r then
                if v.count + 1 < stack_size then
                  v.count = v.count + 1
                  cursor.item_stack.count = cursor.item_stack.count - 1
                  if cursor.item_stack.count < 1 then
                    set_cursor_item()
                  end
                  return true
                end
              else
                if cursor.item_stack.count + v.count > stack_size then
                  local old_count = v.count
                  v.count = stack_size
                  cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                  return true
                else
                  v.count = v.count + cursor.item_stack.count
                  set_cursor_item()
                  return true
                end
              end
            end
            
          end
        end
        if ent.output.count > 0 and cursor.type == 'pointer' and hovered({x = sx, y = sy}, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
          if key(64) then
            local old_count = ent.output.count
            local result, stack = inv:add_item({id = ent.output.id, count = ent.output.count})
            if result then
              ent.output.count = stack.count
              ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output.id].fancy_name, 1000, 0, 6)
              sound('deposit')
              return true
            end
          else
            if cursor.r and v.count > 1 then
              set_cursor_item({id = ent.output.id, count = math.ceil(ent.output.count/2)}, false)
              v.count = floor(ent.output.count/2)
              return true
            else
              set_cursor_item({id = ent.output.id, count = ent.output.count})
              ent.output.count = 0
              return true
            end
          end
        end
        return false
      end,
      is_hovered = function(self, x, y)
        return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
      end,
    }
  else
    return {
      width = 80,
      height = 55,
      x = 70,
      y = 18,
      bg = 8,
      fg = 9,
      close = function(self, sx, sy)
        -- 5x5 close button sprite
        local cx, cy, cw, ch = self.x + self.width - 7, self.y + 2, 5, 5
        if sx >= cx and sx < sx + cw and sy >= cy and sy < cy + ch then
          return true
        end
        return false
      end,
      ent_key = self.x .. '-' .. self.y,
      click = function(self, sx, sy)
        --check for close-button
        if self:close(sx, sy) then
          craft_menu.current_output = 'player'
          ui.active_window = false
          return true
        end
        --if no recipe, check the 'set-recipe' button
        local width = print('Select a recipe', 0, -10, 0, false, 1, true) + 4
        local btn = {x = self.x + ((width + 4)/2) - width/2 - 2, y = self.y + 32, w = width + 4, h = 9}
        local x, y, w, h = btn.x, btn.y, btn.w, btn.h
        if sx >= x and sx < x + w and sy >= y and sy < sy + h then
          --open recipe selection widget
          ui.active_window = false
          --ui.assembly_recipe_widget(self)
          craft_menu.current_output = self.ent_key
          toggle_crafting(true)
          --trace('selecting recipe')
          return true
        end
        return false
      end,

      is_hovered = function(self, x, y)
        return x >= self.x and x < self.x + self.width and y >= self.y and y < self.y + self.height and true or false
      end,
      draw = function(self)
        local ent = ENTS[self.ent_key]
        if not ent then self = nil return end
        local x, y, w, h, bg, fg = self.x, self.y, self.width, self.height, self.bg, self.fg
        local width = print('Select a recipe', 0, -10, 0, false, 1, true)
        local c = cursor
        local btn = {x = x + w/2 - width/2 - 2, y = y + 32, w = width + 4, h = 9}
        btn.color = c.x >= btn.x and c.x < btn.x + btn.w and c.y >= btn.y and c.y < btn.y + btn.h and 9 or 8
        ui.draw_panel(x, y, w, h, bg, fg, ITEMS[ent.item_id].fancy_name)
        box(btn.x, btn.y, btn.w, btn.h, btn.color, 9)
        prints('Select a recipe', btn.x + 2, btn.y + 2, 0, 4)
        sspr(482, x + w/2 - 8, y + 14, 6, 2, 0, 0, 1, 1)
        sspr(CLOSE_ID, x + w - 7, y + 2, 15)
      end
    }
  end
end

function Refinery:update_requests()
  for i = 1, #self.requests do
    --if ingredients are low, request more items
    if self.input[i].count < self.recipe.ingredients[i].count*2 then
      self.requests[i][1] = true
    end
    --self.requests[i][2] = false 
  end
end

function Refinery:get_request()
  for i = 1, #self.requests do
    if self.requests[i][1] and not self.requests[i][2] then
      --self.requests[i][2] = true
      return self.recipe.ingredients[i].id
      --now an inserter has been dispatched to retrieve this item
    end
  end
  return false
end

function Refinery:deposit(id)
  if not self.recipe then return false end
  for k, v in ipairs(self.recipe.ingredients) do
    if id == v.id then
      self.input[k].count = self.input[k].count + 1
      self.requests[k][2] = false
      if self.input[k].count >= self.recipe.ingredients[k].count*2 then
        self.requests[k][1] = false
      end
      return true
    end
  end
  return false
end

function Refinery:request_deposit()
  if not self.recipe then return false end
  local item = self:get_request()
  return item
end

function Refinery:item_request(id)
  if (self.output.id == id or id == 'any') and self.output.count > 0 then
    self.output.count = self.output.count - 1
    return self.output.id
  end
end

function Refinery:assign_delivery(id)
  for k, v in ipairs(self.recipe.ingredients) do
    if v.id == id then
      self.requests[k][2] = true
      return
    end
  end
end

function Refinery:return_all()
  if not self.recipe then return end
  for k, v in ipairs(self.input) do
    if v.count > 0 then
      local _, stack = inv:add_item({id = v.id, count = v.count})
      if stack.count ~= v.count then
        ui.new_alert(cursor.x, cursor.y, '+ ' .. v.count - stack.count .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
        v.count = stack.count
      end
    end
  end
  if self.output.count > 0 then
    local _, stack = inv:add_item({id = self.output.id, count = self.output.count})
    if stack.count ~= self.output.count then
      ui.new_alert(cursor.x, cursor.y, '+ ' .. self.output.count - stack.count .. ' ' .. ITEMS[self.output.id].fancy_name, 1000, 0, 6)
      self.output.count = stack.count
    end
  end
end

function new_refinery(x, y)
  local newRefinery = {x = x, y = y}
  newRefinery.input = {
    {id = 0, count = 0},
    {id = 0, count = 0},
    {id = 0, count = 0},
  }
  newRefinery.output = {id = 0, count = 0}
  return setmetatable(newRefinery, {__index = Refinery})
end

ROCKET_SILO_ID = 368
ROCKET_DOOR_ID = 370
ROCKET_ID = 394
ROCKET_CRAFT_TIME = 100
ROCKET_FX_ID = 476

local Silo = {
  x = 0,
  y = 0,
  anim_frame = 0,
  input = {},
  output = {},
  progress = {},
  type = 'rocket_silo',
  updated = false,
  drawn = false,
  is_hovered = false,
  item_id = 40,
  state = 'wait',
  wait = 0,
  delay = 200,
  requests = {},
  rocket = {},
  tickrate = 5,
}

function Silo:draw()
  local sx, sy = world_to_screen(self.x, self.y)
  
  rect(sx + 8, sy + 8, 16, 16, 0)
  spr(ROCKET_SILO_ID, sx, sy, 1, 1, 0, 0, 2, 2)
  spr(ROCKET_SILO_ID, sx + 16, sy, 1, 1, 1, 0, 2, 2)
  
  if self.state == 'raise' or self.state == 'launch' then
    clip(sx + 8, (sy + 24) - 72, 16, 72)
    spr(ROCKET_ID, sx + 8, sy + 16 - self.anim_frame, 1, 1, 0, 0, 2, 6)
    if self.state == 'launch' then
      rocket_fx(sx + 8, (sy + 16 - self.anim_frame) + 46)
    end
    clip()
  end

  if self.state == 'opening' then
    clip(sx + 8, (sy + 24) - 56, 16, 56)
    spr(ROCKET_ID, sx + 8, sy + 16, 1, 1, 0, 0, 2, 1)
    clip()
  end

  spr(ROCKET_SILO_ID, sx + 16, sy + 16, 1, 1, 3, 0, 2, 2)
  spr(ROCKET_SILO_ID, sx, sy + 16, 1, 1, 2, 0, 2, 2)
  
  clip(sx + 8, sy + 8, 16, 16)
  local offset = ((self.state == 'opening' or self.state == 'closing' or self.state == 'launch_ready') and self.anim_frame) or 0
  if self.state == 'raise' or self.state == 'launch' then offset = 8 end
  for y = 0, 1 do
    for x = 0, 1 do
      if x == 0 then
        spr(370, sx + 8 + x*8 - offset, sy + 8 + y*8)
      else
        spr(370, offset + sx + 8 + x*8, sy + 8 + y*8)
      end
    end
  end
  clip()
  if self.state == 'launch_ready' then
    clip(sx + 8, (sy + 24) - 56, 16, 56)
    spr(ROCKET_ID, sx + 8, sy - 16, 1, 1, 0, 0, 2, 6)
    clip()
  end
  if self.state == 'launch' then
    if self.anim_frame < 56 then
      local d = 4
      poke(0x3FF9,math.random(-d,d))
      poke(0x3FF9+1,math.random(-d,d))
    else
      memset(0x3FF9,0,2)
    end
  end

  -- if self.state == 'launch' then
  --   spr(ROCKET_ID, sx + 8, sy - 16 - self.anim_frame, 1, 1, 0, 0, 2, 1)
  -- end
end

function Silo:draw_hover_widget(x, y)
  x, y = clamp(x or cursor.x + 5, 1, 240 - 63), clamp(y or cursor.y + 5, 1, 136 - 66)
  local w, h = 63, 66
  --local txt = ITEMS[ENTS[self.ent_key].id].fancy_name
  ui.draw_panel(x, y, w, h, UI_BG, UI_FG, 'Rocket Silo', UI_SH)
  ui.progress_bar(math.min(1.0, self.progress/ROCKET_CRAFT_TIME), x + w/2 - 25, y + 12, 50, 6, UI_BG, UI_FG, 6, 0)
  prints('Input', x + w/2 - 12, y + h - 24)
  for k, v in ipairs(self.input) do
    box(x + w/2 - ((#self.input*13)/2) + (k-1)*13, y + h - 15, 10, 10, 8, 9)
    if v.id ~= 0 and v.count > 0 then
      draw_item_stack(x + w/2 - ((#self.input*13)/2) + (k-1)*13 + 1, y + h - 15 + 1, v)
    end
  end
  --draw output items
  prints('Output', x + w/2 - 12, y + 19)
  box(x + w/2 - 6, y + 27, 10, 10, 8, 9)
  if self.output.count > 0 then
    draw_item_stack(x + w/2 - 4, y + 28, {id = self.output.id, count = self.output.count})
  end
end

function Silo:open()
  return {
    x = 240 - 65,
    y = 1,
    w = 63,
    h = 78,
    ent_key = self.x .. '-' .. self.y,
    close = function(self, sx, sy)
      local btn = {x = self.x + self.w - 9, y = self.y + 1, w = 5, h = 5}
      if sx >= btn.x and sy < btn.x + btn.w and sy >= btn.y and sy <= btn.y + btn.h then
        return true
      end
      return false
    end,
    draw = function(self)
      --local txt = ITEMS[ENTS[self.ent_key].id].fancy_name
      local ent = ENTS[self.ent_key]
      ui.draw_panel(self.x, self.y, self.w, self.h, UI_BG, UI_FG, 'Rocket Silo', UI_SH)
      ui.progress_bar(math.min(1.0, ent.progress/ROCKET_CRAFT_TIME), self.x + self.w/2 - 25, self.y + 12, 50, 6, UI_BG, UI_FG, 6, 0)
      sspr(CLOSE_ID, self.x + self.w - 9, self.y + 2, 15)
      prints('Input', (self.x + self.w/2) - text_width('Input')/2, self.y + self.h - 36)
      local start_x, start_y = self.x + self.w/2 - ((#ent.input*13)/2), self.y + self.h - 27
      for k, v in ipairs(ent.input) do
        box(start_x + (k-1)*13, start_y, 10, 10, 8, 9)
        if v.id ~= 0 and v.count > 0 then
          draw_item_stack(start_x + (k-1)*13 + 1, start_y + 1, v)
        end
      end
      --draw output items
      prints('Output', self.x + self.w/2 - 12, self.y + 19)
      box(self.x + self.w/2 - 6, self.y + 27, 10, 10, 8, 9)
      if ent.output.count > 0 then
        draw_item_stack(self.x + self.w/2 - 5, self.y + 28, {id = ent.output.id, count = ent.output.count})
      end
      if hovered(cursor, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
        ui.highlight(self.x + self.w/2 - 6, self.y + 27, 8, 8, false, 3, 4)
        if key(64) then draw_recipe_widget(cursor.x + 5, cursor.y + 5, ent.output.id) end
      end
      --draw cursor item
      if self:is_hovered(cursor.x, cursor.y) and cursor.type == 'item' then
        draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
      end
      --input slots hover
      for k, v in ipairs(ent.input) do
        if hovered(cursor, {x = start_x + (k-1)*13, y = start_y, w = 10, h = 10}) then
          ui.highlight(start_x + (k-1)*13, start_y, 8, 8, false, 3, 4)
          if key(64) then draw_recipe_widget(cursor.x + 5, cursor.y + 5, v.id) end
        end
      end
      if ent.state == 'launch_ready' then
        if ui.draw_text_button((floor(self.x + self.w/2) - (text_width(' Launch ')/2) - 2), self.y + self.h - 12, 113, 8, 8, 9, 0, 3, {text = ' Launch ', x = 1, y = 1, bg = 0, fg = 2, shadow = {x = 1, y = 0}}) then
          --draw launch button
          ent.state = 'launch'
        end
      else
        ui.draw_text_button((floor(self.x + self.w/2) - (text_width(' Launch ')/2) - 2), self.y + self.h - 12, 113, 8, 8, 13, 14, 12, {text = ' Launch ', x = 1, y = 1, bg = 15, fg = 14, shadow = {x = 1, y = 0}}, true)
      end
    end,
    click = function(self, sx, sy)
      local ent = ENTS[self.ent_key]
      if self:close(sx, sy) then
        ui.active_window = nil
        return true
      end
      local start_x, start_y = self.x + self.w/2 - ((#ent.input*13)/2), self.y + self.h - 27
      for k, v in ipairs(ent.input) do
        if hovered(cursor, {x = start_x + (k-1)*13, y = start_y, w = 10, h = 10}) then
          -- ui.highlight(self.x + 13 + (i - 1)*13, self.y + 49, 10, 10, false, 3, 4)
          
          local stack_size = 100
          --item interaction
          if cursor.type == 'pointer' then
            if key(64) then
              local old_count = v.count
              local result, stack = inv:add_item({id = v.id, count = v.count})
              if result then
                v.count = stack.count
                sound('deposit')
                ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                return true
              end
            elseif v.count > 0 then
              if cursor.r and v.count > 1 then
                set_cursor_item({id = v.id, count = math.ceil(v.count/2)}, false)
                v.count = floor(v.count/2)
                return true
              else
                set_cursor_item({id = v.id, count = v.count}, false)
                v.count = 0
                return true
              end
            end
          elseif cursor.type == 'item' and cursor.item_stack.id == v.id then
            --try to combine stacks, leaving extra on cursor
            if key(64) then
              if v.count > 0 then
                local result, stack = inv:add_item({id = v.id, count = v.count})
                if result then
                  v.count = stack.count
                  sound('deposit')
                  ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
                end
              end
              return true
            end
            if cursor.r then
              if v.count + 1 < stack_size then
                v.count = v.count + 1
                cursor.item_stack.count = cursor.item_stack.count - 1
                if cursor.item_stack.count < 1 then
                  set_cursor_item()
                end
                return true
              end
            else
              if cursor.item_stack.count + v.count > stack_size then
                local old_count = v.count
                v.count = stack_size
                cursor.item_stack.count = cursor.item_stack.count - (stack_size - old_count)
                return true
              else
                v.count = v.count + cursor.item_stack.count
                set_cursor_item()
                return true
              end
            end
          end
          
        end
      end
      if ent.output.count > 0 and cursor.type == 'pointer' and hovered({x = sx, y = sy}, {x = self.x + self.w/2 - 6, y = self.y + 27, w = 10, h = 10}) then
        if key(64) then
          local old_count = ent.output.count
          local result, stack = inv:add_item({id = ent.output.id, count = ent.output.count})
          if result then
            ent.output.count = stack.count
            ui.new_alert(cursor.x, cursor.y, '+ ' .. (stack.count == 0 and old_count or old_count - stack.count) .. ' ' .. ITEMS[ent.output.id].fancy_name, 1000, 0, 6)
            sound('deposit')
            return true
          end
        else
          if cursor.r and v.count > 1 then
            set_cursor_item({id = v.id, count = math.ceil(v.count/2)}, false)
            v.count = floor(v.count/2)
            return true
          else
            set_cursor_item({id = ent.output.id, count = ent.output.count})
            ent.output.count = 0
            return true
          end
        end
      end
      return false
    end,
    is_hovered = function(self, x, y)
      return x >= self.x and x < self.x + self.w and y >= self.y and y < self.y + self.h and true or false
    end,
  }
end

function Silo:update()
  if self.state == 'opening' then
    self.anim_frame = self.anim_frame + 1
    if self.anim_frame > 7 then
      self.anim_frame = 0
      self.state = 'raise'
    end
  elseif self.state == 'closing' then
    self.anim_frame = self.anim_frame - 1
    if self.anim_frame < 1 then
      self.anim_frame = 0
      self.state = 'wait'
    end
  elseif self.state == 'wait' then
    for k, v in ipairs(self.input) do
      if v.count < 100 then return end
    end
    for k, v in ipairs(self.input) do
      v.count = 0
    end
    self.state = 'opening'
  elseif self.state == 'return' then
    self.wait = self.wait + 5
    if time() > self.wait + self.delay then
      self.wait = 0
      self.state = 'closing'
    end

  elseif self.state == 'raise' then
    self.anim_frame = self.anim_frame + 1
    if self.anim_frame > 32 then
      self.anim_frame = 32
      self.state = 'launch_ready'
    end
  elseif self.state == 'launch' then
    if self.anim_frame < 56 then
      self.anim_frame = self.anim_frame + 1
    else
      self.state = 'closing'
      self.anim_frame = 8
      new_rocket(self.x, self.y)
      if not launched then
        first_launch()
      end
    end
  end
end

function Silo:update_requests()
  for i = 1, #self.requests do
    --if ingredients are low, request more items
    if self.input[i].count < 100 then
      self.requests[i][1] = true
    end
    --self.requests[i][2] = false 
  end
end

function Silo:get_request()
  for i = 1, #self.requests do
    if self.requests[i][1] and not self.requests[i][2] then
      --self.requests[i][2] = true
      return self.input[i].id
      --now an inserter has been dispatched to retrieve this item
    end
  end
  return false
end

function Silo:deposit(id)
  for k, v in ipairs(self.input) do
    if id == v.id then
      self.input[k].count = self.input[k].count + 1
      self.requests[k][2] = false
      if self.input[k].count > 100 then
        self.requests[k][1] = false
      end
      return true
    end
  end
  return false
end

function Silo:deposit_stack(stack)
  for k, v in ipairs(self.input) do
    if v.id == stack.id then
      local stack_size = 100
      if v.count < stack_size then
        if v.count + stack.count <= stack_size then
          v.count = v.count + stack.count
          return true, {id = 0, count = 0}
        elseif v.count + stack.count > stack_size then
          stack.count = stack.count - (stack_size - v.count)
          v.count = stack_size
          return true, stack
        end
        return false, stack
      end
    end
  end
  return false, stack
end

function Silo:request_deposit()
  return self:get_request()
end

function Silo:item_request(id)
  if (id == 'any' or id == self.output.id) and self.output.count > 0 then
    self.output.count = self.output.count - 1
    return self.output.id
  end
  return false
end

function Silo:assign_delivery(id)
  for k, v in ipairs(self.input) do
    if v.id == id then
      self.requests[k][2] = true
      return
    end
  end
end

function Silo:return_all()
  for k, v in ipairs(self.input) do
    if v.count > 0 then
      local _, stack = inv:add_item({id = v.id, count = v.count})
      if stack.count ~= v.count then
        ui.new_alert(cursor.x, cursor.y, '+ ' .. v.count - stack.count .. ' ' .. ITEMS[v.id].fancy_name, 1000, 0, 6)
        v.count = stack.count
      end
    end
  end
  if self.output.count > 0 then
    local _, stack = inv:add_item({id = self.output.id, count = self.output.count})
    if stack.count ~= self.output.count then
      ui.new_alert(cursor.x, cursor.y, '+ ' .. self.output.count - stack.count .. ' ' .. ITEMS[self.output.id].fancy_name, 1000, 0, 6)
      self.output.count = stack.count
    end
  end
end

function rocket_fx(x, y)
  spr(ROCKET_FX_ID, x, y, 0, 1, tick%10 > 5 and 0 or 1, 0, 2, 1)
end

function new_rocket(wx, wy)
  local rocket = {
    wx = wx,
    wy = wy,
    parent = wx .. '-' .. wy,
    anim_frame = 0,
    update = function(self)
      if self.anim_frame < 500 then
        self.anim_frame = self.anim_frame + 1
      else
        if ENTS[self.parent] then
          ENTS[self.parent].output.count = 1000
        end
        if rockets[self.parent] then
          rockets[self.parent] = nil
        end
        -- if not launched then
        --   first_launch()
        -- end
      end
    end,
    draw = function(self)
      local sx, sy = world_to_screen(self.wx, self.wy)
      spr(ROCKET_ID, floor(sx + 8), floor(sy - 40 - self.anim_frame), 1, 1, 0, 0, 2, 6)
      rocket_fx(floor(sx + 8), floor(sy - 40 - self.anim_frame) + 46)
      local d = 4
      poke(0x3FF9,math.random(-d,d))
      poke(0x3FF9+1,math.random(-d,d))
      if self.anim_frame >= 500 then
        memset(0x3FF9,0,2)
      end
    end,
  }
  rockets[wx .. '-' .. wy] = rocket
end

function new_silo(x, y)
  local newSilo = {
    x = x,
    y = y,
    anim_frame = 0,
    input = {
      {id = 41, count = 0},
      {id = 42, count = 0},
      {id = 43, count = 0}
    },
    requests = {
      {true, false},
      {true, false},
      {true, false},
    },
    output = {id = 44, count = 0},
    progress = 0,
    rocket = {},
  }
  setmetatable(newSilo, {__index = Silo})
  return newSilo
end

local seed = tstamp() * time()
--local seed = 172046262608.13
seed = math.random(-1000000000, 1000000000)
--local seed = 902404786
--local seed = 747070313
--math.randomseed(53264)
math.randomseed(seed)
offset = math.random(100000, 500000)
simplex.seed()
TileMan = TileManager:new()
floor = math.floor
sspr = spr
biome = 1
db_time = 0.0
last_frame_time = time()
STATE = 'start'
current_recipe = {x = 0, y = 0, id = 0}
--image = require('\\assets\\fullscreen_images')
--------------------COUNTERS--------------------------
tick = 0
-------------GAME-OBJECTS-AND-CONTAINERS---------------
ENTS = {}
ORES = {}
CURSOR_POINTER = 286
CURSOR_HIGHLIGHT = 309
CURSOR_HIGHLIGHT_CORNER = 307
CURSOR_HIGHLIGHT_CORNER_S = 336
CURSOR_HAND_ID = 320
CURSOR_GRAB_ID = 321
WATER_SPRITE = 224
CURSOR_MINING_SPEED = 50
technology = {}
rockets = {}
launched = false
current_help = 1
help = {
  [1] = {
    name = 'Controls 1/2',
    info = {
      {'W A S D', 'Move player'},
      {'RIGHT CLICK', 'Grab half stack or deposit 1 item'},
      {'^ - HOLD', 'Mine resource or destroy object'},
      {'I or TAB', 'Toggle inventory window'},
      {'SHIFT + ALT', 'Toggle item count'},
      {'SHIFT', 'Show item count, inspect tile'},
      {'C', 'Toggle crafting window'},
      {'T', 'Toggle research window'},
      {'R', 'Rotate held item or hovered object'},
      {'Q', 'Pipette tool - copy/swap objects'},
      {'LEFT-CLICK', 'Place-item/interact'},
      {'SHIFT + L-CLICK', 'Quick-move, or deposit to ent'},
      {'CTRL + L-CLICK', 'Take all from hovered ent'},
      {'SCROLL +/-', 'Scroll active hotbar slot'},
      {'M', 'Toggle world-map'},
      {'ESC', 'Exit game'},
      {'CTRL + R', 'Reload game'},
    }
  },
  [2] = {
    name = 'Controls 2/2',
    info = {
      {'O', 'Toggle help window'}
    }
  },
  [3] = {
    name = 'Getting Started 1/2',
    info = {
      [1] = 'To get started, first you should mine up some stone, by either destroying loose stones or by mining a stone ore deposit.',
      [2] = 'Once you have 10 stone ore, hit \'C\' to open the crafting window, and craft a few furnaces. You can click the tabs to switch pages.',
      [3] = 'Now that you have a few furnaces, you will have to manually mine up some iron and copper ore, and smelt into plates.',
      [4] = 'Next, craft a research lab, and then red science packs, in order to begin researching new technologies.',
      [5] = 'Start by researching Automation and Logistics, which will unlock inserters, splitters, underground belts, and assembly machines, unlocking the ability to fully automate your factory.'
    }
  },
  [4] = {
    name = 'Getting Started 2/2',
    info = {
      [1] = 'To begin researching a new technology, either manually place some science packs into your research lab, or use inserters. The inserters are smart enough to divide the science packs between the labs, so long as you have inserters between them, and at least 3 science packs in any lab to share',
      [2] = 'Now hit \'T\' to open the tech screen, select a technology, and click the little play button to begin. The labs will begin a flashing animation to indicate current research is active',
      [3] = 'The end goal is to craft a rocket silo, and launch a rocket into space!',
      [4] = 'To get there, you will need all 4 science packs unlocked, as well as their required technologies',
    }
  },
  [5] = {
    name = 'Credits 1/2',
    info = {
      [1] = 'This game is dedicated to Joshua Ryen Hall, March 31, 1986 - May 1, 2022. My dear brother, may you rest in peace. You will alawys be in my heart.',
      [2] = '@Vebrun - Thank you for helping with sprites, and many discussions about direction and gameplay',
      [3] = '@Ban this ^ guy - For gameplay discussions and ideas',
      [4] = '@Vand - Particle system for F4R3TR',
      [5] = 'Factorio & Wube Software, for making an incredible cult hit',
      [6] = '@Nesbox - For creating the Tic80 platform making this de-make possible'
    }
  },
  [6] = {
    name = 'Credits 2/2',
    info = {
      [1] = '@Skeptim - Playtesting and feedback',
      [2] = '@Breck - Playtesting and feedback',
      [3] = '@Astropulse - For creating the RetroDiffusion Aseprite plugin, used to create trees, clutter, and ores. https://astropulse.co/#retrodiffusion',
    }
  },
}

cursor = {
  x = 8,
  y = 8,
  id = 352,
  lx = 8,
  ly = 8,
  tx = 8,
  ty = 8,
  wx = 0,
  wy = 0,
  sx = 0,
  sy = 0,
  lsx = 0,
  lsy = 0,
  l = false,
  ll = false,
  m = false,
  lm = false,
  r = false,
  lr = false,
  prog = false,
  rot = 0,
  last_rotation = 0,
  hold_time = 0,
  type = 'pointer',
  item = 'transport_belt',
  drag = false,
  panel_drag = false,
  drag_dir = 0,
  drag_loc = {x = 0, y = 0},
  hand_item = {id = 0, count = 0},
  drag_offset = {x = 0, y = 0},
  item_stack = {id = 0, count = 0, slot = false}
}

player = {
  x = 100*8, y = 50*8,
  spr = 362,
  lx = 0, ly = 0,
  shadow = 382,
  anim_frame = 0, anim_speed = 8, anim_dir = 0, anim_max = 4, anim_tickrate = 17*10, last_anim_time = time(),
  last_dir = '0,0', move_speed = 0.125,
  directions = {
    ['0,0'] =   {id = 362, flip = 0, rot = 0, dust = vec2(4, 11)},  --straight
    ['0,-1'] =  {id = 365, flip = 0, rot = 0, dust = vec2(4, 11)},  --up
    ['0,1'] =   {id = 365, flip = 2, rot = 0, dust = vec2(4, -2)},  --down
    ['-1,0'] =  {id = 363, flip = 1, rot = 0, dust = vec2(11, 5)},  --left
    ['1,0'] =   {id = 363, flip = 0, rot = 0, dust = vec2(-2, 5)},  --right
    ['1,-1'] =  {id = 364, flip = 0, rot = 0, dust = vec2(-2, 10)},  --up-right
    ['-1,-1'] = {id = 364, flip = 1, rot = 0, dust = vec2(10, 10)},  --up-left
    ['-1,1'] =  {id = 364, flip = 3, rot = 0, dust = vec2(10, -2)},  --down-left
    ['1,1'] =   {id = 364, flip = 2, rot = 0, dust = vec2(-2, -2)}   --down-right
  },
}

dummies = {
  ['dummy_furnace'] = true,
  ['dummy_assembler'] = true,
  ['dummy_drill'] = true,
  ['dummy_lab'] = true,
  ['dummy_splitter'] = true,
  ['dummy_refinery'] = true,
  ['dummy_silo'] = true,
}

opensies = {
  ['stone_furnace'] = true,
  ['assembly_machine'] = true,
  ['research_lab'] = true,
  ['chest'] = true,
  ['mining_drill'] = true,
  ['bio_refinery'] = true,
  ['rocket_silo'] = true,
}

inv = make_inventory()
-- local starting_items = {
--   {id = 32, slot =  1},
--   {id = 32, slot =  2},
--   {id = 32, slot =  3},
--   {id = 32, slot =  4},
--   {id = 32, slot =  5},
--   {id = 26, slot =  6},
--   {id =  6, slot =  7},
--   {id =  8, slot =  8},
--   {id = 32, slot =  9},
--   {id = 20, slot = 10},
--   {id = 15, slot = 11},
--   {id = 14, slot = 12},
--   {id = 40, slot = 13},
--   {id = 41, slot = 14},
--   {id = 42, slot = 15},
--   {id = 43, slot = 16},
--   {id =  9, slot = 57},
--   {id = 18, slot = 58},
--   {id = 11, slot = 59},
--   {id = 13, slot = 60},
--   {id = 14, slot = 61},
--   {id = 22, slot = 62},
--   {id = 19, slot = 63},
--   {id = 10, slot = 64},
-- }
-- for k,v in ipairs(starting_items) do
--   inv.slots[v.slot].id = v.id
--   inv.slots[v.slot].count = ITEMS[v.id].stack_size
-- end

craft_menu = ui.NewCraftPanel(135, 1)
vis_ents = {}
show_mini_map = false
show_tile_widget = false
debug = false
alt_mode = false
show_tech = false
show_count = false
--water effect defs
local num_colors = 3
local start_color = 8
local tileSize = 8
local tileCount = 1
local amplitude = num_colors
local frequency = 0.185
local speed = 0.0022
--------------------
sounds = {
  ['deny']        = {id =  5, note = 'C-3', duration = 22, channel = 0, volume = 10, speed = 0},
  ['place_belt']  = {id =  4, note = 'B-3', duration = 10, channel = 1, volume =  8, speed = 4},
  ['delete']      = {id =  2, note = 'C-3', duration =  4, channel = 1, volume =  9, speed = 5},
  ['rotate_r']    = {id =  3, note = 'E-5', duration = 10, channel = 1, volume =  8, speed = 3},
  ['rotate_l']    = {id =  7, note = 'E-5', duration =  5, channel = 2, volume =  8, speed = 4},
  ['move_cursor'] = {id =  0, note = 'C-4', duration =  4, channel = 0, volume =  8, speed = 5},
  ['axe']         = {id =  9, note = 'D-3', duration = 20, channel = 0, volume =  6, speed = 4},
  ['laser']       = {id =  0, note = 'D-3', duration =  5, channel = 0, volume =  4, speed = 7},
  ['move']        = {id = 10, note = 'D-3', duration =  5, channel = 3, volume =  2, speed = 5},
  ['deposit']     = {id = 11, note = 'D-6', duration =  3, channel = 1, volume =  5, speed = 7},
  ['tech_done']   = {id = 12, note = 'D-8', duration = 50, channel = 2, volume = 10, speed = 6},
  ['tech_add']    = {id = 13, note = 'G-5', duration = 50, channel = 1, volume = 10, speed = 6},
}

resources = {
  ['2']  = {name = 'Petrified Fossil', id = 5, min =  5, max = 20}, --rocks
  ['7']  = {name = 'Medium Rock', id = 5, min =  5, max = 10},
  ['8']  = {name = 'Pebble', id = 5, min =  1, max =  3},
  ['9']  = {name = 'Bone', id = 5, min =  1, max =  3},
  ['10'] = {name = 'Skull', id = 5, min =  5, max =  10},
  ['24'] = {name = 'Small Rock', id = 5, min =  1, max =  3},
  ['26'] = {name = 'Medium Rock', id = 5, min =  4, max = 15},
  ['40'] = {name = 'Medium Rock', id = 5, min =  4, max = 15},
  ['42'] = {name = 'Large Rock', id = 5, min =  4, max = 15},

  ['3']  = {name = 'Cactus Sprouts', id = 32, min = 5, max = 12}, --fiber
  ['4']  = {name = 'Wildflower Patch', id = 32, min = 10, max = 20},
  ['5']  = {name = 'Flowering Cactus', id = 32, min = 19, max = 45},
  ['6']  = {name = 'Large Wildflower', id = 32, min = 5, max = 17},
  ['1']  = {name = 'Palm Sprout', id = 32, min = 5, max = 12},
  ['17'] = {name = 'Grass', id = 32, min = 5, max = 12},
  ['18'] = {name = 'Small Wildflowers', id = 32, min = 5, max = 12},
  ['19'] = {name = 'Grass', id = 32, min = 5, max = 12},
  ['20'] = {name = 'Bean Sprouts', id = 32, min = 5, max = 12},
  ['21'] = {name = 'Wildflower', id = 32, min = 5, max = 12},
  ['22'] = {name = 'Wildflower', id = 32, min = 5, max = 12},
  ['23'] = {name = 'Fungal Sprout', id = 32, min = 5, max = 15},
  ['33'] = {name = 'Grass', id = 32, min = 5, max = 12},
  ['34'] = {name = 'Grass', id = 32, min = 5, max = 12},
  ['35'] = {name = 'Large Grass Patch', id = 32, min = 5, max = 12},
  ['36'] = {name = 'Wildflower Stem', id = 32, min = 5, max = 12},
  ['37'] = {name = 'Small Wildflowers', id = 32, min = 5, max = 12},
  ['39'] = {name = 'Grass', id = 32, min = 5, max = 12},

}

dust = {}

_t = 0
sprites = {}
loaded = false

function BOOT()
  spawn_player()
  -- local tile, _, _ = get_world_cell(player.x, player.y)
  -- biome = tile.biome
  cls(0)
  --poke(0x3FF8, 0)
  draw_image(0,0,240,136,cover,-1)
  vbank(1)
  --poke(0x3FF8, 1)
  --cls(0)
   --poke(0x03FF8, 0)
   
end

function hovered(_mouse, _box)
  local mx, my, bx, by, bw, bh = _mouse.x, _mouse.y, _box.x, _box.y, _box.w, _box.h
  return mx >= bx and mx < bx + bw and my >= by and my < by + bh
end

function pokey(bnk,sid,tw,th,x,y,ck,rot)
  rot = rot or 0
  if bnk == 0 then sspr(sid, x, y, ck, 1, 0, rot, tw, th) return end
  for ty=0,th-1 do
    for tx=0,tw-1 do
      for sy=0,7 do
        for sx=0,7 do
          local px = x + tx * 8 + sx
          local py = y + ty * 8 + sy
          local pixel = sprites[bnk][(sid + tx + ty * 16)][sy * 8 + sx]

          -- Check if pixel matches color_key
          local skip_pixel = false
          if type(ck) == 'table' then
            -- If color_key is a table, check if pixel is in the table
            for _, value in ipairs(ck) do
              if pixel == value then
                skip_pixel = true
                break
              end
            end
          else
            -- If color_key is a single value, directly compare with pixel
            if pixel == ck then
              skip_pixel = true
            end
          end

          -- Skip drawing this pixel if it matches the color_key
          if skip_pixel then
            goto continue
          end

          local addr = (py * 240 + px) // 2
          if px % 2 == 0 then
            -- Modify the least significant nibble
            local byte = peek(addr)
            byte = (byte & 0xF0) | pixel
            poke(addr, byte)
          else
            -- Modify the most significant nibble
            local byte = peek(addr)
            byte = (byte & 0x0F) | (pixel << 4)
            poke(addr, byte)
          end

          ::continue::
        end
      end
    end
  end
end

function load_sprites()
  local s = "Loading Bank ".. _t .. (("."):rep((_t+1)%4))
  local _w = print(s,0,-6)
  prints(s,(240//2)-(_w//2),65)
  if _t==8 then sync(0,0,false) loaded = true return end
  sync(0,_t,false)
  sprites[_t] = {}
  for i=0,511 do
    sprites[_t][i] = {}
    for j=0,31 do
      local byte = peek(0x4000 + i * 32 + j)
      sprites[_t][i][j*2] = byte & 0x0F
      sprites[_t][i][j*2 + 1] = (byte >> 4) & 0x0F
    end
  end
  _t=_t+1
end

function move(o)
  o.x = o.x + o.vx
  o.y = o.y + o.vy
end

function particles()
  for i,d in pairs(dust) do
    move(d)
    d.vx, d.vy = d.vx * 1.015, d.vy * 1.015    
    --if (d.t//1)%5==0 and d.c>3 then d.c=d.c-1 end    
    if d.t < 5 then d.r = d.r/1.1 d.c = d.c - (d.c > 3 and 1 or 0) end
    d.t = d.t - 1 + math.random()
    if d.r < 1 then	table.remove(dust, i) end
  end
end

function new_dust(x_, y_, r_, vx_, vy_)
  for i = 0, 1 do
    table.insert(dust, {x = x_, y = y_, c = 4, ty = math.random(-1, 1), vx = vx_, vy = vy_, r = math.random() * r_, t = 5 * r_})
  end
end

function draw_dust()
  if not show_mini_map and not craft_menu.vis and not inv.vis and not show_tech then
    for i,d in pairs(dust) do
      if d.ty>=0 then	circ(d.x,d.y,d.r,d.c)
      else circb(d.x,d.y,d.r,d.c+1) end
    end
  end
end

function get_sprite_pixel(sprite_id, x, y)
  --Arguments: sprite_id (0-511), x (0-7), y (0-7)
  local byte = peek(0x04000 + sprite_id * 32 + y * 4 + math.floor(x / 2))
  return x % 2 == 0 and byte % 16 or byte // 16
end

function set_sprite_pixel(sprite_id, x, y, color)
  --Arguments: sprite_id (0-511), x (0-7), y (0-7), color (palette index 0-15)
  local addr = 0x04000 + sprite_id * 32 + y * 4 + math.floor(x / 2)
  local byte = peek(addr)
  if x % 2 == 0 then poke(addr, (byte - byte % 16) + color) else poke(addr, (color * 16) + byte % 16) end
end

function sound(name)
  if sounds[name] then
    local s = sounds[name]
    sfx(s.id, s.note, s.duration, s.channel, s.volume, s.speed)
  end
end

function update_water_effect(time)
  for sprite_id = 0, (tileCount * tileCount) - 1 do
    for y = 0, tileSize - 1 do
      for x = 0, tileSize - 1 do
        local worldX = (sprite_id % tileCount) * tileSize + x
        local worldY = math.floor(sprite_id / tileCount) * tileSize + y
        local tileX = worldX % (tileSize * tileCount)
        local tileY = worldY % (tileSize * tileCount)
        local noiseValue = simplex.Noise2D(((tileX + time * speed) * frequency), (tileY + time * speed) * frequency)
        local color = math.floor(((noiseValue + 1) / 2) * amplitude) + start_color
        set_sprite_pixel(224, x, y, color)
      end
    end
  end
end

function get_visible_ents()
  vis_ents = {
    ['transport_belt'] = {},
    ['inserter'] = {},
    --['power_pole'] = {},
    ['splitter'] = {},
    ['mining_drill'] = {},
    ['stone_furnace'] = {},
    ['underground_belt'] = {},
    --['underground_belt_exit'] = {},
    ['assembly_machine'] = {},
    ['research_lab'] = {},
    ['chest'] = {},
    ['bio_refinery'] = {},
    ['rocket_silo'] = {},
  }
  for x = 1, 31 do
    for y = 1, 18 do
      local worldX = (x*8) + (player.x - 116)
      local worldY = (y*8) + (player.y - 64)
      local cellX = floor(worldX / 8)
      local cellY = floor(worldY / 8)
      local k = cellX .. '-' .. cellY
      if ENTS[k] and vis_ents[ENTS[k].type] then
        local type = ENTS[k].type
        local index = #vis_ents[type] + 1
        vis_ents[type][index] = k
      end
    end
  end
end

function get_ent(x, y)
  local k = get_key(x, y)
  if not ENTS[k] then
    return false
  end

  if ENTS[k].type == 'splitter' then return k end
  if ENTS[k].type == 'underground_belt_exit' then return ENTS[k].other_key, true end
  if ENTS[k].type == 'underground_belt' then return k end
  if ENTS[k].other_key then return ENTS[k].other_key else return k end
  return false
end

function get_key(x, y)
  local _, wx, wy = get_world_cell(x, y)
  return wx .. '-' .. wy
end

function get_world_key(x, y)
  return x .. '-' .. y
end

function world_to_screen(world_x, world_y)
  local screen_x = (world_x * 8) - (player.x - 116)
  local screen_y = (world_y * 8) - (player.y - 64)
  return screen_x - 8, screen_y - 8
end

function screen_to_world(screen_x, screen_y)
  local cam_x = player.x - 116
  local cam_y = player.y - 64
  local sub_tile_x = cam_x % 8
  local sub_tile_y = cam_y % 8
  local sx = floor((screen_x + sub_tile_x) / 8)
  local sy = floor((screen_y + sub_tile_y) / 8)
  local wx = floor(cam_x / 8) + sx + 1
  local wy = floor(cam_y / 8) + sy + 1
  return wx, wy
end

function get_cell(x, y)
  return x - (x % 8), y - (y % 8)
end

function get_screen_cell(mouse_x, mouse_y)
  local cam_x, cam_y = 116 - player.x, 64 - player.y
  local mx = floor(cam_x) % 8
  local my = floor(cam_y) % 8
  return mouse_x - ((mouse_x - mx) % 8), mouse_y - ((mouse_y - my) % 8)
end

function get_world_cell(mouse_x, mouse_y)
  local cam_x = player.x - 116 + 1
  local cam_y = player.y - 64 + 1
  local sub_tile_x = cam_x % 8
  local sub_tile_y = cam_y % 8
  local sx = floor((mouse_x + sub_tile_x) / 8)
  local sy = floor((mouse_y + sub_tile_y) / 8)
  local wx = floor(cam_x / 8) + sx + 1
  local wy = floor(cam_y / 8) + sy + 1
  return TileMan.tiles[wy][wx], wx, wy
end

function highlight_ent(k)

end

function pal(c0, c1)
  if not c0 and not c1 then
    for i = 0, 15 do
      poke4(0x3FF0 * 2 + i, i)
    end
  elseif type(c0) == 'table' then
    for i = 1, #c0, 2 do
      poke4(0x3FF0*2 + c0[i], c0[i + 1])
    end
  else
    poke4(0x3FF0*2 + c0, c1)
  end
end

function clamp(val, min, max)
  return math.max(min, math.min(val, max))
end

function prints(text, x, y, bg, fg, shadow_offset, size)
  shadow_offset = shadow_offset or {x = 1, y = 0}
  size = not size
  bg, fg = bg or 0, fg or 4
  print(text, x + shadow_offset.x, y + shadow_offset.y, bg, false, 1, size)
  print(text, x, y, fg, false, 1, size)
end

function lerp(a,b,mu)
  return a*(1-mu)+b*mu
end
--------------------------------------------------------------------------------------

function spawn_player()
  local tile = get_world_cell(player.x, player.y)
  if not tile.is_land then
    while tile.is_land == false do
      player.x = player.x + 8
      tile = get_world_cell(player.x, player.y)
    end
  end
end

function remap(n, a, b, c, d)
  return c + (n - a) * (d - c) / (b - a)
end

function is_water(x, y)
  local tile = get_world_cell(x, y)
  if not tile.is_land then
    sound('deny')
    return true
  end
  return false
end

function new_item_stack(id, count)
  return{
    id = id,
    count = count,
    name = ITEMS[id].name
  }
end

function is_facing(self, other, side)
  local rotations = {
    [0] = {['left'] = 1, ['right'] = 3},
    [1] = {['left'] = 2, ['right'] = 0},
    [2] = {['left'] = 3, ['right'] = 1},
    [3] = {['left'] = 0, ['right'] = 2},
  }
  if rotations[self.rot][side] == other.rot then return true else return false end
end

function move_player(x, y)
  local tile, wx, wy = get_world_cell(116 + x, 76 + y)
  local sx, sy = world_to_screen(wx, wy)
  player.x, player.y = player.x + x, player.y + y
end

function update_player(dt)
  if time() - player.last_anim_time >= player.anim_tickrate then
    player.last_anim_time = time()
    if player.anim_dir == 0 then
      player.anim_frame = player.anim_frame + 1
      if player.anim_frame > player.anim_max then
        player.anim_dir = 1
        player.anim_frame = player.anim_max
      end
    else
      player.anim_frame = player.anim_frame - 1
      if player.anim_frame < 0 then
        player.anim_dir = 0
        player.anim_frame = 0
      end
    end
  end
  player.lx, player.ly = player.x, player.y
  local x_dir, y_dir = 0, 0
  if key(23) then --w
    y_dir = -1
  end
  if key(19) then --s
    y_dir = 1
  end
  if key(1)  then --a
    x_dir = -1
  end
  if key(4)  then --d
    x_dir = 1
  end
  if not cursor.prog then
    local dust_dir = player.directions[x_dir .. ',' .. y_dir].dust
    local dx, dy = 240/2 - 4 + dust_dir.x, 136/2 - 4 + player.anim_frame + dust_dir.y
    if dust_dir and (x_dir ~= 0 or y_dir ~= 0) then
      new_dust(dx, dy, 2, math.random(-1,1) + (3*-x_dir), math.random() + (3*-y_dir))
    elseif tick%24 == 0 then
      new_dust(dx, dy, 2, math.random(-1,1) + (3*-x_dir), math.random() + (3*-y_dir))
    end
    if x_dir ~= 0 or y_dir ~= 0 then
      sound('move')
      move_player(x_dir * player.move_speed*dt, y_dir * player.move_speed*dt)
    end
  end
    player.last_dir = x_dir .. ',' .. y_dir
end

function draw_player()
  local sx, sy = get_screen_cell(120, 76)
  local tile, wx, wy = get_world_cell(sx, sy)
  -- if biome ~= tile.biome and not show_tech then
  --   biome = tile.biome
  --   poke(0x03FF8, biomes[tile.biome].map_col)
  -- end
  if alt_mode then ui.highlight(sx-1, sy-1, 8, 8, false, 5, 6) end
  local sprite = player.directions[player.last_dir] or player.directions['0,0']
  sspr(player.shadow - player.anim_frame, 240/2 - 4, 136/2 + 8, 0)
  draw_dust()
  sspr(sprite.id, 240/2 - 4, 136/2 - 4 + player.anim_frame, 0, 1, sprite.flip)
end

function cycle_hotbar(dir)
  if cursor.type == 'item' and cursor.item_stack then
    if cursor.item_stack.slot then
      inv.slots[cursor.item_stack.slot].id = cursor.item_stack.id
      inv.slots[cursor.item_stack.slot].count = cursor.item_stack.count
      --set_cursor_item()
    else
      inv:add_item({id = cursor.item_stack.id, count = cursor.item_stack.count})
      --set_cursor_item()
    end
  end
  inv.active_slot = inv.active_slot + dir
  if inv.active_slot < 1 then inv.active_slot = INVENTORY_COLS end
  if inv.active_slot > INVENTORY_COLS then inv.active_slot = 1 end
  set_active_slot(inv.active_slot)
end

function set_active_slot(slot)
  inv.active_slot = slot
  local id = inv.slots[slot + INV_HOTBAR_OFFSET].id
  if id ~= 0 then
    cursor.item = ITEMS[id].name
    cursor.item_stack = {id = id, count = inv.slots[slot + INV_HOTBAR_OFFSET].count, slot = slot + INV_HOTBAR_OFFSET}
    cursor.type = 'item'
  else
    cursor.item = false
    cursor.type = 'pointer'
    cursor.item_stack = {id = 0, count = 0, slot = false}
  end
end

function add_item(x, y, id)
  local k = get_key(x, y)
  if ENTS[k] and ENTS[k].type == 'transport_belt' then
    ENTS[k].idle = false
    ENTS[k].lanes[1][8] = id
    ENTS[k].lanes[2][8] = id
  end
end

function draw_debug_window(data, x, y)
  if debug then
    x, y = x or 2, y or 2
    local width = 74
    local height = (#data * 6) + 5
    ui.draw_panel(x, y, width, height, 0, 2, _, 0)
    for i = 1, #data do
      prints(data[i], x + 4, i*6 + y - 3, 0, 11)
    end
  end
end

function draw_ground_items()
  -- for i = 1, #GROUND_ITEMS do
  --   if GROUND_ITEMS[i][1] > 0 then
  --     draw_pixel_ssprite(GROUND_ITEMS[i][1], GROUND_ITEMS[i][2], GROUND_ITEMS[i][3])
  --   end
  -- end
end

function move_cursor(dir, x, y)
  if dir == 'up' then
    if get_flags(cursor.tx, cursor.ty - 8, 0) then cursor.ty = cursor.ty - 8 sound('move_cursor') end
  elseif dir == 'down' then
    if get_flags(cursor.tx, cursor.ty + 8, 0) then cursor.ty = cursor.ty + 8 sound('move_cursor') end
  elseif dir == 'left' then
    if get_flags(cursor.tx - 8, cursor.ty, 0) then cursor.tx = cursor.tx - 8 sound('move_cursor') end
  elseif dir == 'right' then
    if get_flags(cursor.tx + 8, cursor.ty, 0) then cursor.tx = cursor.tx + 8 sound('move_cursor') end
  end
  if dir == 'mouse' then
    cursor.tx, cursor.ty = get_screen_cell(x, y)
  end 
end

function draw_cursor()
  local x, y = cursor.x, cursor.y
  local tile, wx, wy = get_world_cell(x, y)
  local sx, sy = world_to_screen(wx, wy)
  local k = get_key(x, y)
  local ent = ENTS[k]

  if inv:is_hovered(x, y) or craft_menu:is_hovered(x, y) or (ui.active_window and ui.active_window:is_hovered(cursor.x, cursor.y)) then
    if cursor.panel_drag then
      sspr(CURSOR_GRAB_ID, cursor.x - 1, cursor.y - 1, 0, 1, 0, 0, 1, 1)
    else
      sspr(CURSOR_HAND_ID, cursor.x - 2, cursor.y, 0, 1, 0, 0, 1, 1)
    end
    if cursor.type == 'item' and cursor.item then
      -- draw_item_stack(cursor.x + 3, cursor.y + 3, cursor.item_stack)
    end
    return
  end
  
  if cursor.type == 'item' and cursor.item then
    if callbacks[cursor.item] then
      callbacks[cursor.item].draw_item(x, y)
    else
      local y = 5
      if ent and key(64) then y = -8 end
      draw_item_stack(cursor.x + 5, cursor.y + y, cursor.item_stack)
    end
  end

  if cursor.type == 'item' and ITEMS[cursor.item_stack.id].type ~= 'placeable' then
    draw_item_stack(cursor.x + 5, cursor.y + 5, {id = cursor.item_stack.id, count = cursor.item_stack.count})
  end
  if cursor.type == 'pointer' then
    local k = get_key(cursor.x, cursor.y)
    if ui.active_window and ui.active_window:is_hovered(cursor.x, cursor.y) then
      
    end
    sspr(CURSOR_POINTER, cursor.x, cursor.y, 0, 1, 0, 0, 1, 1)
    --if show_tile_widget and not cursor.prog then
    if not cursor.prog then
      if tile.is_tree and not ent then
        local sx, sy = world_to_screen(wx, wy)
        local c1, c2 = 3, 4
        if tile.biome < 2 then c1, c2 = 2, 3 end
        ui.highlight(sx - 9 + tile.offset.x, sy - 27 + tile.offset.y, 24, 32, false, c1, c2)
      end
      ui.highlight(cursor.tx - 1, cursor.ty - 1, 8, 8, false, 2, 2)
    end
  end
end

function rotate_cursor(dir)
  dir = dir or 'r'
  if not cursor.drag then
    cursor.rot = (dir == 'r' and cursor.rot + 1) or (cursor.rot - 1)
    if cursor.rot > 3 then cursor.rot = 0 end
    if cursor.rot < 0 then cursor.rot = 3 end
    local k = get_key(cursor.x, cursor.y)
    local tile, cell_x, cell_y = get_world_cell(cursor.x, cursor.y)
    if ENTS[k] then
      if ENTS[k].type == 'transport_belt' and cursor.type == 'pointer' then
        sound('rotate_' .. dir)
        ENTS[k]:rotate(ENTS[k].rot + 1)
        local tiles = {
          [1] = {x = cell_x, y = cell_y - 1},
          [2] = {x = cell_x + 1, y = cell_y},
          [3] = {x = cell_x, y = cell_y + 1},
          [4] = {x = cell_x - 1, y = cell_y}}
        for i = 1, 4 do
          local k = get_world_key(tiles[i].x, tiles[i].y)
          if ENTS[k] and ENTS[k].type == 'transport_belt' then ENTS[k]:set_curved() end
        end
      end
      if ENTS[k].type == 'inserter' and cursor.type == 'pointer' then
        sound('rotate_' .. dir)
        ENTS[k]:rotate(ENTS[k].rot + 1)
      end
    end
  end
  if cursor.type == 'item' then sound('rotate_' .. dir) end
end

function remove_tile(x, y)
  local sx, sy = get_screen_cell(x, y)
  local tile, wx, wy = get_world_cell(x, y)
  -- local sx, sy = screen_to_world(x, y)
  -- local tile, wx, wy = get_world_cell(sx, sy)
  local k = get_ent(x, y)
  if k and cursor.tx == cursor.ltx and cursor.ty == cursor.lty then
    --add item back to inventory
    local stack = {id = ENTS[k].item_id, count = 1}
    if ENTS[k].type == 'underground_belt' and ENTS[k].exit_key then
      stack.count = 2
    end
    if ENTS[k].return_all then ENTS[k]:return_all() end
    callbacks[ENTS[k].type].remove_item(x, y)
    --trace('adding item_id: ' .. tostring(stack.id) .. ' to inventory')
    ui.new_alert(cursor.x, cursor.y, '+ ' .. stack.count .. ' ' .. ITEMS[stack.id].fancy_name, 1500, 0, 4)
    inv:add_item(stack, 1)
    return
  end
  if cursor.held_right and cursor.tx == cursor.ltx and cursor.ty == cursor.lty then
    local result = resources[tostring(tile.sprite_id)]
    if result then
      local deposit = {id = result.id, count = floor(math.random(result.min, result.max))}
      ui.new_alert(cursor.x, cursor.y, '+ ' .. deposit.count .. ' ' .. ITEMS[deposit.id].fancy_name, 1000, 0, 6)
      inv:add_item(deposit, 1)
      --trace('adding mined resource to inventory')
      TileMan:set_tile(wx, wy)
      sound('delete')
    end


    if tile.is_tree then
      --deposit wood to inventory
      local count = floor(math.random(3, 10))
      local result, stack = inv:add_item({id = 28, count = count}, 1)
      if result then 
        ui.new_alert(cursor.x, cursor.y, '+ ' .. count .. ' ' .. ITEMS[28].fancy_name, 1000, 0, 6)
      end
      TileMan:set_tile(wx, wy)
      sound('delete')
    end

    if tile.ore then
      local k = get_key(x, y)
      if not ORES[k] then
        local max_ore = floor(math.random(250, 5000))
        local ore = {
          type = ores[tile.ore].name,
          tile_id = ores[tile.ore].tile_id,
          sprite_id = ores[tile.ore].sprite_id,
          id = ores[tile.ore].id,
          total_ore = max_ore,
          ore_remaining = max_ore,
          wx = wx,
          wy = wy,
        }
        ORES[k] = ore
      end
      if ORES[k].ore_remaining > 0 then
        ORES[k].ore_remaining = ORES[k].ore_remaining - 1
        ui.new_alert(cursor.x, cursor.y, '+ 1 ' .. ITEMS[ORES[k].id].fancy_name, 1000, 0, 6)
        inv:add_item({id = ORES[k].id, count = 1}, 1)
        sound('delete')
      end
      if ORES[k].ore_remaining < 1 then
        TileManager:set_tile(wx, wy)
      end
    end
    -- local result = rocks[tostring(tile.sprite_id)]
    -- if result then
    --   --deposit stone ore to inventory
    --   local _, stack = inv:add_item({id = 5, count = floor(math.random(result[1], result[2]))})
    --   TileMan:set_tile(wx, wy)
    -- end
    -- if stack then
    --   --TODO: deposit remaing stack to ground
    -- end
  end
end

function set_cursor_item(stack, slot)
  if not stack then
    cursor.item = false
    cursor.item_stack.id = 0
    cursor.item_stack.count = 0
    cursor.item_stack.slot = cursor.item_stack.slot or false
    cursor.type = 'pointer'
  else
    cursor.type = 'item'
    cursor.item_stack.id = stack.id
    cursor.item_stack.count = stack.count
    cursor.item_stack.slot = slot
    cursor.item = ITEMS[stack.id].type == 'placeable' and ITEMS[stack.id].name or false
  end
end

-- trace('Q pressed')
-- trace('cursor.item_stack.id = ' .. tostring(cursor.item_stack.id))
-- trace('cursor.item_stack.count = ' .. tostring(cursor.item_stack.count))
-- trace('cursor.item_stack.slot = ' .. tostring(cursor.item_stack.slot or false))
-- trace('inv.active_slot = ' .. tostring(inv.active_slot))
function pipette()
  if cursor.type == 'pointer' then
    local k = get_ent(cursor.x, cursor.y)
    local ent = ENTS[k]
    if ent then
      if dummies[ent.type] then
        ent = ENTS[ent.other_key]
      end
      for i = 57, #inv.slots do
        if inv.slots[i].id == ENTS[k].item_id then
          cursor.type = 'item'
          cursor.item = ent.type
          cursor.item_stack = {id = inv.slots[i].id, count = inv.slots[i].count, slot = i}
          -- inv.slots[i].id = 0
          -- inv.slots[i].count = 0
          if ent.rot then
            cursor.rot = ent.rot
          end
          if i > 56 then inv.active_slot = i - 56 end
          return
        end
      end
      for i = 1, #inv.slots - INVENTORY_COLS do
        if inv.slots[i].id == ENTS[k].item_id then
          cursor.type = 'item'
          cursor.item = ent.type
          cursor.item_stack = {id = inv.slots[i].id, count = inv.slots[i].count, slot = i}
          -- inv.slots[i].id = 0
          -- inv.slots[i].count = 0
          if ent.rot then
            cursor.rot = ent.rot
          end
          if i > 56 then inv.active_slot = i - 56 end
          return
        end
      end
      -- cursor.type = 'item'
      -- cursor.item = ent.type
      -- cursor.item_stack = {id = ent.id, count = 5}
      -- if ent.rot then
      --   cursor.rot = ent.rot
      -- end
      -- return
    elseif cursor.item_stack.slot and inv.slots[cursor.item_stack.slot].id ~= 0 then
      set_cursor_item({id = inv.slots[cursor.item_stack.slot].id, count = inv.slots[cursor.item_stack.slot].count}, cursor.item_stack.slot)
      -- inv.slots[cursor.item_stack.slot].id = 0
      -- inv.slots[cursor.item_stack.slot].count = 0
    end
  elseif cursor.type == 'item' then
    if not cursor.item_stack.slot then
      inv:add_item({id = cursor.item_stack.id, count = cursor.item_stack.count})
    else
      inv.slots[cursor.item_stack.slot].id = cursor.item_stack.id
      inv.slots[cursor.item_stack.slot].count = cursor.item_stack.count
    end
    set_cursor_item()
    -- cursor.item = false
    -- cursor.item_stack.id = 0
    -- cursor.item_stack.count = 0
    -- cursor.type = 'pointer'
  end
end

function update_cursor_state()
  local x, y, l, m, r, sx, sy = mouse()
  local _, wx, wy = get_world_cell(x, y)
  local tx, ty = world_to_screen(wx, wy)
  --update hold state for left and right click
  if l and cursor.l and not cursor.held_left and not cursor.r then
    cursor.held_left = true
  end

  if r and cursor.r and not cursor.held_right and not cursor.l then
    cursor.held_right = true
  end

  if cursor.held_left or cursor.held_right then
    cursor.hold_time = cursor.hold_time + 1
  end

  if not l and cursor.held_left then
    cursor.held_left = false
    cursor.hold_time = 0
  end

  if not r and cursor.held_right then
    cursor.held_right = false
    cursor.hold_time = 0
  end

  cursor.ltx, cursor.lty = cursor.tx, cursor.ty
  cursor.wx, cursor.wy, cursor.tx, cursor.ty, cursor.sx, cursor.sy = wx, wy, tx, ty, sx, sy
  cursor.lx, cursor.ly, cursor.ll, cursor.lm, cursor.lr, cursor.lsx, cursor.lsy = cursor.x, cursor.y, cursor.l, cursor.m, cursor.r, cursor.sx, cursor.sy
  cursor.x, cursor.y, cursor.l, cursor.m, cursor.r, cursor.sx, cursor.sy = x, y, l, m, r, sx, sy
  if cursor.tx ~= cursor.ltx or cursor.ty ~= cursor.lty then
    cursor.hold_time = 0
  end
end

function dispatch_keypress()
  --F
  --if key(6) then add_item(cursor.x, cursor.y, 1) end
  --G
  --if key(7) then rota(cursor.x, cursor.y, 2) end
  --M
  if keyp(13) then show_mini_map = not show_mini_map end
  --R
  if keyp(18) then
    if not key(64) then
      rotate_cursor('r')
    else
      rotate_cursor('l')
    end
  end
  --Q
  if keyp(17) then pipette() end
  --I or TAB
  if keyp(9) or keyp(49) then inv.vis = not inv.vis end
  --H
  if keyp(8) then toggle_hotbar() end
  --C
  if keyp(3) then toggle_crafting() end
  --Y
  if keyp(25) then debug = not debug end
  --SHIFT
  show_tile_widget = key(64)
  --ALT
  if keyp(65) then alt_mode = not alt_mode end
  --CTRL
  if key(64) and keyp(65) then show_count = not show_count end
  if keyp(15) then show_help = not show_help end
  --E
  --if keyp(5) then inv:add_item({id = 1, count = 10}) end
  --T
  if keyp(20) then
    show_tech = not show_tech
    if show_tech then
      biome = 10
      --poke(0x03FF8, UI_FG)
    end
  end
  --0-9
  for i = 1, INVENTORY_COLS do
    local key_n = 27 + i
    if keyp(key_n) then set_active_slot(i) end
  end
end

function dispatch_input()
  update_cursor_state()
  dispatch_keypress()
  if show_tech then

    return
  end

  local tile, wx, wy = get_world_cell(cursor.x, cursor.y)
  local k = get_ent(cursor.x, cursor.y)
  if ENTS[k] then ENTS[k].is_hovered = true end
  if cursor.sy ~= 0 then cycle_hotbar(cursor.sy*-1) end
  if not cursor.l then
    cursor.panel_drag = false
    cursor.drag = false
  end
  
  --begin mouse-over priority dispatch
  if ui.active_window and ui.active_window:is_hovered(cursor.x, cursor.y) then
    if (cursor.l and not cursor.ll) or (cursor.r and not cursor.lr) then
      if ui.active_window:click(cursor.x, cursor.y) then
        --trace('clicked active window')
      end
    end
    return
  end
  
  if craft_menu.vis and craft_menu:is_hovered(cursor.x, cursor.y) then
    if cursor.l and not cursor.ll then
      if craft_menu:click(cursor.x, cursor.y, 'left') then return end
    elseif cursor.r and cursor.lr then
      if craft_menu:click(cursor.x, cursor.y, 'right') then return end
    end
    if craft_menu.vis and cursor.panel_drag then
      craft_menu.x = math.max(1, math.min(cursor.x + cursor.drag_offset.x, 239 - craft_menu.w))
      craft_menu.y = math.max(1, math.min(cursor.y + cursor.drag_offset.y, 135 - craft_menu.h))
      return
      --consumed = true
    end
    if craft_menu.vis and not cursor.panel_drag and cursor.l and not cursor.ll and craft_menu:is_hovered(cursor.x, cursor.y) then
      if craft_menu:click(cursor.x, cursor.y) then
        return
      elseif not craft_menu.docked then
        cursor.panel_drag = true
        cursor.drag_offset.x = craft_menu.x - cursor.x
        cursor.drag_offset.y = craft_menu.y - cursor.y
        return
      end
    end
    return
  end
  
  if inv:is_hovered(cursor.x, cursor.y) then
    if (cursor.l and not cursor.ll) or (cursor.r and not cursor.lr) then
      inv:clicked(cursor.x, cursor.y)
    end
    return
  end

  if cursor.type == 'item' and cursor.item_stack.id ~= 0 then
    --check other visible widgets
    local item = ITEMS[cursor.item_stack.id]
    local count = cursor.item_stack.count
    --check for ents to deposit item stack
    if key(63) and ENTS[k] and ENTS[k].deposit_stack then --TODO
      if cursor.r and not cursor.lr then
        local result, stack = ENTS[k]:deposit_stack({id = cursor.item_stack.id, count = 1})
        if result then
          cursor.item_stack.count = cursor.item_stack.count - 1
          if cursor.item_stack.slot then
            inv.slots[cursor.item_stack.slot].count = inv.slots[cursor.item_stack.slot].count - 1
            if inv.slots[cursor.item_stack.slot].count < 1 then
              inv.slots[cursor.item_stack.slot].count = 0
              inv.slots[cursor.item_stack.slot].id = 0
            end
          end
          ui.new_alert(cursor.x, cursor.y, '-1 ' .. ITEMS[cursor.item_stack.id].fancy_name, 1000, 0, 6)
          sound('deposit')
          if cursor.item_stack.count < 1 then
            set_cursor_item()
          end
        end
      elseif cursor.l and not cursor.ll then
        local result, stack = ENTS[k]:deposit_stack(cursor.item_stack)
        local old_stack = {id = cursor.item_stack.id, count = cursor.item_stack.count}
        if stack.count == 0 then
          if cursor.item_stack.slot then
            inv.slots[cursor.item_stack.slot].count = 0
            inv.slots[cursor.item_stack.slot].id = 0
          end
          ui.new_alert(cursor.x, cursor.y, -old_stack.count .. ' ' .. ITEMS[old_stack.id].fancy_name, 1000, 0, 6)
          sound('deposit')
          set_cursor_item()
        else
          ui.new_alert(cursor.x, cursor.y, '- ' .. (old_stack.count - stack.count) .. ' ' .. ITEMS[old_stack.id].fancy_name, 1000, 0, 6)
          sound('deposit')
          cursor.item_stack.count = stack.count
          if cursor.item_stack.slot then
            inv.slots[cursor.item_stack.slot].count = stack.count
          end
        end
      end
      return
      --if item is placeable, run callback for item type
      --checking transport_belt's first (for drag-placement), then other items
    else
      if cursor.l and cursor.item == 'transport_belt' and (cursor.tx ~= cursor.ltx or cursor.ty ~= cursor.lty)  then
        --trace('placing belt')
        local slot = cursor.item_stack.slot
        local item_consumed = callbacks[cursor.item].place_item(cursor.x, cursor.y)
        if slot and item_consumed then
          inv.slots[slot].count = inv.slots[slot].count - 1
          cursor.item_stack.count = inv.slots[slot].count
        elseif item_consumed ~= false then
          cursor.item_stack.count = cursor.item_stack.count - 1
          if cursor.item_stack.count < 1 then
            set_cursor_item()
          end
        end
        if slot and inv.slots[slot].count < 1 then
          inv.slots[slot].id = 0
          inv.slots[slot].count = 0
          set_cursor_item()
        end
        return
      elseif cursor.l and not cursor.ll and ITEMS[cursor.item_stack.id].type == 'placeable' then
        if callbacks[cursor.item] then
          local item_consumed = callbacks[cursor.item].place_item(cursor.x, cursor.y)
          if item_consumed ~= false then
            cursor.item_stack.count = cursor.item_stack.count - 1
            if cursor.item_stack.count < 1 then
              set_cursor_item()
            end
            if cursor.item_stack.slot then
              inv.slots[cursor.item_stack.slot].count = inv.slots[cursor.item_stack.slot].count - 1
              if inv.slots[cursor.item_stack.slot].count < 1 then
                inv.slots[cursor.item_stack.slot].id = 0
                inv.slots[cursor.item_stack.slot].count = 0
                set_cursor_item()
              end
            end
          end
        end
        return
      elseif cursor.r then
        --remove_tile(cursor.x, cursor.y)
        return
      end
    end
  elseif cursor.type == 'pointer' then
    if cursor.l and not cursor.ll and key(63) and ENTS[k] and ENTS[k].return_all then
      --try to take all items
      ENTS[k]:return_all()
      return
    end
  end

  if cursor.held_right and cursor.type == 'pointer' then
    local sx, sy = get_screen_cell(cursor.x, cursor.y)
    local tile, wx, wy = get_world_cell(cursor.x, cursor.y)
    local result = resources[tostring(tile.sprite_id)]
    local k = get_ent(cursor.x, cursor.y)
    if not result and not tile.is_tree and not ENTS[k] and not tile.ore then cursor.prog = false return end
    if tick % 4 == 0 then
      local px, py = sx + 4, sy + 4
      line(120, 67 + player.anim_frame, px, py, floor(math.random(1, 3) + 0.5))
      for i = 1, 3 do
        local rr = 1 + floor((math.random() + 0.5) * 4)
        local rc = 1 + floor((math.random(6) + 0.5))
        circb(px, py, rr, rc)
      end
    end
    if tile.is_tree then
      local c1, c2 = 3, 4
      if tile.biome < 2 then c1, c2 = 2, 3 end
      ui.highlight(cursor.tx - 9 + tile.offset.x, cursor.ty - 27 + tile.offset.y, 24, 32, false, c1, c2)
      ui.highlight(cursor.tx + tile.offset.x - 2, cursor.ty - 1 + tile.offset.y, 8, 8, false, c1, c2)
    end
    if result or tile.ore or ENTS[k] then
      ui.highlight(sx - 1, sy - 1, 8, 8, false, 3, 4)
    end
    if (ENTS[k] or tile.is_tree or tile.ore or result) then
      sound('laser')
      cursor.prog = remap(clamp(cursor.hold_time, 0, CURSOR_MINING_SPEED), 0, CURSOR_MINING_SPEED, 0, 9)
      if cursor.prog >= 9 then
        remove_tile(cursor.x, cursor.y)
        cursor.prog = false
        cursor.held_right = false
        cursor.hold_time = 0
        return
      end
    end
  else
    cursor.prog = false
  end

    --check for held item placement/deposit to other ents
  if cursor.l and not cursor.ll and not craft_menu:is_hovered(cursor.x, cursor.y) and inv:is_hovered(cursor.x, cursor.y) then
    local slot = inv:get_hovered_slot(cursor.x, cursor.y)
    if slot then
      inv.slots[slot.index]:callback()
      return
    end
  end

  if cursor.l and not cursor.ll and ENTS[k] then

    if dummies[ENTS[k].type] then
      k = ENTS[k].other_key
    end

    if opensies[ENTS[k].type] then
      if key(63) and cursor.type == 'pointer' then
        
      end
      if key(64) and cursor.type == 'item' and ENTS[k].deposit_stack then
        local old_stack = cursor.item_stack
        local result, stack = ENTS[k]:deposit_stack(cursor.item_stack)
        if result then
          if stack then
            if stack.count > 0 then
              cursor.item_stack.count = stack.count
            else
              cursor.item_stack = {id = 0, count = 0, slot = false}
              cursor.type = 'pointer'
            end
            sound('deposit')
            ui.new_alert(cursor.x, cursor.y, stack.count - old_stack.count .. ' ' .. ITEMS[old_stack.id].fancy_name, 1000, 0, 2)
          end
        end
      else
        ui.active_window = ENTS[k]:open()
      end
    end
    return
  end
end

function render_cursor_progress()
  if not cursor.prog or not cursor.r then return end
  cursor.prog = remap(clamp(cursor.hold_time, 0, CURSOR_MINING_SPEED), 0, CURSOR_MINING_SPEED, 0, 9)
  rect(cursor.x - 4, cursor.y + 7, 9, 2, 0)
  rect(cursor.x - 4, cursor.y + 7, cursor.prog, 2, floor(remap(cursor.prog, 0, 9, 2, 7))+0.5)
  prints(cursor.hold_time, cursor.x - 4, cursor.y + 10)
end

function toggle_hotbar()
  if not inv.hotbar_vis then
    inv.hotbar_vis = true
  else
    inv.hotbar_vis = false
    inv.hovered_slot = -1
  end
end

function toggle_crafting(force)
  if force then craft_menu.vis = true else craft_menu.vis = not craft_menu.vis end
end

function update_ents()
  for k, v in pairs(ENTS) do
    if v.update and tick % v.tickrate == 0 then
      v:update()
    end
  end
end

function update_rockets()
  for k, rocket in pairs(rockets) do
    rocket:update()
    rocket:draw()
  end
end

function first_launch(rocket)
  STATE = 'first_launch'
  trace('You won!')
end

function draw_ents()
  if show_mini_map or show_help or STATE ~= 'game' then return end
  for i, k in pairs(vis_ents['transport_belt']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  local start = time()
  for i, k in pairs(vis_ents['transport_belt']) do
    if ENTS[k] then ENTS[k]:draw_items() end
  end
  db_time = floor((time() - start) * 1000)
  for i, k in pairs(vis_ents['stone_furnace']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['underground_belt']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['underground_belt']) do
    if ENTS[k] then ENTS[k]:draw_items() end
  end
  for i, k in pairs(vis_ents['splitter']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['mining_drill']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['assembly_machine']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['research_lab']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['chest']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['rocket_silo']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['bio_refinery']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  for i, k in pairs(vis_ents['inserter']) do
    if ENTS[k] then ENTS[k]:draw() end
  end
  -- for i, k in pairs(vis_ents['power_pole']) do
  --   if ENTS[k] then ENTS[k]:draw() end
  -- end
end

function draw_terrain()
  TileMan:draw_terrain(player, 31, 18)
end

function lapse(fn, ...)
	local t = time()
	fn(...)
	return floor((time() - t))
end

-- local nums = {}
-- for i = 1, 45 do
--   nums[i] = false
-- end
-- local missing = {}
-- for k, v in ipairs(starting_unlocked_items) do
--   nums[v] = true
-- end
-- for k, v in ipairs(TECH) do
--   for a, item in ipairs(v.item_unlocks) do
--     nums[item] = true
--   end
-- end

-- for i = 1, 45 do
--   if nums[i] == false then
--     table.insert(missing, i)
--   end
-- end

-- trace('missing items from crafting tabs: {' .. table.concat(missing, ',') .. '}')

-- for i = 1, 5 do
--   inv:add_item({id = 32, count = 199}, 2)
-- end

function TIC()
  local dt = time() - last_frame_time
  last_frame_time = time()
  if not loaded then
    load_sprites()
    return
  end
  current_recipe = {x = 0, y = 0, id = 0}
  --change mouse cursor
  poke(0x3FFB, 286)

  --draw main menu
  if STATE == "start" or STATE == 'help' then
    update_cursor_state()
    ui.draw_menu()
    tick = tick + 1
    return
  end

  if STATE == 'first_launch' then
    update_cursor_state()
    ui:draw_endgame_window()
    tick = tick + 1
    return
  end
  
  local start = time()
  update_water_effect(time())
  cls(0)

  local m_time = 0
  local gv_time = lapse(get_visible_ents)
  local m_time = lapse(draw_terrain)

  local up_time = lapse(update_player, dt)
  local hi_time = lapse(dispatch_input, dt)

  if tick % BELT_TICKRATE == 0 then
    BELT_TICK = BELT_TICK + 1
    if BELT_TICK > BELT_MAXTICK then BELT_TICK = 0 end
  end

  if tick % UBELT_TICKRATE == 0 then
    UBELT_TICK = UBELT_TICK + 1
    if UBELT_TICK > UBELT_MAXTICK then UBELT_TICK = 0 end
  end

  if tick % DRILL_TICK_RATE == 0 then
    DRILL_BIT_TICK = DRILL_BIT_TICK + DRILL_BIT_DIR
    if DRILL_BIT_TICK > 7 or DRILL_BIT_TICK < 0 then DRILL_BIT_DIR = DRILL_BIT_DIR * -1 end
    DRILL_ANIM_TICK = DRILL_ANIM_TICK + 1
    if DRILL_ANIM_TICK > 2 then DRILL_ANIM_TICK = 0 end
  end

  if tick % FURNACE_ANIM_TICKRATE == 0 then
    FURNACE_ANIM_TICK = FURNACE_ANIM_TICK + 1
    for y = 0, 3 do
      set_sprite_pixel(490, 0, y, floor(math.random(2, 4)))
      set_sprite_pixel(490, 1, y, floor(math.random(2, 4)))
    end
    if FURNACE_ANIM_TICK > FURNACE_ANIM_TICKS then
      FURNACE_ANIM_TICK = 0
    end
  end

  if tick % CRAFTER_ANIM_RATE == 0 then
    CRAFTER_ANIM_FRAME = CRAFTER_ANIM_FRAME + CRAFTER_ANIM_DIR
    if CRAFTER_ANIM_FRAME > 5 then
      CRAFTER_ANIM_DIR = -1
    elseif CRAFTER_ANIM_FRAME < 1 then
      CRAFTER_ANIM_DIR = 1
    end
  end

  local ue_time = lapse(update_ents)
  local de_time = lapse(draw_ents)
  local dcl_time = 0
  if not show_mini_map then
    local st_time = time()
    TileMan:draw_clutter(player, 32, 21)
    dcl_time = floor(time() - st_time)
  end
  particles()

  draw_player()

  local x, y, l, m, r = mouse()
  local col = 5
  if r then col = 2 end
  if not show_mini_map then
    inv:draw()
    craft_menu:draw()
    if ui.active_window then
      if ENTS[ui.active_window.ent_key] then
        ui.active_window:draw()
      else
        ui.active_window = nil
      end
    end
  end
  local dc_time = lapse(draw_cursor)
  local info = {
    [1] = 'draw_clutter: ' .. dcl_time,
    [2] = 'draw_terrain: ' .. m_time,
    [3] = 'update_player: ' .. up_time,
    [4] = 'handle_input: ' .. hi_time,
    [5] = 'draw_ents: ' .. de_time,
    [6] = 'update_ents:' .. ue_time,
    [7] = 'draw_cursor: ' .. dc_time,    
    [8] = 'draw_belt_items: ' .. db_time,
    [9] = 'get_vis_ents: ' .. gv_time,
  }
  local ents = 0
  for k, v in pairs(vis_ents) do
    for _, ent in ipairs(v) do
      ents = ents + 1
    end
  end

  info[9] = 0
  if show_mini_map then
    local st_time = time()
    TileMan:draw_worldmap(player, 0, 0, 192, 109, true)
    pix(121, 69, 2)
    info[9] = 'draw_worldmap: ' .. floor(time() - st_time) .. 'ms'
  end

  local tile, wx, wy = get_world_cell(cursor.x, cursor.y)
  local sx, sy = get_screen_cell(cursor.x, cursor.y)
  local k
  info[10] = 'Frame Time: ' .. floor(time() - start) .. 'ms'
  info[11] = 'Seed: ' .. seed
  info[12] = 'hold time: ' .. cursor.hold_time
  local _, wx, wy  = get_world_cell(cursor.tx, cursor.ty)
  local k = wx .. '-' .. wy
  if key(64) and ENTS[k] and not inv:is_hovered(cursor.x, cursor.y) then
    if ENTS[k].type == 'underground_belt_exit' then
      ENTS[ENTS[k].other_key]:draw_hover_widget(k)
    else
      k = get_ent(cursor.x, cursor.y)
      if ENTS[k] then ENTS[k]:draw_hover_widget() end
    end
  end
  for k, v in pairs(ENTS) do
    v.updated = false
    v.drawn = false
    v.is_hovered = false
    if v.type == 'transport_belt' then v.belt_drawn = false; v.curve_checked = false; end
  end
  if show_tech then draw_research_screen() end
  if debug then ui.draw_text_window(info, 2, 2, 'Debug - Y to toggle', 0, 2, 0, 4) end
  if show_tile_widget and not ENTS[k] then draw_tile_widget() end
  if current_recipe.id > 0 then
    show_recipe_widget()
  end
  render_cursor_progress()
  ui.update_alerts()
  
  update_rockets()
  if show_help then ui:draw_help_screen() end
  tick = tick + 1
end

--11488